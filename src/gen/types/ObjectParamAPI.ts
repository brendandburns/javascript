import { ResponseContext, RequestContext, HttpFile, HttpInfo } from '../http/http.js';
import { Configuration, ConfigurationOptions } from '../configuration.js'
import type { Middleware } from '../middleware.js';

import { AdmissionregistrationV1ServiceReference } from '../models/AdmissionregistrationV1ServiceReference.js';
import { AdmissionregistrationV1WebhookClientConfig } from '../models/AdmissionregistrationV1WebhookClientConfig.js';
import { ApiextensionsV1ServiceReference } from '../models/ApiextensionsV1ServiceReference.js';
import { ApiextensionsV1WebhookClientConfig } from '../models/ApiextensionsV1WebhookClientConfig.js';
import { ApiregistrationV1ServiceReference } from '../models/ApiregistrationV1ServiceReference.js';
import { AuthenticationV1TokenRequest } from '../models/AuthenticationV1TokenRequest.js';
import { CoreV1EndpointPort } from '../models/CoreV1EndpointPort.js';
import { CoreV1Event } from '../models/CoreV1Event.js';
import { CoreV1EventList } from '../models/CoreV1EventList.js';
import { CoreV1EventSeries } from '../models/CoreV1EventSeries.js';
import { DiscoveryV1EndpointPort } from '../models/DiscoveryV1EndpointPort.js';
import { EventsV1Event } from '../models/EventsV1Event.js';
import { EventsV1EventList } from '../models/EventsV1EventList.js';
import { EventsV1EventSeries } from '../models/EventsV1EventSeries.js';
import { FlowcontrolV1Subject } from '../models/FlowcontrolV1Subject.js';
import { RbacV1Subject } from '../models/RbacV1Subject.js';
import { StorageV1TokenRequest } from '../models/StorageV1TokenRequest.js';
import { V1APIGroup } from '../models/V1APIGroup.js';
import { V1APIGroupList } from '../models/V1APIGroupList.js';
import { V1APIResource } from '../models/V1APIResource.js';
import { V1APIResourceList } from '../models/V1APIResourceList.js';
import { V1APIService } from '../models/V1APIService.js';
import { V1APIServiceCondition } from '../models/V1APIServiceCondition.js';
import { V1APIServiceList } from '../models/V1APIServiceList.js';
import { V1APIServiceSpec } from '../models/V1APIServiceSpec.js';
import { V1APIServiceStatus } from '../models/V1APIServiceStatus.js';
import { V1APIVersions } from '../models/V1APIVersions.js';
import { V1AWSElasticBlockStoreVolumeSource } from '../models/V1AWSElasticBlockStoreVolumeSource.js';
import { V1Affinity } from '../models/V1Affinity.js';
import { V1AggregationRule } from '../models/V1AggregationRule.js';
import { V1AppArmorProfile } from '../models/V1AppArmorProfile.js';
import { V1AttachedVolume } from '../models/V1AttachedVolume.js';
import { V1AuditAnnotation } from '../models/V1AuditAnnotation.js';
import { V1AzureDiskVolumeSource } from '../models/V1AzureDiskVolumeSource.js';
import { V1AzureFilePersistentVolumeSource } from '../models/V1AzureFilePersistentVolumeSource.js';
import { V1AzureFileVolumeSource } from '../models/V1AzureFileVolumeSource.js';
import { V1Binding } from '../models/V1Binding.js';
import { V1BoundObjectReference } from '../models/V1BoundObjectReference.js';
import { V1CSIDriver } from '../models/V1CSIDriver.js';
import { V1CSIDriverList } from '../models/V1CSIDriverList.js';
import { V1CSIDriverSpec } from '../models/V1CSIDriverSpec.js';
import { V1CSINode } from '../models/V1CSINode.js';
import { V1CSINodeDriver } from '../models/V1CSINodeDriver.js';
import { V1CSINodeList } from '../models/V1CSINodeList.js';
import { V1CSINodeSpec } from '../models/V1CSINodeSpec.js';
import { V1CSIPersistentVolumeSource } from '../models/V1CSIPersistentVolumeSource.js';
import { V1CSIStorageCapacity } from '../models/V1CSIStorageCapacity.js';
import { V1CSIStorageCapacityList } from '../models/V1CSIStorageCapacityList.js';
import { V1CSIVolumeSource } from '../models/V1CSIVolumeSource.js';
import { V1Capabilities } from '../models/V1Capabilities.js';
import { V1CephFSPersistentVolumeSource } from '../models/V1CephFSPersistentVolumeSource.js';
import { V1CephFSVolumeSource } from '../models/V1CephFSVolumeSource.js';
import { V1CertificateSigningRequest } from '../models/V1CertificateSigningRequest.js';
import { V1CertificateSigningRequestCondition } from '../models/V1CertificateSigningRequestCondition.js';
import { V1CertificateSigningRequestList } from '../models/V1CertificateSigningRequestList.js';
import { V1CertificateSigningRequestSpec } from '../models/V1CertificateSigningRequestSpec.js';
import { V1CertificateSigningRequestStatus } from '../models/V1CertificateSigningRequestStatus.js';
import { V1CinderPersistentVolumeSource } from '../models/V1CinderPersistentVolumeSource.js';
import { V1CinderVolumeSource } from '../models/V1CinderVolumeSource.js';
import { V1ClientIPConfig } from '../models/V1ClientIPConfig.js';
import { V1ClusterRole } from '../models/V1ClusterRole.js';
import { V1ClusterRoleBinding } from '../models/V1ClusterRoleBinding.js';
import { V1ClusterRoleBindingList } from '../models/V1ClusterRoleBindingList.js';
import { V1ClusterRoleList } from '../models/V1ClusterRoleList.js';
import { V1ClusterTrustBundleProjection } from '../models/V1ClusterTrustBundleProjection.js';
import { V1ComponentCondition } from '../models/V1ComponentCondition.js';
import { V1ComponentStatus } from '../models/V1ComponentStatus.js';
import { V1ComponentStatusList } from '../models/V1ComponentStatusList.js';
import { V1Condition } from '../models/V1Condition.js';
import { V1ConfigMap } from '../models/V1ConfigMap.js';
import { V1ConfigMapEnvSource } from '../models/V1ConfigMapEnvSource.js';
import { V1ConfigMapKeySelector } from '../models/V1ConfigMapKeySelector.js';
import { V1ConfigMapList } from '../models/V1ConfigMapList.js';
import { V1ConfigMapNodeConfigSource } from '../models/V1ConfigMapNodeConfigSource.js';
import { V1ConfigMapProjection } from '../models/V1ConfigMapProjection.js';
import { V1ConfigMapVolumeSource } from '../models/V1ConfigMapVolumeSource.js';
import { V1Container } from '../models/V1Container.js';
import { V1ContainerImage } from '../models/V1ContainerImage.js';
import { V1ContainerPort } from '../models/V1ContainerPort.js';
import { V1ContainerResizePolicy } from '../models/V1ContainerResizePolicy.js';
import { V1ContainerState } from '../models/V1ContainerState.js';
import { V1ContainerStateRunning } from '../models/V1ContainerStateRunning.js';
import { V1ContainerStateTerminated } from '../models/V1ContainerStateTerminated.js';
import { V1ContainerStateWaiting } from '../models/V1ContainerStateWaiting.js';
import { V1ContainerStatus } from '../models/V1ContainerStatus.js';
import { V1ContainerUser } from '../models/V1ContainerUser.js';
import { V1ControllerRevision } from '../models/V1ControllerRevision.js';
import { V1ControllerRevisionList } from '../models/V1ControllerRevisionList.js';
import { V1CronJob } from '../models/V1CronJob.js';
import { V1CronJobList } from '../models/V1CronJobList.js';
import { V1CronJobSpec } from '../models/V1CronJobSpec.js';
import { V1CronJobStatus } from '../models/V1CronJobStatus.js';
import { V1CrossVersionObjectReference } from '../models/V1CrossVersionObjectReference.js';
import { V1CustomResourceColumnDefinition } from '../models/V1CustomResourceColumnDefinition.js';
import { V1CustomResourceConversion } from '../models/V1CustomResourceConversion.js';
import { V1CustomResourceDefinition } from '../models/V1CustomResourceDefinition.js';
import { V1CustomResourceDefinitionCondition } from '../models/V1CustomResourceDefinitionCondition.js';
import { V1CustomResourceDefinitionList } from '../models/V1CustomResourceDefinitionList.js';
import { V1CustomResourceDefinitionNames } from '../models/V1CustomResourceDefinitionNames.js';
import { V1CustomResourceDefinitionSpec } from '../models/V1CustomResourceDefinitionSpec.js';
import { V1CustomResourceDefinitionStatus } from '../models/V1CustomResourceDefinitionStatus.js';
import { V1CustomResourceDefinitionVersion } from '../models/V1CustomResourceDefinitionVersion.js';
import { V1CustomResourceSubresourceScale } from '../models/V1CustomResourceSubresourceScale.js';
import { V1CustomResourceSubresources } from '../models/V1CustomResourceSubresources.js';
import { V1CustomResourceValidation } from '../models/V1CustomResourceValidation.js';
import { V1DaemonEndpoint } from '../models/V1DaemonEndpoint.js';
import { V1DaemonSet } from '../models/V1DaemonSet.js';
import { V1DaemonSetCondition } from '../models/V1DaemonSetCondition.js';
import { V1DaemonSetList } from '../models/V1DaemonSetList.js';
import { V1DaemonSetSpec } from '../models/V1DaemonSetSpec.js';
import { V1DaemonSetStatus } from '../models/V1DaemonSetStatus.js';
import { V1DaemonSetUpdateStrategy } from '../models/V1DaemonSetUpdateStrategy.js';
import { V1DeleteOptions } from '../models/V1DeleteOptions.js';
import { V1Deployment } from '../models/V1Deployment.js';
import { V1DeploymentCondition } from '../models/V1DeploymentCondition.js';
import { V1DeploymentList } from '../models/V1DeploymentList.js';
import { V1DeploymentSpec } from '../models/V1DeploymentSpec.js';
import { V1DeploymentStatus } from '../models/V1DeploymentStatus.js';
import { V1DeploymentStrategy } from '../models/V1DeploymentStrategy.js';
import { V1DownwardAPIProjection } from '../models/V1DownwardAPIProjection.js';
import { V1DownwardAPIVolumeFile } from '../models/V1DownwardAPIVolumeFile.js';
import { V1DownwardAPIVolumeSource } from '../models/V1DownwardAPIVolumeSource.js';
import { V1EmptyDirVolumeSource } from '../models/V1EmptyDirVolumeSource.js';
import { V1Endpoint } from '../models/V1Endpoint.js';
import { V1EndpointAddress } from '../models/V1EndpointAddress.js';
import { V1EndpointConditions } from '../models/V1EndpointConditions.js';
import { V1EndpointHints } from '../models/V1EndpointHints.js';
import { V1EndpointSlice } from '../models/V1EndpointSlice.js';
import { V1EndpointSliceList } from '../models/V1EndpointSliceList.js';
import { V1EndpointSubset } from '../models/V1EndpointSubset.js';
import { V1Endpoints } from '../models/V1Endpoints.js';
import { V1EndpointsList } from '../models/V1EndpointsList.js';
import { V1EnvFromSource } from '../models/V1EnvFromSource.js';
import { V1EnvVar } from '../models/V1EnvVar.js';
import { V1EnvVarSource } from '../models/V1EnvVarSource.js';
import { V1EphemeralContainer } from '../models/V1EphemeralContainer.js';
import { V1EphemeralVolumeSource } from '../models/V1EphemeralVolumeSource.js';
import { V1EventSource } from '../models/V1EventSource.js';
import { V1Eviction } from '../models/V1Eviction.js';
import { V1ExecAction } from '../models/V1ExecAction.js';
import { V1ExemptPriorityLevelConfiguration } from '../models/V1ExemptPriorityLevelConfiguration.js';
import { V1ExpressionWarning } from '../models/V1ExpressionWarning.js';
import { V1ExternalDocumentation } from '../models/V1ExternalDocumentation.js';
import { V1FCVolumeSource } from '../models/V1FCVolumeSource.js';
import { V1FieldSelectorAttributes } from '../models/V1FieldSelectorAttributes.js';
import { V1FieldSelectorRequirement } from '../models/V1FieldSelectorRequirement.js';
import { V1FlexPersistentVolumeSource } from '../models/V1FlexPersistentVolumeSource.js';
import { V1FlexVolumeSource } from '../models/V1FlexVolumeSource.js';
import { V1FlockerVolumeSource } from '../models/V1FlockerVolumeSource.js';
import { V1FlowDistinguisherMethod } from '../models/V1FlowDistinguisherMethod.js';
import { V1FlowSchema } from '../models/V1FlowSchema.js';
import { V1FlowSchemaCondition } from '../models/V1FlowSchemaCondition.js';
import { V1FlowSchemaList } from '../models/V1FlowSchemaList.js';
import { V1FlowSchemaSpec } from '../models/V1FlowSchemaSpec.js';
import { V1FlowSchemaStatus } from '../models/V1FlowSchemaStatus.js';
import { V1ForNode } from '../models/V1ForNode.js';
import { V1ForZone } from '../models/V1ForZone.js';
import { V1GCEPersistentDiskVolumeSource } from '../models/V1GCEPersistentDiskVolumeSource.js';
import { V1GRPCAction } from '../models/V1GRPCAction.js';
import { V1GitRepoVolumeSource } from '../models/V1GitRepoVolumeSource.js';
import { V1GlusterfsPersistentVolumeSource } from '../models/V1GlusterfsPersistentVolumeSource.js';
import { V1GlusterfsVolumeSource } from '../models/V1GlusterfsVolumeSource.js';
import { V1GroupSubject } from '../models/V1GroupSubject.js';
import { V1GroupVersionForDiscovery } from '../models/V1GroupVersionForDiscovery.js';
import { V1HTTPGetAction } from '../models/V1HTTPGetAction.js';
import { V1HTTPHeader } from '../models/V1HTTPHeader.js';
import { V1HTTPIngressPath } from '../models/V1HTTPIngressPath.js';
import { V1HTTPIngressRuleValue } from '../models/V1HTTPIngressRuleValue.js';
import { V1HorizontalPodAutoscaler } from '../models/V1HorizontalPodAutoscaler.js';
import { V1HorizontalPodAutoscalerList } from '../models/V1HorizontalPodAutoscalerList.js';
import { V1HorizontalPodAutoscalerSpec } from '../models/V1HorizontalPodAutoscalerSpec.js';
import { V1HorizontalPodAutoscalerStatus } from '../models/V1HorizontalPodAutoscalerStatus.js';
import { V1HostAlias } from '../models/V1HostAlias.js';
import { V1HostIP } from '../models/V1HostIP.js';
import { V1HostPathVolumeSource } from '../models/V1HostPathVolumeSource.js';
import { V1IPAddress } from '../models/V1IPAddress.js';
import { V1IPAddressList } from '../models/V1IPAddressList.js';
import { V1IPAddressSpec } from '../models/V1IPAddressSpec.js';
import { V1IPBlock } from '../models/V1IPBlock.js';
import { V1ISCSIPersistentVolumeSource } from '../models/V1ISCSIPersistentVolumeSource.js';
import { V1ISCSIVolumeSource } from '../models/V1ISCSIVolumeSource.js';
import { V1ImageVolumeSource } from '../models/V1ImageVolumeSource.js';
import { V1Ingress } from '../models/V1Ingress.js';
import { V1IngressBackend } from '../models/V1IngressBackend.js';
import { V1IngressClass } from '../models/V1IngressClass.js';
import { V1IngressClassList } from '../models/V1IngressClassList.js';
import { V1IngressClassParametersReference } from '../models/V1IngressClassParametersReference.js';
import { V1IngressClassSpec } from '../models/V1IngressClassSpec.js';
import { V1IngressList } from '../models/V1IngressList.js';
import { V1IngressLoadBalancerIngress } from '../models/V1IngressLoadBalancerIngress.js';
import { V1IngressLoadBalancerStatus } from '../models/V1IngressLoadBalancerStatus.js';
import { V1IngressPortStatus } from '../models/V1IngressPortStatus.js';
import { V1IngressRule } from '../models/V1IngressRule.js';
import { V1IngressServiceBackend } from '../models/V1IngressServiceBackend.js';
import { V1IngressSpec } from '../models/V1IngressSpec.js';
import { V1IngressStatus } from '../models/V1IngressStatus.js';
import { V1IngressTLS } from '../models/V1IngressTLS.js';
import { V1JSONSchemaProps } from '../models/V1JSONSchemaProps.js';
import { V1Job } from '../models/V1Job.js';
import { V1JobCondition } from '../models/V1JobCondition.js';
import { V1JobList } from '../models/V1JobList.js';
import { V1JobSpec } from '../models/V1JobSpec.js';
import { V1JobStatus } from '../models/V1JobStatus.js';
import { V1JobTemplateSpec } from '../models/V1JobTemplateSpec.js';
import { V1KeyToPath } from '../models/V1KeyToPath.js';
import { V1LabelSelector } from '../models/V1LabelSelector.js';
import { V1LabelSelectorAttributes } from '../models/V1LabelSelectorAttributes.js';
import { V1LabelSelectorRequirement } from '../models/V1LabelSelectorRequirement.js';
import { V1Lease } from '../models/V1Lease.js';
import { V1LeaseList } from '../models/V1LeaseList.js';
import { V1LeaseSpec } from '../models/V1LeaseSpec.js';
import { V1Lifecycle } from '../models/V1Lifecycle.js';
import { V1LifecycleHandler } from '../models/V1LifecycleHandler.js';
import { V1LimitRange } from '../models/V1LimitRange.js';
import { V1LimitRangeItem } from '../models/V1LimitRangeItem.js';
import { V1LimitRangeList } from '../models/V1LimitRangeList.js';
import { V1LimitRangeSpec } from '../models/V1LimitRangeSpec.js';
import { V1LimitResponse } from '../models/V1LimitResponse.js';
import { V1LimitedPriorityLevelConfiguration } from '../models/V1LimitedPriorityLevelConfiguration.js';
import { V1LinuxContainerUser } from '../models/V1LinuxContainerUser.js';
import { V1ListMeta } from '../models/V1ListMeta.js';
import { V1LoadBalancerIngress } from '../models/V1LoadBalancerIngress.js';
import { V1LoadBalancerStatus } from '../models/V1LoadBalancerStatus.js';
import { V1LocalObjectReference } from '../models/V1LocalObjectReference.js';
import { V1LocalSubjectAccessReview } from '../models/V1LocalSubjectAccessReview.js';
import { V1LocalVolumeSource } from '../models/V1LocalVolumeSource.js';
import { V1ManagedFieldsEntry } from '../models/V1ManagedFieldsEntry.js';
import { V1MatchCondition } from '../models/V1MatchCondition.js';
import { V1MatchResources } from '../models/V1MatchResources.js';
import { V1ModifyVolumeStatus } from '../models/V1ModifyVolumeStatus.js';
import { V1MutatingWebhook } from '../models/V1MutatingWebhook.js';
import { V1MutatingWebhookConfiguration } from '../models/V1MutatingWebhookConfiguration.js';
import { V1MutatingWebhookConfigurationList } from '../models/V1MutatingWebhookConfigurationList.js';
import { V1NFSVolumeSource } from '../models/V1NFSVolumeSource.js';
import { V1NamedRuleWithOperations } from '../models/V1NamedRuleWithOperations.js';
import { V1Namespace } from '../models/V1Namespace.js';
import { V1NamespaceCondition } from '../models/V1NamespaceCondition.js';
import { V1NamespaceList } from '../models/V1NamespaceList.js';
import { V1NamespaceSpec } from '../models/V1NamespaceSpec.js';
import { V1NamespaceStatus } from '../models/V1NamespaceStatus.js';
import { V1NetworkPolicy } from '../models/V1NetworkPolicy.js';
import { V1NetworkPolicyEgressRule } from '../models/V1NetworkPolicyEgressRule.js';
import { V1NetworkPolicyIngressRule } from '../models/V1NetworkPolicyIngressRule.js';
import { V1NetworkPolicyList } from '../models/V1NetworkPolicyList.js';
import { V1NetworkPolicyPeer } from '../models/V1NetworkPolicyPeer.js';
import { V1NetworkPolicyPort } from '../models/V1NetworkPolicyPort.js';
import { V1NetworkPolicySpec } from '../models/V1NetworkPolicySpec.js';
import { V1Node } from '../models/V1Node.js';
import { V1NodeAddress } from '../models/V1NodeAddress.js';
import { V1NodeAffinity } from '../models/V1NodeAffinity.js';
import { V1NodeCondition } from '../models/V1NodeCondition.js';
import { V1NodeConfigSource } from '../models/V1NodeConfigSource.js';
import { V1NodeConfigStatus } from '../models/V1NodeConfigStatus.js';
import { V1NodeDaemonEndpoints } from '../models/V1NodeDaemonEndpoints.js';
import { V1NodeFeatures } from '../models/V1NodeFeatures.js';
import { V1NodeList } from '../models/V1NodeList.js';
import { V1NodeRuntimeHandler } from '../models/V1NodeRuntimeHandler.js';
import { V1NodeRuntimeHandlerFeatures } from '../models/V1NodeRuntimeHandlerFeatures.js';
import { V1NodeSelector } from '../models/V1NodeSelector.js';
import { V1NodeSelectorRequirement } from '../models/V1NodeSelectorRequirement.js';
import { V1NodeSelectorTerm } from '../models/V1NodeSelectorTerm.js';
import { V1NodeSpec } from '../models/V1NodeSpec.js';
import { V1NodeStatus } from '../models/V1NodeStatus.js';
import { V1NodeSwapStatus } from '../models/V1NodeSwapStatus.js';
import { V1NodeSystemInfo } from '../models/V1NodeSystemInfo.js';
import { V1NonResourceAttributes } from '../models/V1NonResourceAttributes.js';
import { V1NonResourcePolicyRule } from '../models/V1NonResourcePolicyRule.js';
import { V1NonResourceRule } from '../models/V1NonResourceRule.js';
import { V1ObjectFieldSelector } from '../models/V1ObjectFieldSelector.js';
import { V1ObjectMeta } from '../models/V1ObjectMeta.js';
import { V1ObjectReference } from '../models/V1ObjectReference.js';
import { V1Overhead } from '../models/V1Overhead.js';
import { V1OwnerReference } from '../models/V1OwnerReference.js';
import { V1ParamKind } from '../models/V1ParamKind.js';
import { V1ParamRef } from '../models/V1ParamRef.js';
import { V1ParentReference } from '../models/V1ParentReference.js';
import { V1PersistentVolume } from '../models/V1PersistentVolume.js';
import { V1PersistentVolumeClaim } from '../models/V1PersistentVolumeClaim.js';
import { V1PersistentVolumeClaimCondition } from '../models/V1PersistentVolumeClaimCondition.js';
import { V1PersistentVolumeClaimList } from '../models/V1PersistentVolumeClaimList.js';
import { V1PersistentVolumeClaimSpec } from '../models/V1PersistentVolumeClaimSpec.js';
import { V1PersistentVolumeClaimStatus } from '../models/V1PersistentVolumeClaimStatus.js';
import { V1PersistentVolumeClaimTemplate } from '../models/V1PersistentVolumeClaimTemplate.js';
import { V1PersistentVolumeClaimVolumeSource } from '../models/V1PersistentVolumeClaimVolumeSource.js';
import { V1PersistentVolumeList } from '../models/V1PersistentVolumeList.js';
import { V1PersistentVolumeSpec } from '../models/V1PersistentVolumeSpec.js';
import { V1PersistentVolumeStatus } from '../models/V1PersistentVolumeStatus.js';
import { V1PhotonPersistentDiskVolumeSource } from '../models/V1PhotonPersistentDiskVolumeSource.js';
import { V1Pod } from '../models/V1Pod.js';
import { V1PodAffinity } from '../models/V1PodAffinity.js';
import { V1PodAffinityTerm } from '../models/V1PodAffinityTerm.js';
import { V1PodAntiAffinity } from '../models/V1PodAntiAffinity.js';
import { V1PodCondition } from '../models/V1PodCondition.js';
import { V1PodDNSConfig } from '../models/V1PodDNSConfig.js';
import { V1PodDNSConfigOption } from '../models/V1PodDNSConfigOption.js';
import { V1PodDisruptionBudget } from '../models/V1PodDisruptionBudget.js';
import { V1PodDisruptionBudgetList } from '../models/V1PodDisruptionBudgetList.js';
import { V1PodDisruptionBudgetSpec } from '../models/V1PodDisruptionBudgetSpec.js';
import { V1PodDisruptionBudgetStatus } from '../models/V1PodDisruptionBudgetStatus.js';
import { V1PodFailurePolicy } from '../models/V1PodFailurePolicy.js';
import { V1PodFailurePolicyOnExitCodesRequirement } from '../models/V1PodFailurePolicyOnExitCodesRequirement.js';
import { V1PodFailurePolicyOnPodConditionsPattern } from '../models/V1PodFailurePolicyOnPodConditionsPattern.js';
import { V1PodFailurePolicyRule } from '../models/V1PodFailurePolicyRule.js';
import { V1PodIP } from '../models/V1PodIP.js';
import { V1PodList } from '../models/V1PodList.js';
import { V1PodOS } from '../models/V1PodOS.js';
import { V1PodReadinessGate } from '../models/V1PodReadinessGate.js';
import { V1PodResourceClaim } from '../models/V1PodResourceClaim.js';
import { V1PodResourceClaimStatus } from '../models/V1PodResourceClaimStatus.js';
import { V1PodSchedulingGate } from '../models/V1PodSchedulingGate.js';
import { V1PodSecurityContext } from '../models/V1PodSecurityContext.js';
import { V1PodSpec } from '../models/V1PodSpec.js';
import { V1PodStatus } from '../models/V1PodStatus.js';
import { V1PodTemplate } from '../models/V1PodTemplate.js';
import { V1PodTemplateList } from '../models/V1PodTemplateList.js';
import { V1PodTemplateSpec } from '../models/V1PodTemplateSpec.js';
import { V1PolicyRule } from '../models/V1PolicyRule.js';
import { V1PolicyRulesWithSubjects } from '../models/V1PolicyRulesWithSubjects.js';
import { V1PortStatus } from '../models/V1PortStatus.js';
import { V1PortworxVolumeSource } from '../models/V1PortworxVolumeSource.js';
import { V1Preconditions } from '../models/V1Preconditions.js';
import { V1PreferredSchedulingTerm } from '../models/V1PreferredSchedulingTerm.js';
import { V1PriorityClass } from '../models/V1PriorityClass.js';
import { V1PriorityClassList } from '../models/V1PriorityClassList.js';
import { V1PriorityLevelConfiguration } from '../models/V1PriorityLevelConfiguration.js';
import { V1PriorityLevelConfigurationCondition } from '../models/V1PriorityLevelConfigurationCondition.js';
import { V1PriorityLevelConfigurationList } from '../models/V1PriorityLevelConfigurationList.js';
import { V1PriorityLevelConfigurationReference } from '../models/V1PriorityLevelConfigurationReference.js';
import { V1PriorityLevelConfigurationSpec } from '../models/V1PriorityLevelConfigurationSpec.js';
import { V1PriorityLevelConfigurationStatus } from '../models/V1PriorityLevelConfigurationStatus.js';
import { V1Probe } from '../models/V1Probe.js';
import { V1ProjectedVolumeSource } from '../models/V1ProjectedVolumeSource.js';
import { V1QueuingConfiguration } from '../models/V1QueuingConfiguration.js';
import { V1QuobyteVolumeSource } from '../models/V1QuobyteVolumeSource.js';
import { V1RBDPersistentVolumeSource } from '../models/V1RBDPersistentVolumeSource.js';
import { V1RBDVolumeSource } from '../models/V1RBDVolumeSource.js';
import { V1ReplicaSet } from '../models/V1ReplicaSet.js';
import { V1ReplicaSetCondition } from '../models/V1ReplicaSetCondition.js';
import { V1ReplicaSetList } from '../models/V1ReplicaSetList.js';
import { V1ReplicaSetSpec } from '../models/V1ReplicaSetSpec.js';
import { V1ReplicaSetStatus } from '../models/V1ReplicaSetStatus.js';
import { V1ReplicationController } from '../models/V1ReplicationController.js';
import { V1ReplicationControllerCondition } from '../models/V1ReplicationControllerCondition.js';
import { V1ReplicationControllerList } from '../models/V1ReplicationControllerList.js';
import { V1ReplicationControllerSpec } from '../models/V1ReplicationControllerSpec.js';
import { V1ReplicationControllerStatus } from '../models/V1ReplicationControllerStatus.js';
import { V1ResourceAttributes } from '../models/V1ResourceAttributes.js';
import { V1ResourceClaim } from '../models/V1ResourceClaim.js';
import { V1ResourceFieldSelector } from '../models/V1ResourceFieldSelector.js';
import { V1ResourceHealth } from '../models/V1ResourceHealth.js';
import { V1ResourcePolicyRule } from '../models/V1ResourcePolicyRule.js';
import { V1ResourceQuota } from '../models/V1ResourceQuota.js';
import { V1ResourceQuotaList } from '../models/V1ResourceQuotaList.js';
import { V1ResourceQuotaSpec } from '../models/V1ResourceQuotaSpec.js';
import { V1ResourceQuotaStatus } from '../models/V1ResourceQuotaStatus.js';
import { V1ResourceRequirements } from '../models/V1ResourceRequirements.js';
import { V1ResourceRule } from '../models/V1ResourceRule.js';
import { V1ResourceStatus } from '../models/V1ResourceStatus.js';
import { V1Role } from '../models/V1Role.js';
import { V1RoleBinding } from '../models/V1RoleBinding.js';
import { V1RoleBindingList } from '../models/V1RoleBindingList.js';
import { V1RoleList } from '../models/V1RoleList.js';
import { V1RoleRef } from '../models/V1RoleRef.js';
import { V1RollingUpdateDaemonSet } from '../models/V1RollingUpdateDaemonSet.js';
import { V1RollingUpdateDeployment } from '../models/V1RollingUpdateDeployment.js';
import { V1RollingUpdateStatefulSetStrategy } from '../models/V1RollingUpdateStatefulSetStrategy.js';
import { V1RuleWithOperations } from '../models/V1RuleWithOperations.js';
import { V1RuntimeClass } from '../models/V1RuntimeClass.js';
import { V1RuntimeClassList } from '../models/V1RuntimeClassList.js';
import { V1SELinuxOptions } from '../models/V1SELinuxOptions.js';
import { V1Scale } from '../models/V1Scale.js';
import { V1ScaleIOPersistentVolumeSource } from '../models/V1ScaleIOPersistentVolumeSource.js';
import { V1ScaleIOVolumeSource } from '../models/V1ScaleIOVolumeSource.js';
import { V1ScaleSpec } from '../models/V1ScaleSpec.js';
import { V1ScaleStatus } from '../models/V1ScaleStatus.js';
import { V1Scheduling } from '../models/V1Scheduling.js';
import { V1ScopeSelector } from '../models/V1ScopeSelector.js';
import { V1ScopedResourceSelectorRequirement } from '../models/V1ScopedResourceSelectorRequirement.js';
import { V1SeccompProfile } from '../models/V1SeccompProfile.js';
import { V1Secret } from '../models/V1Secret.js';
import { V1SecretEnvSource } from '../models/V1SecretEnvSource.js';
import { V1SecretKeySelector } from '../models/V1SecretKeySelector.js';
import { V1SecretList } from '../models/V1SecretList.js';
import { V1SecretProjection } from '../models/V1SecretProjection.js';
import { V1SecretReference } from '../models/V1SecretReference.js';
import { V1SecretVolumeSource } from '../models/V1SecretVolumeSource.js';
import { V1SecurityContext } from '../models/V1SecurityContext.js';
import { V1SelectableField } from '../models/V1SelectableField.js';
import { V1SelfSubjectAccessReview } from '../models/V1SelfSubjectAccessReview.js';
import { V1SelfSubjectAccessReviewSpec } from '../models/V1SelfSubjectAccessReviewSpec.js';
import { V1SelfSubjectReview } from '../models/V1SelfSubjectReview.js';
import { V1SelfSubjectReviewStatus } from '../models/V1SelfSubjectReviewStatus.js';
import { V1SelfSubjectRulesReview } from '../models/V1SelfSubjectRulesReview.js';
import { V1SelfSubjectRulesReviewSpec } from '../models/V1SelfSubjectRulesReviewSpec.js';
import { V1ServerAddressByClientCIDR } from '../models/V1ServerAddressByClientCIDR.js';
import { V1Service } from '../models/V1Service.js';
import { V1ServiceAccount } from '../models/V1ServiceAccount.js';
import { V1ServiceAccountList } from '../models/V1ServiceAccountList.js';
import { V1ServiceAccountSubject } from '../models/V1ServiceAccountSubject.js';
import { V1ServiceAccountTokenProjection } from '../models/V1ServiceAccountTokenProjection.js';
import { V1ServiceBackendPort } from '../models/V1ServiceBackendPort.js';
import { V1ServiceCIDR } from '../models/V1ServiceCIDR.js';
import { V1ServiceCIDRList } from '../models/V1ServiceCIDRList.js';
import { V1ServiceCIDRSpec } from '../models/V1ServiceCIDRSpec.js';
import { V1ServiceCIDRStatus } from '../models/V1ServiceCIDRStatus.js';
import { V1ServiceList } from '../models/V1ServiceList.js';
import { V1ServicePort } from '../models/V1ServicePort.js';
import { V1ServiceSpec } from '../models/V1ServiceSpec.js';
import { V1ServiceStatus } from '../models/V1ServiceStatus.js';
import { V1SessionAffinityConfig } from '../models/V1SessionAffinityConfig.js';
import { V1SleepAction } from '../models/V1SleepAction.js';
import { V1StatefulSet } from '../models/V1StatefulSet.js';
import { V1StatefulSetCondition } from '../models/V1StatefulSetCondition.js';
import { V1StatefulSetList } from '../models/V1StatefulSetList.js';
import { V1StatefulSetOrdinals } from '../models/V1StatefulSetOrdinals.js';
import { V1StatefulSetPersistentVolumeClaimRetentionPolicy } from '../models/V1StatefulSetPersistentVolumeClaimRetentionPolicy.js';
import { V1StatefulSetSpec } from '../models/V1StatefulSetSpec.js';
import { V1StatefulSetStatus } from '../models/V1StatefulSetStatus.js';
import { V1StatefulSetUpdateStrategy } from '../models/V1StatefulSetUpdateStrategy.js';
import { V1Status } from '../models/V1Status.js';
import { V1StatusCause } from '../models/V1StatusCause.js';
import { V1StatusDetails } from '../models/V1StatusDetails.js';
import { V1StorageClass } from '../models/V1StorageClass.js';
import { V1StorageClassList } from '../models/V1StorageClassList.js';
import { V1StorageOSPersistentVolumeSource } from '../models/V1StorageOSPersistentVolumeSource.js';
import { V1StorageOSVolumeSource } from '../models/V1StorageOSVolumeSource.js';
import { V1SubjectAccessReview } from '../models/V1SubjectAccessReview.js';
import { V1SubjectAccessReviewSpec } from '../models/V1SubjectAccessReviewSpec.js';
import { V1SubjectAccessReviewStatus } from '../models/V1SubjectAccessReviewStatus.js';
import { V1SubjectRulesReviewStatus } from '../models/V1SubjectRulesReviewStatus.js';
import { V1SuccessPolicy } from '../models/V1SuccessPolicy.js';
import { V1SuccessPolicyRule } from '../models/V1SuccessPolicyRule.js';
import { V1Sysctl } from '../models/V1Sysctl.js';
import { V1TCPSocketAction } from '../models/V1TCPSocketAction.js';
import { V1Taint } from '../models/V1Taint.js';
import { V1TokenRequestSpec } from '../models/V1TokenRequestSpec.js';
import { V1TokenRequestStatus } from '../models/V1TokenRequestStatus.js';
import { V1TokenReview } from '../models/V1TokenReview.js';
import { V1TokenReviewSpec } from '../models/V1TokenReviewSpec.js';
import { V1TokenReviewStatus } from '../models/V1TokenReviewStatus.js';
import { V1Toleration } from '../models/V1Toleration.js';
import { V1TopologySelectorLabelRequirement } from '../models/V1TopologySelectorLabelRequirement.js';
import { V1TopologySelectorTerm } from '../models/V1TopologySelectorTerm.js';
import { V1TopologySpreadConstraint } from '../models/V1TopologySpreadConstraint.js';
import { V1TypeChecking } from '../models/V1TypeChecking.js';
import { V1TypedLocalObjectReference } from '../models/V1TypedLocalObjectReference.js';
import { V1TypedObjectReference } from '../models/V1TypedObjectReference.js';
import { V1UncountedTerminatedPods } from '../models/V1UncountedTerminatedPods.js';
import { V1UserInfo } from '../models/V1UserInfo.js';
import { V1UserSubject } from '../models/V1UserSubject.js';
import { V1ValidatingAdmissionPolicy } from '../models/V1ValidatingAdmissionPolicy.js';
import { V1ValidatingAdmissionPolicyBinding } from '../models/V1ValidatingAdmissionPolicyBinding.js';
import { V1ValidatingAdmissionPolicyBindingList } from '../models/V1ValidatingAdmissionPolicyBindingList.js';
import { V1ValidatingAdmissionPolicyBindingSpec } from '../models/V1ValidatingAdmissionPolicyBindingSpec.js';
import { V1ValidatingAdmissionPolicyList } from '../models/V1ValidatingAdmissionPolicyList.js';
import { V1ValidatingAdmissionPolicySpec } from '../models/V1ValidatingAdmissionPolicySpec.js';
import { V1ValidatingAdmissionPolicyStatus } from '../models/V1ValidatingAdmissionPolicyStatus.js';
import { V1ValidatingWebhook } from '../models/V1ValidatingWebhook.js';
import { V1ValidatingWebhookConfiguration } from '../models/V1ValidatingWebhookConfiguration.js';
import { V1ValidatingWebhookConfigurationList } from '../models/V1ValidatingWebhookConfigurationList.js';
import { V1Validation } from '../models/V1Validation.js';
import { V1ValidationRule } from '../models/V1ValidationRule.js';
import { V1Variable } from '../models/V1Variable.js';
import { V1Volume } from '../models/V1Volume.js';
import { V1VolumeAttachment } from '../models/V1VolumeAttachment.js';
import { V1VolumeAttachmentList } from '../models/V1VolumeAttachmentList.js';
import { V1VolumeAttachmentSource } from '../models/V1VolumeAttachmentSource.js';
import { V1VolumeAttachmentSpec } from '../models/V1VolumeAttachmentSpec.js';
import { V1VolumeAttachmentStatus } from '../models/V1VolumeAttachmentStatus.js';
import { V1VolumeDevice } from '../models/V1VolumeDevice.js';
import { V1VolumeError } from '../models/V1VolumeError.js';
import { V1VolumeMount } from '../models/V1VolumeMount.js';
import { V1VolumeMountStatus } from '../models/V1VolumeMountStatus.js';
import { V1VolumeNodeAffinity } from '../models/V1VolumeNodeAffinity.js';
import { V1VolumeNodeResources } from '../models/V1VolumeNodeResources.js';
import { V1VolumeProjection } from '../models/V1VolumeProjection.js';
import { V1VolumeResourceRequirements } from '../models/V1VolumeResourceRequirements.js';
import { V1VsphereVirtualDiskVolumeSource } from '../models/V1VsphereVirtualDiskVolumeSource.js';
import { V1WatchEvent } from '../models/V1WatchEvent.js';
import { V1WebhookConversion } from '../models/V1WebhookConversion.js';
import { V1WeightedPodAffinityTerm } from '../models/V1WeightedPodAffinityTerm.js';
import { V1WindowsSecurityContextOptions } from '../models/V1WindowsSecurityContextOptions.js';
import { V1alpha1ApplyConfiguration } from '../models/V1alpha1ApplyConfiguration.js';
import { V1alpha1ClusterTrustBundle } from '../models/V1alpha1ClusterTrustBundle.js';
import { V1alpha1ClusterTrustBundleList } from '../models/V1alpha1ClusterTrustBundleList.js';
import { V1alpha1ClusterTrustBundleSpec } from '../models/V1alpha1ClusterTrustBundleSpec.js';
import { V1alpha1GroupVersionResource } from '../models/V1alpha1GroupVersionResource.js';
import { V1alpha1JSONPatch } from '../models/V1alpha1JSONPatch.js';
import { V1alpha1MatchCondition } from '../models/V1alpha1MatchCondition.js';
import { V1alpha1MatchResources } from '../models/V1alpha1MatchResources.js';
import { V1alpha1MigrationCondition } from '../models/V1alpha1MigrationCondition.js';
import { V1alpha1MutatingAdmissionPolicy } from '../models/V1alpha1MutatingAdmissionPolicy.js';
import { V1alpha1MutatingAdmissionPolicyBinding } from '../models/V1alpha1MutatingAdmissionPolicyBinding.js';
import { V1alpha1MutatingAdmissionPolicyBindingList } from '../models/V1alpha1MutatingAdmissionPolicyBindingList.js';
import { V1alpha1MutatingAdmissionPolicyBindingSpec } from '../models/V1alpha1MutatingAdmissionPolicyBindingSpec.js';
import { V1alpha1MutatingAdmissionPolicyList } from '../models/V1alpha1MutatingAdmissionPolicyList.js';
import { V1alpha1MutatingAdmissionPolicySpec } from '../models/V1alpha1MutatingAdmissionPolicySpec.js';
import { V1alpha1Mutation } from '../models/V1alpha1Mutation.js';
import { V1alpha1NamedRuleWithOperations } from '../models/V1alpha1NamedRuleWithOperations.js';
import { V1alpha1ParamKind } from '../models/V1alpha1ParamKind.js';
import { V1alpha1ParamRef } from '../models/V1alpha1ParamRef.js';
import { V1alpha1ServerStorageVersion } from '../models/V1alpha1ServerStorageVersion.js';
import { V1alpha1StorageVersion } from '../models/V1alpha1StorageVersion.js';
import { V1alpha1StorageVersionCondition } from '../models/V1alpha1StorageVersionCondition.js';
import { V1alpha1StorageVersionList } from '../models/V1alpha1StorageVersionList.js';
import { V1alpha1StorageVersionMigration } from '../models/V1alpha1StorageVersionMigration.js';
import { V1alpha1StorageVersionMigrationList } from '../models/V1alpha1StorageVersionMigrationList.js';
import { V1alpha1StorageVersionMigrationSpec } from '../models/V1alpha1StorageVersionMigrationSpec.js';
import { V1alpha1StorageVersionMigrationStatus } from '../models/V1alpha1StorageVersionMigrationStatus.js';
import { V1alpha1StorageVersionStatus } from '../models/V1alpha1StorageVersionStatus.js';
import { V1alpha1Variable } from '../models/V1alpha1Variable.js';
import { V1alpha1VolumeAttributesClass } from '../models/V1alpha1VolumeAttributesClass.js';
import { V1alpha1VolumeAttributesClassList } from '../models/V1alpha1VolumeAttributesClassList.js';
import { V1alpha2LeaseCandidate } from '../models/V1alpha2LeaseCandidate.js';
import { V1alpha2LeaseCandidateList } from '../models/V1alpha2LeaseCandidateList.js';
import { V1alpha2LeaseCandidateSpec } from '../models/V1alpha2LeaseCandidateSpec.js';
import { V1alpha3AllocatedDeviceStatus } from '../models/V1alpha3AllocatedDeviceStatus.js';
import { V1alpha3AllocationResult } from '../models/V1alpha3AllocationResult.js';
import { V1alpha3BasicDevice } from '../models/V1alpha3BasicDevice.js';
import { V1alpha3CELDeviceSelector } from '../models/V1alpha3CELDeviceSelector.js';
import { V1alpha3Counter } from '../models/V1alpha3Counter.js';
import { V1alpha3CounterSet } from '../models/V1alpha3CounterSet.js';
import { V1alpha3Device } from '../models/V1alpha3Device.js';
import { V1alpha3DeviceAllocationConfiguration } from '../models/V1alpha3DeviceAllocationConfiguration.js';
import { V1alpha3DeviceAllocationResult } from '../models/V1alpha3DeviceAllocationResult.js';
import { V1alpha3DeviceAttribute } from '../models/V1alpha3DeviceAttribute.js';
import { V1alpha3DeviceClaim } from '../models/V1alpha3DeviceClaim.js';
import { V1alpha3DeviceClaimConfiguration } from '../models/V1alpha3DeviceClaimConfiguration.js';
import { V1alpha3DeviceClass } from '../models/V1alpha3DeviceClass.js';
import { V1alpha3DeviceClassConfiguration } from '../models/V1alpha3DeviceClassConfiguration.js';
import { V1alpha3DeviceClassList } from '../models/V1alpha3DeviceClassList.js';
import { V1alpha3DeviceClassSpec } from '../models/V1alpha3DeviceClassSpec.js';
import { V1alpha3DeviceConstraint } from '../models/V1alpha3DeviceConstraint.js';
import { V1alpha3DeviceCounterConsumption } from '../models/V1alpha3DeviceCounterConsumption.js';
import { V1alpha3DeviceRequest } from '../models/V1alpha3DeviceRequest.js';
import { V1alpha3DeviceRequestAllocationResult } from '../models/V1alpha3DeviceRequestAllocationResult.js';
import { V1alpha3DeviceSelector } from '../models/V1alpha3DeviceSelector.js';
import { V1alpha3DeviceSubRequest } from '../models/V1alpha3DeviceSubRequest.js';
import { V1alpha3DeviceTaint } from '../models/V1alpha3DeviceTaint.js';
import { V1alpha3DeviceTaintRule } from '../models/V1alpha3DeviceTaintRule.js';
import { V1alpha3DeviceTaintRuleList } from '../models/V1alpha3DeviceTaintRuleList.js';
import { V1alpha3DeviceTaintRuleSpec } from '../models/V1alpha3DeviceTaintRuleSpec.js';
import { V1alpha3DeviceTaintSelector } from '../models/V1alpha3DeviceTaintSelector.js';
import { V1alpha3DeviceToleration } from '../models/V1alpha3DeviceToleration.js';
import { V1alpha3NetworkDeviceData } from '../models/V1alpha3NetworkDeviceData.js';
import { V1alpha3OpaqueDeviceConfiguration } from '../models/V1alpha3OpaqueDeviceConfiguration.js';
import { V1alpha3ResourceClaim } from '../models/V1alpha3ResourceClaim.js';
import { V1alpha3ResourceClaimConsumerReference } from '../models/V1alpha3ResourceClaimConsumerReference.js';
import { V1alpha3ResourceClaimList } from '../models/V1alpha3ResourceClaimList.js';
import { V1alpha3ResourceClaimSpec } from '../models/V1alpha3ResourceClaimSpec.js';
import { V1alpha3ResourceClaimStatus } from '../models/V1alpha3ResourceClaimStatus.js';
import { V1alpha3ResourceClaimTemplate } from '../models/V1alpha3ResourceClaimTemplate.js';
import { V1alpha3ResourceClaimTemplateList } from '../models/V1alpha3ResourceClaimTemplateList.js';
import { V1alpha3ResourceClaimTemplateSpec } from '../models/V1alpha3ResourceClaimTemplateSpec.js';
import { V1alpha3ResourcePool } from '../models/V1alpha3ResourcePool.js';
import { V1alpha3ResourceSlice } from '../models/V1alpha3ResourceSlice.js';
import { V1alpha3ResourceSliceList } from '../models/V1alpha3ResourceSliceList.js';
import { V1alpha3ResourceSliceSpec } from '../models/V1alpha3ResourceSliceSpec.js';
import { V1beta1AllocatedDeviceStatus } from '../models/V1beta1AllocatedDeviceStatus.js';
import { V1beta1AllocationResult } from '../models/V1beta1AllocationResult.js';
import { V1beta1AuditAnnotation } from '../models/V1beta1AuditAnnotation.js';
import { V1beta1BasicDevice } from '../models/V1beta1BasicDevice.js';
import { V1beta1CELDeviceSelector } from '../models/V1beta1CELDeviceSelector.js';
import { V1beta1ClusterTrustBundle } from '../models/V1beta1ClusterTrustBundle.js';
import { V1beta1ClusterTrustBundleList } from '../models/V1beta1ClusterTrustBundleList.js';
import { V1beta1ClusterTrustBundleSpec } from '../models/V1beta1ClusterTrustBundleSpec.js';
import { V1beta1Counter } from '../models/V1beta1Counter.js';
import { V1beta1CounterSet } from '../models/V1beta1CounterSet.js';
import { V1beta1Device } from '../models/V1beta1Device.js';
import { V1beta1DeviceAllocationConfiguration } from '../models/V1beta1DeviceAllocationConfiguration.js';
import { V1beta1DeviceAllocationResult } from '../models/V1beta1DeviceAllocationResult.js';
import { V1beta1DeviceAttribute } from '../models/V1beta1DeviceAttribute.js';
import { V1beta1DeviceCapacity } from '../models/V1beta1DeviceCapacity.js';
import { V1beta1DeviceClaim } from '../models/V1beta1DeviceClaim.js';
import { V1beta1DeviceClaimConfiguration } from '../models/V1beta1DeviceClaimConfiguration.js';
import { V1beta1DeviceClass } from '../models/V1beta1DeviceClass.js';
import { V1beta1DeviceClassConfiguration } from '../models/V1beta1DeviceClassConfiguration.js';
import { V1beta1DeviceClassList } from '../models/V1beta1DeviceClassList.js';
import { V1beta1DeviceClassSpec } from '../models/V1beta1DeviceClassSpec.js';
import { V1beta1DeviceConstraint } from '../models/V1beta1DeviceConstraint.js';
import { V1beta1DeviceCounterConsumption } from '../models/V1beta1DeviceCounterConsumption.js';
import { V1beta1DeviceRequest } from '../models/V1beta1DeviceRequest.js';
import { V1beta1DeviceRequestAllocationResult } from '../models/V1beta1DeviceRequestAllocationResult.js';
import { V1beta1DeviceSelector } from '../models/V1beta1DeviceSelector.js';
import { V1beta1DeviceSubRequest } from '../models/V1beta1DeviceSubRequest.js';
import { V1beta1DeviceTaint } from '../models/V1beta1DeviceTaint.js';
import { V1beta1DeviceToleration } from '../models/V1beta1DeviceToleration.js';
import { V1beta1ExpressionWarning } from '../models/V1beta1ExpressionWarning.js';
import { V1beta1IPAddress } from '../models/V1beta1IPAddress.js';
import { V1beta1IPAddressList } from '../models/V1beta1IPAddressList.js';
import { V1beta1IPAddressSpec } from '../models/V1beta1IPAddressSpec.js';
import { V1beta1LeaseCandidate } from '../models/V1beta1LeaseCandidate.js';
import { V1beta1LeaseCandidateList } from '../models/V1beta1LeaseCandidateList.js';
import { V1beta1LeaseCandidateSpec } from '../models/V1beta1LeaseCandidateSpec.js';
import { V1beta1MatchCondition } from '../models/V1beta1MatchCondition.js';
import { V1beta1MatchResources } from '../models/V1beta1MatchResources.js';
import { V1beta1NamedRuleWithOperations } from '../models/V1beta1NamedRuleWithOperations.js';
import { V1beta1NetworkDeviceData } from '../models/V1beta1NetworkDeviceData.js';
import { V1beta1OpaqueDeviceConfiguration } from '../models/V1beta1OpaqueDeviceConfiguration.js';
import { V1beta1ParamKind } from '../models/V1beta1ParamKind.js';
import { V1beta1ParamRef } from '../models/V1beta1ParamRef.js';
import { V1beta1ParentReference } from '../models/V1beta1ParentReference.js';
import { V1beta1ResourceClaim } from '../models/V1beta1ResourceClaim.js';
import { V1beta1ResourceClaimConsumerReference } from '../models/V1beta1ResourceClaimConsumerReference.js';
import { V1beta1ResourceClaimList } from '../models/V1beta1ResourceClaimList.js';
import { V1beta1ResourceClaimSpec } from '../models/V1beta1ResourceClaimSpec.js';
import { V1beta1ResourceClaimStatus } from '../models/V1beta1ResourceClaimStatus.js';
import { V1beta1ResourceClaimTemplate } from '../models/V1beta1ResourceClaimTemplate.js';
import { V1beta1ResourceClaimTemplateList } from '../models/V1beta1ResourceClaimTemplateList.js';
import { V1beta1ResourceClaimTemplateSpec } from '../models/V1beta1ResourceClaimTemplateSpec.js';
import { V1beta1ResourcePool } from '../models/V1beta1ResourcePool.js';
import { V1beta1ResourceSlice } from '../models/V1beta1ResourceSlice.js';
import { V1beta1ResourceSliceList } from '../models/V1beta1ResourceSliceList.js';
import { V1beta1ResourceSliceSpec } from '../models/V1beta1ResourceSliceSpec.js';
import { V1beta1ServiceCIDR } from '../models/V1beta1ServiceCIDR.js';
import { V1beta1ServiceCIDRList } from '../models/V1beta1ServiceCIDRList.js';
import { V1beta1ServiceCIDRSpec } from '../models/V1beta1ServiceCIDRSpec.js';
import { V1beta1ServiceCIDRStatus } from '../models/V1beta1ServiceCIDRStatus.js';
import { V1beta1TypeChecking } from '../models/V1beta1TypeChecking.js';
import { V1beta1ValidatingAdmissionPolicy } from '../models/V1beta1ValidatingAdmissionPolicy.js';
import { V1beta1ValidatingAdmissionPolicyBinding } from '../models/V1beta1ValidatingAdmissionPolicyBinding.js';
import { V1beta1ValidatingAdmissionPolicyBindingList } from '../models/V1beta1ValidatingAdmissionPolicyBindingList.js';
import { V1beta1ValidatingAdmissionPolicyBindingSpec } from '../models/V1beta1ValidatingAdmissionPolicyBindingSpec.js';
import { V1beta1ValidatingAdmissionPolicyList } from '../models/V1beta1ValidatingAdmissionPolicyList.js';
import { V1beta1ValidatingAdmissionPolicySpec } from '../models/V1beta1ValidatingAdmissionPolicySpec.js';
import { V1beta1ValidatingAdmissionPolicyStatus } from '../models/V1beta1ValidatingAdmissionPolicyStatus.js';
import { V1beta1Validation } from '../models/V1beta1Validation.js';
import { V1beta1Variable } from '../models/V1beta1Variable.js';
import { V1beta1VolumeAttributesClass } from '../models/V1beta1VolumeAttributesClass.js';
import { V1beta1VolumeAttributesClassList } from '../models/V1beta1VolumeAttributesClassList.js';
import { V1beta2AllocatedDeviceStatus } from '../models/V1beta2AllocatedDeviceStatus.js';
import { V1beta2AllocationResult } from '../models/V1beta2AllocationResult.js';
import { V1beta2CELDeviceSelector } from '../models/V1beta2CELDeviceSelector.js';
import { V1beta2Counter } from '../models/V1beta2Counter.js';
import { V1beta2CounterSet } from '../models/V1beta2CounterSet.js';
import { V1beta2Device } from '../models/V1beta2Device.js';
import { V1beta2DeviceAllocationConfiguration } from '../models/V1beta2DeviceAllocationConfiguration.js';
import { V1beta2DeviceAllocationResult } from '../models/V1beta2DeviceAllocationResult.js';
import { V1beta2DeviceAttribute } from '../models/V1beta2DeviceAttribute.js';
import { V1beta2DeviceCapacity } from '../models/V1beta2DeviceCapacity.js';
import { V1beta2DeviceClaim } from '../models/V1beta2DeviceClaim.js';
import { V1beta2DeviceClaimConfiguration } from '../models/V1beta2DeviceClaimConfiguration.js';
import { V1beta2DeviceClass } from '../models/V1beta2DeviceClass.js';
import { V1beta2DeviceClassConfiguration } from '../models/V1beta2DeviceClassConfiguration.js';
import { V1beta2DeviceClassList } from '../models/V1beta2DeviceClassList.js';
import { V1beta2DeviceClassSpec } from '../models/V1beta2DeviceClassSpec.js';
import { V1beta2DeviceConstraint } from '../models/V1beta2DeviceConstraint.js';
import { V1beta2DeviceCounterConsumption } from '../models/V1beta2DeviceCounterConsumption.js';
import { V1beta2DeviceRequest } from '../models/V1beta2DeviceRequest.js';
import { V1beta2DeviceRequestAllocationResult } from '../models/V1beta2DeviceRequestAllocationResult.js';
import { V1beta2DeviceSelector } from '../models/V1beta2DeviceSelector.js';
import { V1beta2DeviceSubRequest } from '../models/V1beta2DeviceSubRequest.js';
import { V1beta2DeviceTaint } from '../models/V1beta2DeviceTaint.js';
import { V1beta2DeviceToleration } from '../models/V1beta2DeviceToleration.js';
import { V1beta2ExactDeviceRequest } from '../models/V1beta2ExactDeviceRequest.js';
import { V1beta2NetworkDeviceData } from '../models/V1beta2NetworkDeviceData.js';
import { V1beta2OpaqueDeviceConfiguration } from '../models/V1beta2OpaqueDeviceConfiguration.js';
import { V1beta2ResourceClaim } from '../models/V1beta2ResourceClaim.js';
import { V1beta2ResourceClaimConsumerReference } from '../models/V1beta2ResourceClaimConsumerReference.js';
import { V1beta2ResourceClaimList } from '../models/V1beta2ResourceClaimList.js';
import { V1beta2ResourceClaimSpec } from '../models/V1beta2ResourceClaimSpec.js';
import { V1beta2ResourceClaimStatus } from '../models/V1beta2ResourceClaimStatus.js';
import { V1beta2ResourceClaimTemplate } from '../models/V1beta2ResourceClaimTemplate.js';
import { V1beta2ResourceClaimTemplateList } from '../models/V1beta2ResourceClaimTemplateList.js';
import { V1beta2ResourceClaimTemplateSpec } from '../models/V1beta2ResourceClaimTemplateSpec.js';
import { V1beta2ResourcePool } from '../models/V1beta2ResourcePool.js';
import { V1beta2ResourceSlice } from '../models/V1beta2ResourceSlice.js';
import { V1beta2ResourceSliceList } from '../models/V1beta2ResourceSliceList.js';
import { V1beta2ResourceSliceSpec } from '../models/V1beta2ResourceSliceSpec.js';
import { V2ContainerResourceMetricSource } from '../models/V2ContainerResourceMetricSource.js';
import { V2ContainerResourceMetricStatus } from '../models/V2ContainerResourceMetricStatus.js';
import { V2CrossVersionObjectReference } from '../models/V2CrossVersionObjectReference.js';
import { V2ExternalMetricSource } from '../models/V2ExternalMetricSource.js';
import { V2ExternalMetricStatus } from '../models/V2ExternalMetricStatus.js';
import { V2HPAScalingPolicy } from '../models/V2HPAScalingPolicy.js';
import { V2HPAScalingRules } from '../models/V2HPAScalingRules.js';
import { V2HorizontalPodAutoscaler } from '../models/V2HorizontalPodAutoscaler.js';
import { V2HorizontalPodAutoscalerBehavior } from '../models/V2HorizontalPodAutoscalerBehavior.js';
import { V2HorizontalPodAutoscalerCondition } from '../models/V2HorizontalPodAutoscalerCondition.js';
import { V2HorizontalPodAutoscalerList } from '../models/V2HorizontalPodAutoscalerList.js';
import { V2HorizontalPodAutoscalerSpec } from '../models/V2HorizontalPodAutoscalerSpec.js';
import { V2HorizontalPodAutoscalerStatus } from '../models/V2HorizontalPodAutoscalerStatus.js';
import { V2MetricIdentifier } from '../models/V2MetricIdentifier.js';
import { V2MetricSpec } from '../models/V2MetricSpec.js';
import { V2MetricStatus } from '../models/V2MetricStatus.js';
import { V2MetricTarget } from '../models/V2MetricTarget.js';
import { V2MetricValueStatus } from '../models/V2MetricValueStatus.js';
import { V2ObjectMetricSource } from '../models/V2ObjectMetricSource.js';
import { V2ObjectMetricStatus } from '../models/V2ObjectMetricStatus.js';
import { V2PodsMetricSource } from '../models/V2PodsMetricSource.js';
import { V2PodsMetricStatus } from '../models/V2PodsMetricStatus.js';
import { V2ResourceMetricSource } from '../models/V2ResourceMetricSource.js';
import { V2ResourceMetricStatus } from '../models/V2ResourceMetricStatus.js';
import { VersionInfo } from '../models/VersionInfo.js';

import { ObservableAdmissionregistrationApi } from "./ObservableAPI.js";
import { AdmissionregistrationApiRequestFactory, AdmissionregistrationApiResponseProcessor} from "../apis/AdmissionregistrationApi.js";

export interface AdmissionregistrationApiGetAPIGroupRequest {
}

export class ObjectAdmissionregistrationApi {
    private api: ObservableAdmissionregistrationApi

    public constructor(configuration: Configuration, requestFactory?: AdmissionregistrationApiRequestFactory, responseProcessor?: AdmissionregistrationApiResponseProcessor) {
        this.api = new ObservableAdmissionregistrationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AdmissionregistrationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AdmissionregistrationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAdmissionregistrationV1Api } from "./ObservableAPI.js";
import { AdmissionregistrationV1ApiRequestFactory, AdmissionregistrationV1ApiResponseProcessor} from "../apis/AdmissionregistrationV1Api.js";

export interface AdmissionregistrationV1ApiCreateMutatingWebhookConfigurationRequest {
    /**
     * 
     * @type V1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    body: V1MutatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateMutatingWebhookConfiguration
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiCreateValidatingAdmissionPolicyRequest {
    /**
     * 
     * @type V1ValidatingAdmissionPolicy
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicy
     */
    body: V1ValidatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicy
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiCreateValidatingAdmissionPolicyBindingRequest {
    /**
     * 
     * @type V1ValidatingAdmissionPolicyBinding
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicyBinding
     */
    body: V1ValidatingAdmissionPolicyBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingAdmissionPolicyBinding
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiCreateValidatingWebhookConfigurationRequest {
    /**
     * 
     * @type V1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    body: V1ValidatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApicreateValidatingWebhookConfiguration
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiDeleteCollectionMutatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteCollectionMutatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteCollectionValidatingAdmissionPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicy
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteCollectionValidatingAdmissionPolicyBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteCollectionValidatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteCollectionValidatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteMutatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicy
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteValidatingAdmissionPolicyBinding
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiDeleteValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1ApideleteValidatingWebhookConfiguration
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1ApiGetAPIResourcesRequest {
}

export interface AdmissionregistrationV1ApiListMutatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistMutatingWebhookConfiguration
     */
    watch?: boolean
}

export interface AdmissionregistrationV1ApiListValidatingAdmissionPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicy
     */
    watch?: boolean
}

export interface AdmissionregistrationV1ApiListValidatingAdmissionPolicyBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingAdmissionPolicyBinding
     */
    watch?: boolean
}

export interface AdmissionregistrationV1ApiListValidatingWebhookConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApilistValidatingWebhookConfiguration
     */
    watch?: boolean
}

export interface AdmissionregistrationV1ApiPatchMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchMutatingWebhookConfiguration
     */
    force?: boolean
}

export interface AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicy
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicy
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicy
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicy
     */
    force?: boolean
}

export interface AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyBinding
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyBinding
     */
    force?: boolean
}

export interface AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyStatusRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchValidatingAdmissionPolicyStatus
     */
    force?: boolean
}

export interface AdmissionregistrationV1ApiPatchValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1ApipatchValidatingWebhookConfiguration
     */
    force?: boolean
}

export interface AdmissionregistrationV1ApiReadMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadMutatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadMutatingWebhookConfiguration
     */
    pretty?: string
}

export interface AdmissionregistrationV1ApiReadValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingAdmissionPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingAdmissionPolicy
     */
    pretty?: string
}

export interface AdmissionregistrationV1ApiReadValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingAdmissionPolicyBinding
     */
    pretty?: string
}

export interface AdmissionregistrationV1ApiReadValidatingAdmissionPolicyStatusRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingAdmissionPolicyStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingAdmissionPolicyStatus
     */
    pretty?: string
}

export interface AdmissionregistrationV1ApiReadValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingWebhookConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireadValidatingWebhookConfiguration
     */
    pretty?: string
}

export interface AdmissionregistrationV1ApiReplaceMutatingWebhookConfigurationRequest {
    /**
     * name of the MutatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type V1MutatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    body: V1MutatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceMutatingWebhookConfiguration
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicy
     */
    name: string
    /**
     * 
     * @type V1ValidatingAdmissionPolicy
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicy
     */
    body: V1ValidatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicy
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * 
     * @type V1ValidatingAdmissionPolicyBinding
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyBinding
     */
    body: V1ValidatingAdmissionPolicyBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyBinding
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyStatusRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyStatus
     */
    name: string
    /**
     * 
     * @type V1ValidatingAdmissionPolicy
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyStatus
     */
    body: V1ValidatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingAdmissionPolicyStatus
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1ApiReplaceValidatingWebhookConfigurationRequest {
    /**
     * name of the ValidatingWebhookConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    name: string
    /**
     * 
     * @type V1ValidatingWebhookConfiguration
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    body: V1ValidatingWebhookConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1ApireplaceValidatingWebhookConfiguration
     */
    fieldValidation?: string
}

export class ObjectAdmissionregistrationV1Api {
    private api: ObservableAdmissionregistrationV1Api

    public constructor(configuration: Configuration, requestFactory?: AdmissionregistrationV1ApiRequestFactory, responseProcessor?: AdmissionregistrationV1ApiResponseProcessor) {
        this.api = new ObservableAdmissionregistrationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a MutatingWebhookConfiguration
     * @param param the request object
     */
    public createMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiCreateMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.createMutatingWebhookConfigurationWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a MutatingWebhookConfiguration
     * @param param the request object
     */
    public createMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiCreateMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1MutatingWebhookConfiguration> {
        return this.api.createMutatingWebhookConfiguration(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public createValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1ApiCreateValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicy>> {
        return this.api.createValidatingAdmissionPolicyWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public createValidatingAdmissionPolicy(param: AdmissionregistrationV1ApiCreateValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicy> {
        return this.api.createValidatingAdmissionPolicy(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public createValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1ApiCreateValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicyBinding>> {
        return this.api.createValidatingAdmissionPolicyBindingWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public createValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1ApiCreateValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicyBinding> {
        return this.api.createValidatingAdmissionPolicyBinding(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public createValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiCreateValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.createValidatingWebhookConfigurationWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public createValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiCreateValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.createValidatingWebhookConfiguration(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteCollectionMutatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionMutatingWebhookConfigurationWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteCollectionMutatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionMutatingWebhookConfiguration(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1ApiDeleteCollectionValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionValidatingAdmissionPolicyWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicy(param: AdmissionregistrationV1ApiDeleteCollectionValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionValidatingAdmissionPolicy(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1ApiDeleteCollectionValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionValidatingAdmissionPolicyBindingWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1ApiDeleteCollectionValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionValidatingAdmissionPolicyBinding(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteCollectionValidatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionValidatingWebhookConfigurationWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteCollectionValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteCollectionValidatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionValidatingWebhookConfiguration(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteMutatingWebhookConfigurationWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingWebhookConfiguration
     * @param param the request object
     */
    public deleteMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteMutatingWebhookConfiguration(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1ApiDeleteValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteValidatingAdmissionPolicyWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicy(param: AdmissionregistrationV1ApiDeleteValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteValidatingAdmissionPolicy(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1ApiDeleteValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1ApiDeleteValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteValidatingAdmissionPolicyBinding(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiDeleteValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteValidatingWebhookConfigurationWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingWebhookConfiguration
     * @param param the request object
     */
    public deleteValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiDeleteValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteValidatingWebhookConfiguration(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AdmissionregistrationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AdmissionregistrationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * @param param the request object
     */
    public listMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiListMutatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1MutatingWebhookConfigurationList>> {
        return this.api.listMutatingWebhookConfigurationWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingWebhookConfiguration
     * @param param the request object
     */
    public listMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiListMutatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<V1MutatingWebhookConfigurationList> {
        return this.api.listMutatingWebhookConfiguration(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicy
     * @param param the request object
     */
    public listValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1ApiListValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicyList>> {
        return this.api.listValidatingAdmissionPolicyWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicy
     * @param param the request object
     */
    public listValidatingAdmissionPolicy(param: AdmissionregistrationV1ApiListValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicyList> {
        return this.api.listValidatingAdmissionPolicy(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public listValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1ApiListValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicyBindingList>> {
        return this.api.listValidatingAdmissionPolicyBindingWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public listValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1ApiListValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicyBindingList> {
        return this.api.listValidatingAdmissionPolicyBinding(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * @param param the request object
     */
    public listValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiListValidatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingWebhookConfigurationList>> {
        return this.api.listValidatingWebhookConfigurationWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingWebhookConfiguration
     * @param param the request object
     */
    public listValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiListValidatingWebhookConfigurationRequest = {}, options?: ConfigurationOptions): Promise<V1ValidatingWebhookConfigurationList> {
        return this.api.listValidatingWebhookConfiguration(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public patchMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiPatchMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.patchMutatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public patchMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiPatchMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1MutatingWebhookConfiguration> {
        return this.api.patchMutatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicy>> {
        return this.api.patchValidatingAdmissionPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicy(param: AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicy> {
        return this.api.patchValidatingAdmissionPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicyBinding>> {
        return this.api.patchValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicyBinding> {
        return this.api.patchValidatingAdmissionPolicyBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyStatusWithHttpInfo(param: AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicy>> {
        return this.api.patchValidatingAdmissionPolicyStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyStatus(param: AdmissionregistrationV1ApiPatchValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicy> {
        return this.api.patchValidatingAdmissionPolicyStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public patchValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiPatchValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.patchValidatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public patchValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiPatchValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.patchValidatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public readMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReadMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.readMutatingWebhookConfigurationWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public readMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiReadMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1MutatingWebhookConfiguration> {
        return this.api.readMutatingWebhookConfiguration(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1ApiReadValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicy>> {
        return this.api.readValidatingAdmissionPolicyWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicy(param: AdmissionregistrationV1ApiReadValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicy> {
        return this.api.readValidatingAdmissionPolicy(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public readValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1ApiReadValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicyBinding>> {
        return this.api.readValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public readValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1ApiReadValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicyBinding> {
        return this.api.readValidatingAdmissionPolicyBinding(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicyStatusWithHttpInfo(param: AdmissionregistrationV1ApiReadValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicy>> {
        return this.api.readValidatingAdmissionPolicyStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicyStatus(param: AdmissionregistrationV1ApiReadValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicy> {
        return this.api.readValidatingAdmissionPolicyStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public readValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReadValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.readValidatingWebhookConfigurationWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public readValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiReadValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.readValidatingWebhookConfiguration(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public replaceMutatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReplaceMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1MutatingWebhookConfiguration>> {
        return this.api.replaceMutatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified MutatingWebhookConfiguration
     * @param param the request object
     */
    public replaceMutatingWebhookConfiguration(param: AdmissionregistrationV1ApiReplaceMutatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1MutatingWebhookConfiguration> {
        return this.api.replaceMutatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicy>> {
        return this.api.replaceValidatingAdmissionPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicy(param: AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicy> {
        return this.api.replaceValidatingAdmissionPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicyBinding>> {
        return this.api.replaceValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicyBinding> {
        return this.api.replaceValidatingAdmissionPolicyBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyStatusWithHttpInfo(param: AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingAdmissionPolicy>> {
        return this.api.replaceValidatingAdmissionPolicyStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyStatus(param: AdmissionregistrationV1ApiReplaceValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<V1ValidatingAdmissionPolicy> {
        return this.api.replaceValidatingAdmissionPolicyStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public replaceValidatingWebhookConfigurationWithHttpInfo(param: AdmissionregistrationV1ApiReplaceValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ValidatingWebhookConfiguration>> {
        return this.api.replaceValidatingWebhookConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingWebhookConfiguration
     * @param param the request object
     */
    public replaceValidatingWebhookConfiguration(param: AdmissionregistrationV1ApiReplaceValidatingWebhookConfigurationRequest, options?: ConfigurationOptions): Promise<V1ValidatingWebhookConfiguration> {
        return this.api.replaceValidatingWebhookConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableAdmissionregistrationV1alpha1Api } from "./ObservableAPI.js";
import { AdmissionregistrationV1alpha1ApiRequestFactory, AdmissionregistrationV1alpha1ApiResponseProcessor} from "../apis/AdmissionregistrationV1alpha1Api.js";

export interface AdmissionregistrationV1alpha1ApiCreateMutatingAdmissionPolicyRequest {
    /**
     * 
     * @type V1alpha1MutatingAdmissionPolicy
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicy
     */
    body: V1alpha1MutatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicy
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1alpha1ApiCreateMutatingAdmissionPolicyBindingRequest {
    /**
     * 
     * @type V1alpha1MutatingAdmissionPolicyBinding
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicyBinding
     */
    body: V1alpha1MutatingAdmissionPolicyBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApicreateMutatingAdmissionPolicyBinding
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1alpha1ApiDeleteCollectionMutatingAdmissionPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicy
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1alpha1ApiDeleteCollectionMutatingAdmissionPolicyBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1alpha1ApideleteCollectionMutatingAdmissionPolicyBinding
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1alpha1ApiDeleteMutatingAdmissionPolicyRequest {
    /**
     * name of the MutatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicy
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1alpha1ApiDeleteMutatingAdmissionPolicyBindingRequest {
    /**
     * name of the MutatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1alpha1ApideleteMutatingAdmissionPolicyBinding
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1alpha1ApiGetAPIResourcesRequest {
}

export interface AdmissionregistrationV1alpha1ApiListMutatingAdmissionPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicy
     */
    watch?: boolean
}

export interface AdmissionregistrationV1alpha1ApiListMutatingAdmissionPolicyBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApilistMutatingAdmissionPolicyBinding
     */
    watch?: boolean
}

export interface AdmissionregistrationV1alpha1ApiPatchMutatingAdmissionPolicyRequest {
    /**
     * name of the MutatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicy
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicy
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicy
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicy
     */
    force?: boolean
}

export interface AdmissionregistrationV1alpha1ApiPatchMutatingAdmissionPolicyBindingRequest {
    /**
     * name of the MutatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicyBinding
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicyBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicyBinding
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1alpha1ApipatchMutatingAdmissionPolicyBinding
     */
    force?: boolean
}

export interface AdmissionregistrationV1alpha1ApiReadMutatingAdmissionPolicyRequest {
    /**
     * name of the MutatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireadMutatingAdmissionPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireadMutatingAdmissionPolicy
     */
    pretty?: string
}

export interface AdmissionregistrationV1alpha1ApiReadMutatingAdmissionPolicyBindingRequest {
    /**
     * name of the MutatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireadMutatingAdmissionPolicyBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireadMutatingAdmissionPolicyBinding
     */
    pretty?: string
}

export interface AdmissionregistrationV1alpha1ApiReplaceMutatingAdmissionPolicyRequest {
    /**
     * name of the MutatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicy
     */
    name: string
    /**
     * 
     * @type V1alpha1MutatingAdmissionPolicy
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicy
     */
    body: V1alpha1MutatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicy
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1alpha1ApiReplaceMutatingAdmissionPolicyBindingRequest {
    /**
     * name of the MutatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicyBinding
     */
    name: string
    /**
     * 
     * @type V1alpha1MutatingAdmissionPolicyBinding
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicyBinding
     */
    body: V1alpha1MutatingAdmissionPolicyBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1alpha1ApireplaceMutatingAdmissionPolicyBinding
     */
    fieldValidation?: string
}

export class ObjectAdmissionregistrationV1alpha1Api {
    private api: ObservableAdmissionregistrationV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: AdmissionregistrationV1alpha1ApiRequestFactory, responseProcessor?: AdmissionregistrationV1alpha1ApiResponseProcessor) {
        this.api = new ObservableAdmissionregistrationV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a MutatingAdmissionPolicy
     * @param param the request object
     */
    public createMutatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1alpha1ApiCreateMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicy>> {
        return this.api.createMutatingAdmissionPolicyWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a MutatingAdmissionPolicy
     * @param param the request object
     */
    public createMutatingAdmissionPolicy(param: AdmissionregistrationV1alpha1ApiCreateMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicy> {
        return this.api.createMutatingAdmissionPolicy(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public createMutatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1alpha1ApiCreateMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicyBinding>> {
        return this.api.createMutatingAdmissionPolicyBindingWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public createMutatingAdmissionPolicyBinding(param: AdmissionregistrationV1alpha1ApiCreateMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicyBinding> {
        return this.api.createMutatingAdmissionPolicyBinding(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of MutatingAdmissionPolicy
     * @param param the request object
     */
    public deleteCollectionMutatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1alpha1ApiDeleteCollectionMutatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionMutatingAdmissionPolicyWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of MutatingAdmissionPolicy
     * @param param the request object
     */
    public deleteCollectionMutatingAdmissionPolicy(param: AdmissionregistrationV1alpha1ApiDeleteCollectionMutatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionMutatingAdmissionPolicy(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteCollectionMutatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1alpha1ApiDeleteCollectionMutatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionMutatingAdmissionPolicyBindingWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteCollectionMutatingAdmissionPolicyBinding(param: AdmissionregistrationV1alpha1ApiDeleteCollectionMutatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionMutatingAdmissionPolicyBinding(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingAdmissionPolicy
     * @param param the request object
     */
    public deleteMutatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1alpha1ApiDeleteMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteMutatingAdmissionPolicyWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingAdmissionPolicy
     * @param param the request object
     */
    public deleteMutatingAdmissionPolicy(param: AdmissionregistrationV1alpha1ApiDeleteMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteMutatingAdmissionPolicy(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteMutatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1alpha1ApiDeleteMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteMutatingAdmissionPolicyBindingWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteMutatingAdmissionPolicyBinding(param: AdmissionregistrationV1alpha1ApiDeleteMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteMutatingAdmissionPolicyBinding(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AdmissionregistrationV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AdmissionregistrationV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingAdmissionPolicy
     * @param param the request object
     */
    public listMutatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1alpha1ApiListMutatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicyList>> {
        return this.api.listMutatingAdmissionPolicyWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingAdmissionPolicy
     * @param param the request object
     */
    public listMutatingAdmissionPolicy(param: AdmissionregistrationV1alpha1ApiListMutatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicyList> {
        return this.api.listMutatingAdmissionPolicy(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public listMutatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1alpha1ApiListMutatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicyBindingList>> {
        return this.api.listMutatingAdmissionPolicyBindingWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public listMutatingAdmissionPolicyBinding(param: AdmissionregistrationV1alpha1ApiListMutatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicyBindingList> {
        return this.api.listMutatingAdmissionPolicyBinding(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified MutatingAdmissionPolicy
     * @param param the request object
     */
    public patchMutatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1alpha1ApiPatchMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicy>> {
        return this.api.patchMutatingAdmissionPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified MutatingAdmissionPolicy
     * @param param the request object
     */
    public patchMutatingAdmissionPolicy(param: AdmissionregistrationV1alpha1ApiPatchMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicy> {
        return this.api.patchMutatingAdmissionPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public patchMutatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1alpha1ApiPatchMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicyBinding>> {
        return this.api.patchMutatingAdmissionPolicyBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public patchMutatingAdmissionPolicyBinding(param: AdmissionregistrationV1alpha1ApiPatchMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicyBinding> {
        return this.api.patchMutatingAdmissionPolicyBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified MutatingAdmissionPolicy
     * @param param the request object
     */
    public readMutatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1alpha1ApiReadMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicy>> {
        return this.api.readMutatingAdmissionPolicyWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified MutatingAdmissionPolicy
     * @param param the request object
     */
    public readMutatingAdmissionPolicy(param: AdmissionregistrationV1alpha1ApiReadMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicy> {
        return this.api.readMutatingAdmissionPolicy(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public readMutatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1alpha1ApiReadMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicyBinding>> {
        return this.api.readMutatingAdmissionPolicyBindingWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public readMutatingAdmissionPolicyBinding(param: AdmissionregistrationV1alpha1ApiReadMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicyBinding> {
        return this.api.readMutatingAdmissionPolicyBinding(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified MutatingAdmissionPolicy
     * @param param the request object
     */
    public replaceMutatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1alpha1ApiReplaceMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicy>> {
        return this.api.replaceMutatingAdmissionPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified MutatingAdmissionPolicy
     * @param param the request object
     */
    public replaceMutatingAdmissionPolicy(param: AdmissionregistrationV1alpha1ApiReplaceMutatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicy> {
        return this.api.replaceMutatingAdmissionPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public replaceMutatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1alpha1ApiReplaceMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1MutatingAdmissionPolicyBinding>> {
        return this.api.replaceMutatingAdmissionPolicyBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified MutatingAdmissionPolicyBinding
     * @param param the request object
     */
    public replaceMutatingAdmissionPolicyBinding(param: AdmissionregistrationV1alpha1ApiReplaceMutatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1alpha1MutatingAdmissionPolicyBinding> {
        return this.api.replaceMutatingAdmissionPolicyBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableAdmissionregistrationV1beta1Api } from "./ObservableAPI.js";
import { AdmissionregistrationV1beta1ApiRequestFactory, AdmissionregistrationV1beta1ApiResponseProcessor} from "../apis/AdmissionregistrationV1beta1Api.js";

export interface AdmissionregistrationV1beta1ApiCreateValidatingAdmissionPolicyRequest {
    /**
     * 
     * @type V1beta1ValidatingAdmissionPolicy
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicy
     */
    body: V1beta1ValidatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicy
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1beta1ApiCreateValidatingAdmissionPolicyBindingRequest {
    /**
     * 
     * @type V1beta1ValidatingAdmissionPolicyBinding
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicyBinding
     */
    body: V1beta1ValidatingAdmissionPolicyBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApicreateValidatingAdmissionPolicyBinding
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1beta1ApiDeleteCollectionValidatingAdmissionPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicy
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1beta1ApiDeleteCollectionValidatingAdmissionPolicyBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteCollectionValidatingAdmissionPolicyBinding
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1beta1ApiDeleteValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicy
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1beta1ApiDeleteValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AdmissionregistrationV1beta1ApideleteValidatingAdmissionPolicyBinding
     */
    body?: V1DeleteOptions
}

export interface AdmissionregistrationV1beta1ApiGetAPIResourcesRequest {
}

export interface AdmissionregistrationV1beta1ApiListValidatingAdmissionPolicyRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicy
     */
    watch?: boolean
}

export interface AdmissionregistrationV1beta1ApiListValidatingAdmissionPolicyBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApilistValidatingAdmissionPolicyBinding
     */
    watch?: boolean
}

export interface AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicy
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicy
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicy
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicy
     */
    force?: boolean
}

export interface AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyBinding
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyBinding
     */
    force?: boolean
}

export interface AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyStatusRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AdmissionregistrationV1beta1ApipatchValidatingAdmissionPolicyStatus
     */
    force?: boolean
}

export interface AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadValidatingAdmissionPolicy
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadValidatingAdmissionPolicy
     */
    pretty?: string
}

export interface AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadValidatingAdmissionPolicyBinding
     */
    pretty?: string
}

export interface AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyStatusRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadValidatingAdmissionPolicyStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireadValidatingAdmissionPolicyStatus
     */
    pretty?: string
}

export interface AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicy
     */
    name: string
    /**
     * 
     * @type V1beta1ValidatingAdmissionPolicy
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicy
     */
    body: V1beta1ValidatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicy
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyBindingRequest {
    /**
     * name of the ValidatingAdmissionPolicyBinding
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyBinding
     */
    name: string
    /**
     * 
     * @type V1beta1ValidatingAdmissionPolicyBinding
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyBinding
     */
    body: V1beta1ValidatingAdmissionPolicyBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyBinding
     */
    fieldValidation?: string
}

export interface AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyStatusRequest {
    /**
     * name of the ValidatingAdmissionPolicy
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyStatus
     */
    name: string
    /**
     * 
     * @type V1beta1ValidatingAdmissionPolicy
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyStatus
     */
    body: V1beta1ValidatingAdmissionPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AdmissionregistrationV1beta1ApireplaceValidatingAdmissionPolicyStatus
     */
    fieldValidation?: string
}

export class ObjectAdmissionregistrationV1beta1Api {
    private api: ObservableAdmissionregistrationV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: AdmissionregistrationV1beta1ApiRequestFactory, responseProcessor?: AdmissionregistrationV1beta1ApiResponseProcessor) {
        this.api = new ObservableAdmissionregistrationV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public createValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1beta1ApiCreateValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicy>> {
        return this.api.createValidatingAdmissionPolicyWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public createValidatingAdmissionPolicy(param: AdmissionregistrationV1beta1ApiCreateValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicy> {
        return this.api.createValidatingAdmissionPolicy(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public createValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1beta1ApiCreateValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicyBinding>> {
        return this.api.createValidatingAdmissionPolicyBindingWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public createValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1beta1ApiCreateValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicyBinding> {
        return this.api.createValidatingAdmissionPolicyBinding(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1beta1ApiDeleteCollectionValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionValidatingAdmissionPolicyWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicy(param: AdmissionregistrationV1beta1ApiDeleteCollectionValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionValidatingAdmissionPolicy(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1beta1ApiDeleteCollectionValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionValidatingAdmissionPolicyBindingWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteCollectionValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1beta1ApiDeleteCollectionValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionValidatingAdmissionPolicyBinding(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1beta1ApiDeleteValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteValidatingAdmissionPolicyWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicy
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicy(param: AdmissionregistrationV1beta1ApiDeleteValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteValidatingAdmissionPolicy(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1beta1ApiDeleteValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public deleteValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1beta1ApiDeleteValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteValidatingAdmissionPolicyBinding(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AdmissionregistrationV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AdmissionregistrationV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicy
     * @param param the request object
     */
    public listValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1beta1ApiListValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicyList>> {
        return this.api.listValidatingAdmissionPolicyWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicy
     * @param param the request object
     */
    public listValidatingAdmissionPolicy(param: AdmissionregistrationV1beta1ApiListValidatingAdmissionPolicyRequest = {}, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicyList> {
        return this.api.listValidatingAdmissionPolicy(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public listValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1beta1ApiListValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicyBindingList>> {
        return this.api.listValidatingAdmissionPolicyBindingWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public listValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1beta1ApiListValidatingAdmissionPolicyBindingRequest = {}, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicyBindingList> {
        return this.api.listValidatingAdmissionPolicyBinding(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicy>> {
        return this.api.patchValidatingAdmissionPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicy(param: AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicy> {
        return this.api.patchValidatingAdmissionPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicyBinding>> {
        return this.api.patchValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicyBinding> {
        return this.api.patchValidatingAdmissionPolicyBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyStatusWithHttpInfo(param: AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicy>> {
        return this.api.patchValidatingAdmissionPolicyStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public patchValidatingAdmissionPolicyStatus(param: AdmissionregistrationV1beta1ApiPatchValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicy> {
        return this.api.patchValidatingAdmissionPolicyStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicy>> {
        return this.api.readValidatingAdmissionPolicyWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicy(param: AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicy> {
        return this.api.readValidatingAdmissionPolicy(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public readValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicyBinding>> {
        return this.api.readValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public readValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicyBinding> {
        return this.api.readValidatingAdmissionPolicyBinding(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicyStatusWithHttpInfo(param: AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicy>> {
        return this.api.readValidatingAdmissionPolicyStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public readValidatingAdmissionPolicyStatus(param: AdmissionregistrationV1beta1ApiReadValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicy> {
        return this.api.readValidatingAdmissionPolicyStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyWithHttpInfo(param: AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicy>> {
        return this.api.replaceValidatingAdmissionPolicyWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicy(param: AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicy> {
        return this.api.replaceValidatingAdmissionPolicy(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyBindingWithHttpInfo(param: AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicyBinding>> {
        return this.api.replaceValidatingAdmissionPolicyBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ValidatingAdmissionPolicyBinding
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyBinding(param: AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyBindingRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicyBinding> {
        return this.api.replaceValidatingAdmissionPolicyBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyStatusWithHttpInfo(param: AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ValidatingAdmissionPolicy>> {
        return this.api.replaceValidatingAdmissionPolicyStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ValidatingAdmissionPolicy
     * @param param the request object
     */
    public replaceValidatingAdmissionPolicyStatus(param: AdmissionregistrationV1beta1ApiReplaceValidatingAdmissionPolicyStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ValidatingAdmissionPolicy> {
        return this.api.replaceValidatingAdmissionPolicyStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableApiextensionsApi } from "./ObservableAPI.js";
import { ApiextensionsApiRequestFactory, ApiextensionsApiResponseProcessor} from "../apis/ApiextensionsApi.js";

export interface ApiextensionsApiGetAPIGroupRequest {
}

export class ObjectApiextensionsApi {
    private api: ObservableApiextensionsApi

    public constructor(configuration: Configuration, requestFactory?: ApiextensionsApiRequestFactory, responseProcessor?: ApiextensionsApiResponseProcessor) {
        this.api = new ObservableApiextensionsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: ApiextensionsApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: ApiextensionsApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableApiextensionsV1Api } from "./ObservableAPI.js";
import { ApiextensionsV1ApiRequestFactory, ApiextensionsV1ApiResponseProcessor} from "../apis/ApiextensionsV1Api.js";

export interface ApiextensionsV1ApiCreateCustomResourceDefinitionRequest {
    /**
     * 
     * @type V1CustomResourceDefinition
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    body: V1CustomResourceDefinition
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApicreateCustomResourceDefinition
     */
    fieldValidation?: string
}

export interface ApiextensionsV1ApiDeleteCollectionCustomResourceDefinitionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiextensionsV1ApideleteCollectionCustomResourceDefinition
     */
    body?: V1DeleteOptions
}

export interface ApiextensionsV1ApiDeleteCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiextensionsV1ApideleteCustomResourceDefinition
     */
    body?: V1DeleteOptions
}

export interface ApiextensionsV1ApiGetAPIResourcesRequest {
}

export interface ApiextensionsV1ApiListCustomResourceDefinitionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApilistCustomResourceDefinition
     */
    watch?: boolean
}

export interface ApiextensionsV1ApiPatchCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinition
     */
    force?: boolean
}

export interface ApiextensionsV1ApiPatchCustomResourceDefinitionStatusRequest {
    /**
     * name of the CustomResourceDefinition
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiextensionsV1ApipatchCustomResourceDefinitionStatus
     */
    force?: boolean
}

export interface ApiextensionsV1ApiReadCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinition
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinition
     */
    pretty?: string
}

export interface ApiextensionsV1ApiReadCustomResourceDefinitionStatusRequest {
    /**
     * name of the CustomResourceDefinition
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinitionStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireadCustomResourceDefinitionStatus
     */
    pretty?: string
}

export interface ApiextensionsV1ApiReplaceCustomResourceDefinitionRequest {
    /**
     * name of the CustomResourceDefinition
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    name: string
    /**
     * 
     * @type V1CustomResourceDefinition
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    body: V1CustomResourceDefinition
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinition
     */
    fieldValidation?: string
}

export interface ApiextensionsV1ApiReplaceCustomResourceDefinitionStatusRequest {
    /**
     * name of the CustomResourceDefinition
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    name: string
    /**
     * 
     * @type V1CustomResourceDefinition
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    body: V1CustomResourceDefinition
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiextensionsV1ApireplaceCustomResourceDefinitionStatus
     */
    fieldValidation?: string
}

export class ObjectApiextensionsV1Api {
    private api: ObservableApiextensionsV1Api

    public constructor(configuration: Configuration, requestFactory?: ApiextensionsV1ApiRequestFactory, responseProcessor?: ApiextensionsV1ApiResponseProcessor) {
        this.api = new ObservableApiextensionsV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CustomResourceDefinition
     * @param param the request object
     */
    public createCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiCreateCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.createCustomResourceDefinitionWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CustomResourceDefinition
     * @param param the request object
     */
    public createCustomResourceDefinition(param: ApiextensionsV1ApiCreateCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<V1CustomResourceDefinition> {
        return this.api.createCustomResourceDefinition(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of CustomResourceDefinition
     * @param param the request object
     */
    public deleteCollectionCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiDeleteCollectionCustomResourceDefinitionRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCustomResourceDefinitionWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CustomResourceDefinition
     * @param param the request object
     */
    public deleteCollectionCustomResourceDefinition(param: ApiextensionsV1ApiDeleteCollectionCustomResourceDefinitionRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionCustomResourceDefinition(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CustomResourceDefinition
     * @param param the request object
     */
    public deleteCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiDeleteCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCustomResourceDefinitionWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CustomResourceDefinition
     * @param param the request object
     */
    public deleteCustomResourceDefinition(param: ApiextensionsV1ApiDeleteCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCustomResourceDefinition(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: ApiextensionsV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: ApiextensionsV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CustomResourceDefinition
     * @param param the request object
     */
    public listCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiListCustomResourceDefinitionRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinitionList>> {
        return this.api.listCustomResourceDefinitionWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CustomResourceDefinition
     * @param param the request object
     */
    public listCustomResourceDefinition(param: ApiextensionsV1ApiListCustomResourceDefinitionRequest = {}, options?: ConfigurationOptions): Promise<V1CustomResourceDefinitionList> {
        return this.api.listCustomResourceDefinition(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiPatchCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.patchCustomResourceDefinitionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinition(param: ApiextensionsV1ApiPatchCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<V1CustomResourceDefinition> {
        return this.api.patchCustomResourceDefinition(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinitionStatusWithHttpInfo(param: ApiextensionsV1ApiPatchCustomResourceDefinitionStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.patchCustomResourceDefinitionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public patchCustomResourceDefinitionStatus(param: ApiextensionsV1ApiPatchCustomResourceDefinitionStatusRequest, options?: ConfigurationOptions): Promise<V1CustomResourceDefinition> {
        return this.api.patchCustomResourceDefinitionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiReadCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.readCustomResourceDefinitionWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinition(param: ApiextensionsV1ApiReadCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<V1CustomResourceDefinition> {
        return this.api.readCustomResourceDefinition(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinitionStatusWithHttpInfo(param: ApiextensionsV1ApiReadCustomResourceDefinitionStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.readCustomResourceDefinitionStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public readCustomResourceDefinitionStatus(param: ApiextensionsV1ApiReadCustomResourceDefinitionStatusRequest, options?: ConfigurationOptions): Promise<V1CustomResourceDefinition> {
        return this.api.readCustomResourceDefinitionStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinitionWithHttpInfo(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.replaceCustomResourceDefinitionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinition(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionRequest, options?: ConfigurationOptions): Promise<V1CustomResourceDefinition> {
        return this.api.replaceCustomResourceDefinition(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinitionStatusWithHttpInfo(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CustomResourceDefinition>> {
        return this.api.replaceCustomResourceDefinitionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified CustomResourceDefinition
     * @param param the request object
     */
    public replaceCustomResourceDefinitionStatus(param: ApiextensionsV1ApiReplaceCustomResourceDefinitionStatusRequest, options?: ConfigurationOptions): Promise<V1CustomResourceDefinition> {
        return this.api.replaceCustomResourceDefinitionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableApiregistrationApi } from "./ObservableAPI.js";
import { ApiregistrationApiRequestFactory, ApiregistrationApiResponseProcessor} from "../apis/ApiregistrationApi.js";

export interface ApiregistrationApiGetAPIGroupRequest {
}

export class ObjectApiregistrationApi {
    private api: ObservableApiregistrationApi

    public constructor(configuration: Configuration, requestFactory?: ApiregistrationApiRequestFactory, responseProcessor?: ApiregistrationApiResponseProcessor) {
        this.api = new ObservableApiregistrationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: ApiregistrationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: ApiregistrationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableApiregistrationV1Api } from "./ObservableAPI.js";
import { ApiregistrationV1ApiRequestFactory, ApiregistrationV1ApiResponseProcessor} from "../apis/ApiregistrationV1Api.js";

export interface ApiregistrationV1ApiCreateAPIServiceRequest {
    /**
     * 
     * @type V1APIService
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    body: V1APIService
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApicreateAPIService
     */
    fieldValidation?: string
}

export interface ApiregistrationV1ApiDeleteAPIServiceRequest {
    /**
     * name of the APIService
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiregistrationV1ApideleteAPIService
     */
    body?: V1DeleteOptions
}

export interface ApiregistrationV1ApiDeleteCollectionAPIServiceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ApiregistrationV1ApideleteCollectionAPIService
     */
    body?: V1DeleteOptions
}

export interface ApiregistrationV1ApiGetAPIResourcesRequest {
}

export interface ApiregistrationV1ApiListAPIServiceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApilistAPIService
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ApiregistrationV1ApilistAPIService
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApilistAPIService
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApilistAPIService
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ApiregistrationV1ApilistAPIService
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApilistAPIService
     */
    watch?: boolean
}

export interface ApiregistrationV1ApiPatchAPIServiceRequest {
    /**
     * name of the APIService
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApipatchAPIService
     */
    force?: boolean
}

export interface ApiregistrationV1ApiPatchAPIServiceStatusRequest {
    /**
     * name of the APIService
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ApiregistrationV1ApipatchAPIServiceStatus
     */
    force?: boolean
}

export interface ApiregistrationV1ApiReadAPIServiceRequest {
    /**
     * name of the APIService
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireadAPIService
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireadAPIService
     */
    pretty?: string
}

export interface ApiregistrationV1ApiReadAPIServiceStatusRequest {
    /**
     * name of the APIService
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireadAPIServiceStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireadAPIServiceStatus
     */
    pretty?: string
}

export interface ApiregistrationV1ApiReplaceAPIServiceRequest {
    /**
     * name of the APIService
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    name: string
    /**
     * 
     * @type V1APIService
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    body: V1APIService
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIService
     */
    fieldValidation?: string
}

export interface ApiregistrationV1ApiReplaceAPIServiceStatusRequest {
    /**
     * name of the APIService
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    name: string
    /**
     * 
     * @type V1APIService
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    body: V1APIService
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ApiregistrationV1ApireplaceAPIServiceStatus
     */
    fieldValidation?: string
}

export class ObjectApiregistrationV1Api {
    private api: ObservableApiregistrationV1Api

    public constructor(configuration: Configuration, requestFactory?: ApiregistrationV1ApiRequestFactory, responseProcessor?: ApiregistrationV1ApiResponseProcessor) {
        this.api = new ObservableApiregistrationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an APIService
     * @param param the request object
     */
    public createAPIServiceWithHttpInfo(param: ApiregistrationV1ApiCreateAPIServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIService>> {
        return this.api.createAPIServiceWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an APIService
     * @param param the request object
     */
    public createAPIService(param: ApiregistrationV1ApiCreateAPIServiceRequest, options?: ConfigurationOptions): Promise<V1APIService> {
        return this.api.createAPIService(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete an APIService
     * @param param the request object
     */
    public deleteAPIServiceWithHttpInfo(param: ApiregistrationV1ApiDeleteAPIServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteAPIServiceWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an APIService
     * @param param the request object
     */
    public deleteAPIService(param: ApiregistrationV1ApiDeleteAPIServiceRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteAPIService(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of APIService
     * @param param the request object
     */
    public deleteCollectionAPIServiceWithHttpInfo(param: ApiregistrationV1ApiDeleteCollectionAPIServiceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionAPIServiceWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of APIService
     * @param param the request object
     */
    public deleteCollectionAPIService(param: ApiregistrationV1ApiDeleteCollectionAPIServiceRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionAPIService(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: ApiregistrationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: ApiregistrationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind APIService
     * @param param the request object
     */
    public listAPIServiceWithHttpInfo(param: ApiregistrationV1ApiListAPIServiceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIServiceList>> {
        return this.api.listAPIServiceWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind APIService
     * @param param the request object
     */
    public listAPIService(param: ApiregistrationV1ApiListAPIServiceRequest = {}, options?: ConfigurationOptions): Promise<V1APIServiceList> {
        return this.api.listAPIService(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified APIService
     * @param param the request object
     */
    public patchAPIServiceWithHttpInfo(param: ApiregistrationV1ApiPatchAPIServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIService>> {
        return this.api.patchAPIServiceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified APIService
     * @param param the request object
     */
    public patchAPIService(param: ApiregistrationV1ApiPatchAPIServiceRequest, options?: ConfigurationOptions): Promise<V1APIService> {
        return this.api.patchAPIService(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified APIService
     * @param param the request object
     */
    public patchAPIServiceStatusWithHttpInfo(param: ApiregistrationV1ApiPatchAPIServiceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIService>> {
        return this.api.patchAPIServiceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified APIService
     * @param param the request object
     */
    public patchAPIServiceStatus(param: ApiregistrationV1ApiPatchAPIServiceStatusRequest, options?: ConfigurationOptions): Promise<V1APIService> {
        return this.api.patchAPIServiceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified APIService
     * @param param the request object
     */
    public readAPIServiceWithHttpInfo(param: ApiregistrationV1ApiReadAPIServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIService>> {
        return this.api.readAPIServiceWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified APIService
     * @param param the request object
     */
    public readAPIService(param: ApiregistrationV1ApiReadAPIServiceRequest, options?: ConfigurationOptions): Promise<V1APIService> {
        return this.api.readAPIService(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified APIService
     * @param param the request object
     */
    public readAPIServiceStatusWithHttpInfo(param: ApiregistrationV1ApiReadAPIServiceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIService>> {
        return this.api.readAPIServiceStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified APIService
     * @param param the request object
     */
    public readAPIServiceStatus(param: ApiregistrationV1ApiReadAPIServiceStatusRequest, options?: ConfigurationOptions): Promise<V1APIService> {
        return this.api.readAPIServiceStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified APIService
     * @param param the request object
     */
    public replaceAPIServiceWithHttpInfo(param: ApiregistrationV1ApiReplaceAPIServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIService>> {
        return this.api.replaceAPIServiceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified APIService
     * @param param the request object
     */
    public replaceAPIService(param: ApiregistrationV1ApiReplaceAPIServiceRequest, options?: ConfigurationOptions): Promise<V1APIService> {
        return this.api.replaceAPIService(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified APIService
     * @param param the request object
     */
    public replaceAPIServiceStatusWithHttpInfo(param: ApiregistrationV1ApiReplaceAPIServiceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIService>> {
        return this.api.replaceAPIServiceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified APIService
     * @param param the request object
     */
    public replaceAPIServiceStatus(param: ApiregistrationV1ApiReplaceAPIServiceStatusRequest, options?: ConfigurationOptions): Promise<V1APIService> {
        return this.api.replaceAPIServiceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableApisApi } from "./ObservableAPI.js";
import { ApisApiRequestFactory, ApisApiResponseProcessor} from "../apis/ApisApi.js";

export interface ApisApiGetAPIVersionsRequest {
}

export class ObjectApisApi {
    private api: ObservableApisApi

    public constructor(configuration: Configuration, requestFactory?: ApisApiRequestFactory, responseProcessor?: ApisApiResponseProcessor) {
        this.api = new ObservableApisApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersionsWithHttpInfo(param: ApisApiGetAPIVersionsRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroupList>> {
        return this.api.getAPIVersionsWithHttpInfo( options).toPromise();
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersions(param: ApisApiGetAPIVersionsRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroupList> {
        return this.api.getAPIVersions( options).toPromise();
    }

}

import { ObservableAppsApi } from "./ObservableAPI.js";
import { AppsApiRequestFactory, AppsApiResponseProcessor} from "../apis/AppsApi.js";

export interface AppsApiGetAPIGroupRequest {
}

export class ObjectAppsApi {
    private api: ObservableAppsApi

    public constructor(configuration: Configuration, requestFactory?: AppsApiRequestFactory, responseProcessor?: AppsApiResponseProcessor) {
        this.api = new ObservableAppsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AppsApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AppsApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAppsV1Api } from "./ObservableAPI.js";
import { AppsV1ApiRequestFactory, AppsV1ApiResponseProcessor} from "../apis/AppsV1Api.js";

export interface AppsV1ApiCreateNamespacedControllerRevisionRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    namespace: string
    /**
     * 
     * @type V1ControllerRevision
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    body: V1ControllerRevision
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedControllerRevision
     */
    fieldValidation?: string
}

export interface AppsV1ApiCreateNamespacedDaemonSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    namespace: string
    /**
     * 
     * @type V1DaemonSet
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    body: V1DaemonSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDaemonSet
     */
    fieldValidation?: string
}

export interface AppsV1ApiCreateNamespacedDeploymentRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    namespace: string
    /**
     * 
     * @type V1Deployment
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    body: V1Deployment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedDeployment
     */
    fieldValidation?: string
}

export interface AppsV1ApiCreateNamespacedReplicaSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    namespace: string
    /**
     * 
     * @type V1ReplicaSet
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    body: V1ReplicaSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedReplicaSet
     */
    fieldValidation?: string
}

export interface AppsV1ApiCreateNamespacedStatefulSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    namespace: string
    /**
     * 
     * @type V1StatefulSet
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    body: V1StatefulSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApicreateNamespacedStatefulSet
     */
    fieldValidation?: string
}

export interface AppsV1ApiDeleteCollectionNamespacedControllerRevisionRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedControllerRevision
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedDaemonSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedDaemonSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedDeploymentRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedDeployment
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedReplicaSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedReplicaSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteCollectionNamespacedStatefulSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteCollectionNamespacedStatefulSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedControllerRevision
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedDaemonSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedDeployment
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedReplicaSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiDeleteNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AppsV1ApideleteNamespacedStatefulSet
     */
    body?: V1DeleteOptions
}

export interface AppsV1ApiGetAPIResourcesRequest {
}

export interface AppsV1ApiListControllerRevisionForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistControllerRevisionForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListDaemonSetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistDaemonSetForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListDeploymentForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistDeploymentForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedControllerRevisionRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedControllerRevision
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedDaemonSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDaemonSet
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedDeploymentRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedDeployment
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedReplicaSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedReplicaSet
     */
    watch?: boolean
}

export interface AppsV1ApiListNamespacedStatefulSetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistNamespacedStatefulSet
     */
    watch?: boolean
}

export interface AppsV1ApiListReplicaSetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistReplicaSetForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiListStatefulSetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApilistStatefulSetForAllNamespaces
     */
    watch?: boolean
}

export interface AppsV1ApiPatchNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedControllerRevision
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDaemonSet
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDaemonSetStatusRequest {
    /**
     * name of the DaemonSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDaemonSetStatus
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDeployment
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDeploymentScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDeploymentScale
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedDeploymentStatusRequest {
    /**
     * name of the Deployment
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedDeploymentStatus
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedReplicaSet
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedReplicaSetScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedReplicaSetScale
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedReplicaSetStatusRequest {
    /**
     * name of the ReplicaSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedReplicaSetStatus
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedStatefulSet
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedStatefulSetScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedStatefulSetScale
     */
    force?: boolean
}

export interface AppsV1ApiPatchNamespacedStatefulSetStatusRequest {
    /**
     * name of the StatefulSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AppsV1ApipatchNamespacedStatefulSetStatus
     */
    force?: boolean
}

export interface AppsV1ApiReadNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedControllerRevision
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedControllerRevision
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSet
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDaemonSetStatusRequest {
    /**
     * name of the DaemonSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDaemonSetStatus
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeployment
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeployment
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDeploymentScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentScale
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedDeploymentStatusRequest {
    /**
     * name of the Deployment
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedDeploymentStatus
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSet
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedReplicaSetScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetScale
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedReplicaSetStatusRequest {
    /**
     * name of the ReplicaSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedReplicaSetStatus
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSet
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSet
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedStatefulSetScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetScale
     */
    pretty?: string
}

export interface AppsV1ApiReadNamespacedStatefulSetStatusRequest {
    /**
     * name of the StatefulSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireadNamespacedStatefulSetStatus
     */
    pretty?: string
}

export interface AppsV1ApiReplaceNamespacedControllerRevisionRequest {
    /**
     * name of the ControllerRevision
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    namespace: string
    /**
     * 
     * @type V1ControllerRevision
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    body: V1ControllerRevision
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedControllerRevision
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedDaemonSetRequest {
    /**
     * name of the DaemonSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    namespace: string
    /**
     * 
     * @type V1DaemonSet
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    body: V1DaemonSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSet
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedDaemonSetStatusRequest {
    /**
     * name of the DaemonSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    namespace: string
    /**
     * 
     * @type V1DaemonSet
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    body: V1DaemonSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDaemonSetStatus
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedDeploymentRequest {
    /**
     * name of the Deployment
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    namespace: string
    /**
     * 
     * @type V1Deployment
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    body: V1Deployment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeployment
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedDeploymentScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentScale
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedDeploymentStatusRequest {
    /**
     * name of the Deployment
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    namespace: string
    /**
     * 
     * @type V1Deployment
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    body: V1Deployment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedDeploymentStatus
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedReplicaSetRequest {
    /**
     * name of the ReplicaSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    namespace: string
    /**
     * 
     * @type V1ReplicaSet
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    body: V1ReplicaSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSet
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedReplicaSetScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetScale
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedReplicaSetStatusRequest {
    /**
     * name of the ReplicaSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    namespace: string
    /**
     * 
     * @type V1ReplicaSet
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    body: V1ReplicaSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedReplicaSetStatus
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedStatefulSetRequest {
    /**
     * name of the StatefulSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    namespace: string
    /**
     * 
     * @type V1StatefulSet
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    body: V1StatefulSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSet
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedStatefulSetScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetScale
     */
    fieldValidation?: string
}

export interface AppsV1ApiReplaceNamespacedStatefulSetStatusRequest {
    /**
     * name of the StatefulSet
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    namespace: string
    /**
     * 
     * @type V1StatefulSet
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    body: V1StatefulSet
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AppsV1ApireplaceNamespacedStatefulSetStatus
     */
    fieldValidation?: string
}

export class ObjectAppsV1Api {
    private api: ObservableAppsV1Api

    public constructor(configuration: Configuration, requestFactory?: AppsV1ApiRequestFactory, responseProcessor?: AppsV1ApiResponseProcessor) {
        this.api = new ObservableAppsV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ControllerRevision
     * @param param the request object
     */
    public createNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiCreateNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.createNamespacedControllerRevisionWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ControllerRevision
     * @param param the request object
     */
    public createNamespacedControllerRevision(param: AppsV1ApiCreateNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<V1ControllerRevision> {
        return this.api.createNamespacedControllerRevision(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a DaemonSet
     * @param param the request object
     */
    public createNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiCreateNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.createNamespacedDaemonSetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a DaemonSet
     * @param param the request object
     */
    public createNamespacedDaemonSet(param: AppsV1ApiCreateNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<V1DaemonSet> {
        return this.api.createNamespacedDaemonSet(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Deployment
     * @param param the request object
     */
    public createNamespacedDeploymentWithHttpInfo(param: AppsV1ApiCreateNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Deployment>> {
        return this.api.createNamespacedDeploymentWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Deployment
     * @param param the request object
     */
    public createNamespacedDeployment(param: AppsV1ApiCreateNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<V1Deployment> {
        return this.api.createNamespacedDeployment(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ReplicaSet
     * @param param the request object
     */
    public createNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiCreateNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.createNamespacedReplicaSetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ReplicaSet
     * @param param the request object
     */
    public createNamespacedReplicaSet(param: AppsV1ApiCreateNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<V1ReplicaSet> {
        return this.api.createNamespacedReplicaSet(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a StatefulSet
     * @param param the request object
     */
    public createNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiCreateNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.createNamespacedStatefulSetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a StatefulSet
     * @param param the request object
     */
    public createNamespacedStatefulSet(param: AppsV1ApiCreateNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<V1StatefulSet> {
        return this.api.createNamespacedStatefulSet(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of ControllerRevision
     * @param param the request object
     */
    public deleteCollectionNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedControllerRevisionWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ControllerRevision
     * @param param the request object
     */
    public deleteCollectionNamespacedControllerRevision(param: AppsV1ApiDeleteCollectionNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedControllerRevision(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DaemonSet
     * @param param the request object
     */
    public deleteCollectionNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedDaemonSetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DaemonSet
     * @param param the request object
     */
    public deleteCollectionNamespacedDaemonSet(param: AppsV1ApiDeleteCollectionNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedDaemonSet(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Deployment
     * @param param the request object
     */
    public deleteCollectionNamespacedDeploymentWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedDeploymentWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Deployment
     * @param param the request object
     */
    public deleteCollectionNamespacedDeployment(param: AppsV1ApiDeleteCollectionNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedDeployment(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicaSet
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedReplicaSetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicaSet
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicaSet(param: AppsV1ApiDeleteCollectionNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedReplicaSet(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StatefulSet
     * @param param the request object
     */
    public deleteCollectionNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiDeleteCollectionNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedStatefulSetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StatefulSet
     * @param param the request object
     */
    public deleteCollectionNamespacedStatefulSet(param: AppsV1ApiDeleteCollectionNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedStatefulSet(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a ControllerRevision
     * @param param the request object
     */
    public deleteNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiDeleteNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ControllerRevision
     * @param param the request object
     */
    public deleteNamespacedControllerRevision(param: AppsV1ApiDeleteNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedControllerRevision(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DaemonSet
     * @param param the request object
     */
    public deleteNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiDeleteNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DaemonSet
     * @param param the request object
     */
    public deleteNamespacedDaemonSet(param: AppsV1ApiDeleteNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedDaemonSet(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Deployment
     * @param param the request object
     */
    public deleteNamespacedDeploymentWithHttpInfo(param: AppsV1ApiDeleteNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Deployment
     * @param param the request object
     */
    public deleteNamespacedDeployment(param: AppsV1ApiDeleteNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedDeployment(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicaSet
     * @param param the request object
     */
    public deleteNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiDeleteNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicaSet
     * @param param the request object
     */
    public deleteNamespacedReplicaSet(param: AppsV1ApiDeleteNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedReplicaSet(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StatefulSet
     * @param param the request object
     */
    public deleteNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiDeleteNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StatefulSet
     * @param param the request object
     */
    public deleteNamespacedStatefulSet(param: AppsV1ApiDeleteNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedStatefulSet(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AppsV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AppsV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listControllerRevisionForAllNamespacesWithHttpInfo(param: AppsV1ApiListControllerRevisionForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ControllerRevisionList>> {
        return this.api.listControllerRevisionForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listControllerRevisionForAllNamespaces(param: AppsV1ApiListControllerRevisionForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1ControllerRevisionList> {
        return this.api.listControllerRevisionForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listDaemonSetForAllNamespacesWithHttpInfo(param: AppsV1ApiListDaemonSetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSetList>> {
        return this.api.listDaemonSetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listDaemonSetForAllNamespaces(param: AppsV1ApiListDaemonSetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1DaemonSetList> {
        return this.api.listDaemonSetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listDeploymentForAllNamespacesWithHttpInfo(param: AppsV1ApiListDeploymentForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1DeploymentList>> {
        return this.api.listDeploymentForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listDeploymentForAllNamespaces(param: AppsV1ApiListDeploymentForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1DeploymentList> {
        return this.api.listDeploymentForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiListNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ControllerRevisionList>> {
        return this.api.listNamespacedControllerRevisionWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ControllerRevision
     * @param param the request object
     */
    public listNamespacedControllerRevision(param: AppsV1ApiListNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<V1ControllerRevisionList> {
        return this.api.listNamespacedControllerRevision(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiListNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSetList>> {
        return this.api.listNamespacedDaemonSetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DaemonSet
     * @param param the request object
     */
    public listNamespacedDaemonSet(param: AppsV1ApiListNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<V1DaemonSetList> {
        return this.api.listNamespacedDaemonSet(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listNamespacedDeploymentWithHttpInfo(param: AppsV1ApiListNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DeploymentList>> {
        return this.api.listNamespacedDeploymentWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Deployment
     * @param param the request object
     */
    public listNamespacedDeployment(param: AppsV1ApiListNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<V1DeploymentList> {
        return this.api.listNamespacedDeployment(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiListNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSetList>> {
        return this.api.listNamespacedReplicaSetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listNamespacedReplicaSet(param: AppsV1ApiListNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<V1ReplicaSetList> {
        return this.api.listNamespacedReplicaSet(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiListNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSetList>> {
        return this.api.listNamespacedStatefulSetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listNamespacedStatefulSet(param: AppsV1ApiListNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<V1StatefulSetList> {
        return this.api.listNamespacedStatefulSet(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listReplicaSetForAllNamespacesWithHttpInfo(param: AppsV1ApiListReplicaSetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSetList>> {
        return this.api.listReplicaSetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicaSet
     * @param param the request object
     */
    public listReplicaSetForAllNamespaces(param: AppsV1ApiListReplicaSetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1ReplicaSetList> {
        return this.api.listReplicaSetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listStatefulSetForAllNamespacesWithHttpInfo(param: AppsV1ApiListStatefulSetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSetList>> {
        return this.api.listStatefulSetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StatefulSet
     * @param param the request object
     */
    public listStatefulSetForAllNamespaces(param: AppsV1ApiListStatefulSetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1StatefulSetList> {
        return this.api.listStatefulSetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ControllerRevision
     * @param param the request object
     */
    public patchNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiPatchNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.patchNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ControllerRevision
     * @param param the request object
     */
    public patchNamespacedControllerRevision(param: AppsV1ApiPatchNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<V1ControllerRevision> {
        return this.api.patchNamespacedControllerRevision(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiPatchNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.patchNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSet(param: AppsV1ApiPatchNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<V1DaemonSet> {
        return this.api.patchNamespacedDaemonSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSetStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedDaemonSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.patchNamespacedDaemonSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified DaemonSet
     * @param param the request object
     */
    public patchNamespacedDaemonSetStatus(param: AppsV1ApiPatchNamespacedDaemonSetStatusRequest, options?: ConfigurationOptions): Promise<V1DaemonSet> {
        return this.api.patchNamespacedDaemonSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentWithHttpInfo(param: AppsV1ApiPatchNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Deployment>> {
        return this.api.patchNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeployment(param: AppsV1ApiPatchNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<V1Deployment> {
        return this.api.patchNamespacedDeployment(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentScaleWithHttpInfo(param: AppsV1ApiPatchNamespacedDeploymentScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedDeploymentScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentScale(param: AppsV1ApiPatchNamespacedDeploymentScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.patchNamespacedDeploymentScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedDeploymentStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Deployment>> {
        return this.api.patchNamespacedDeploymentStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Deployment
     * @param param the request object
     */
    public patchNamespacedDeploymentStatus(param: AppsV1ApiPatchNamespacedDeploymentStatusRequest, options?: ConfigurationOptions): Promise<V1Deployment> {
        return this.api.patchNamespacedDeploymentStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiPatchNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.patchNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSet(param: AppsV1ApiPatchNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<V1ReplicaSet> {
        return this.api.patchNamespacedReplicaSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetScaleWithHttpInfo(param: AppsV1ApiPatchNamespacedReplicaSetScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedReplicaSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetScale(param: AppsV1ApiPatchNamespacedReplicaSetScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.patchNamespacedReplicaSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedReplicaSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.patchNamespacedReplicaSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicaSet
     * @param param the request object
     */
    public patchNamespacedReplicaSetStatus(param: AppsV1ApiPatchNamespacedReplicaSetStatusRequest, options?: ConfigurationOptions): Promise<V1ReplicaSet> {
        return this.api.patchNamespacedReplicaSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiPatchNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.patchNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSet(param: AppsV1ApiPatchNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<V1StatefulSet> {
        return this.api.patchNamespacedStatefulSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetScaleWithHttpInfo(param: AppsV1ApiPatchNamespacedStatefulSetScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedStatefulSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetScale(param: AppsV1ApiPatchNamespacedStatefulSetScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.patchNamespacedStatefulSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetStatusWithHttpInfo(param: AppsV1ApiPatchNamespacedStatefulSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.patchNamespacedStatefulSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StatefulSet
     * @param param the request object
     */
    public patchNamespacedStatefulSetStatus(param: AppsV1ApiPatchNamespacedStatefulSetStatusRequest, options?: ConfigurationOptions): Promise<V1StatefulSet> {
        return this.api.patchNamespacedStatefulSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified ControllerRevision
     * @param param the request object
     */
    public readNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiReadNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.readNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ControllerRevision
     * @param param the request object
     */
    public readNamespacedControllerRevision(param: AppsV1ApiReadNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<V1ControllerRevision> {
        return this.api.readNamespacedControllerRevision(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiReadNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.readNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSet(param: AppsV1ApiReadNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<V1DaemonSet> {
        return this.api.readNamespacedDaemonSet(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSetStatusWithHttpInfo(param: AppsV1ApiReadNamespacedDaemonSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.readNamespacedDaemonSetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified DaemonSet
     * @param param the request object
     */
    public readNamespacedDaemonSetStatus(param: AppsV1ApiReadNamespacedDaemonSetStatusRequest, options?: ConfigurationOptions): Promise<V1DaemonSet> {
        return this.api.readNamespacedDaemonSetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentWithHttpInfo(param: AppsV1ApiReadNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Deployment>> {
        return this.api.readNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeployment(param: AppsV1ApiReadNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<V1Deployment> {
        return this.api.readNamespacedDeployment(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentScaleWithHttpInfo(param: AppsV1ApiReadNamespacedDeploymentScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedDeploymentScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentScale(param: AppsV1ApiReadNamespacedDeploymentScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.readNamespacedDeploymentScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentStatusWithHttpInfo(param: AppsV1ApiReadNamespacedDeploymentStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Deployment>> {
        return this.api.readNamespacedDeploymentStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Deployment
     * @param param the request object
     */
    public readNamespacedDeploymentStatus(param: AppsV1ApiReadNamespacedDeploymentStatusRequest, options?: ConfigurationOptions): Promise<V1Deployment> {
        return this.api.readNamespacedDeploymentStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiReadNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.readNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSet(param: AppsV1ApiReadNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<V1ReplicaSet> {
        return this.api.readNamespacedReplicaSet(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetScaleWithHttpInfo(param: AppsV1ApiReadNamespacedReplicaSetScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedReplicaSetScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetScale(param: AppsV1ApiReadNamespacedReplicaSetScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.readNamespacedReplicaSetScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetStatusWithHttpInfo(param: AppsV1ApiReadNamespacedReplicaSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.readNamespacedReplicaSetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicaSet
     * @param param the request object
     */
    public readNamespacedReplicaSetStatus(param: AppsV1ApiReadNamespacedReplicaSetStatusRequest, options?: ConfigurationOptions): Promise<V1ReplicaSet> {
        return this.api.readNamespacedReplicaSetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiReadNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.readNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSet(param: AppsV1ApiReadNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<V1StatefulSet> {
        return this.api.readNamespacedStatefulSet(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetScaleWithHttpInfo(param: AppsV1ApiReadNamespacedStatefulSetScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedStatefulSetScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetScale(param: AppsV1ApiReadNamespacedStatefulSetScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.readNamespacedStatefulSetScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetStatusWithHttpInfo(param: AppsV1ApiReadNamespacedStatefulSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.readNamespacedStatefulSetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StatefulSet
     * @param param the request object
     */
    public readNamespacedStatefulSetStatus(param: AppsV1ApiReadNamespacedStatefulSetStatusRequest, options?: ConfigurationOptions): Promise<V1StatefulSet> {
        return this.api.readNamespacedStatefulSetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ControllerRevision
     * @param param the request object
     */
    public replaceNamespacedControllerRevisionWithHttpInfo(param: AppsV1ApiReplaceNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ControllerRevision>> {
        return this.api.replaceNamespacedControllerRevisionWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ControllerRevision
     * @param param the request object
     */
    public replaceNamespacedControllerRevision(param: AppsV1ApiReplaceNamespacedControllerRevisionRequest, options?: ConfigurationOptions): Promise<V1ControllerRevision> {
        return this.api.replaceNamespacedControllerRevision(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSetWithHttpInfo(param: AppsV1ApiReplaceNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.replaceNamespacedDaemonSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSet(param: AppsV1ApiReplaceNamespacedDaemonSetRequest, options?: ConfigurationOptions): Promise<V1DaemonSet> {
        return this.api.replaceNamespacedDaemonSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSetStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedDaemonSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1DaemonSet>> {
        return this.api.replaceNamespacedDaemonSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified DaemonSet
     * @param param the request object
     */
    public replaceNamespacedDaemonSetStatus(param: AppsV1ApiReplaceNamespacedDaemonSetStatusRequest, options?: ConfigurationOptions): Promise<V1DaemonSet> {
        return this.api.replaceNamespacedDaemonSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentWithHttpInfo(param: AppsV1ApiReplaceNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Deployment>> {
        return this.api.replaceNamespacedDeploymentWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeployment(param: AppsV1ApiReplaceNamespacedDeploymentRequest, options?: ConfigurationOptions): Promise<V1Deployment> {
        return this.api.replaceNamespacedDeployment(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentScaleWithHttpInfo(param: AppsV1ApiReplaceNamespacedDeploymentScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedDeploymentScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentScale(param: AppsV1ApiReplaceNamespacedDeploymentScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.replaceNamespacedDeploymentScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedDeploymentStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Deployment>> {
        return this.api.replaceNamespacedDeploymentStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Deployment
     * @param param the request object
     */
    public replaceNamespacedDeploymentStatus(param: AppsV1ApiReplaceNamespacedDeploymentStatusRequest, options?: ConfigurationOptions): Promise<V1Deployment> {
        return this.api.replaceNamespacedDeploymentStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetWithHttpInfo(param: AppsV1ApiReplaceNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.replaceNamespacedReplicaSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSet(param: AppsV1ApiReplaceNamespacedReplicaSetRequest, options?: ConfigurationOptions): Promise<V1ReplicaSet> {
        return this.api.replaceNamespacedReplicaSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetScaleWithHttpInfo(param: AppsV1ApiReplaceNamespacedReplicaSetScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedReplicaSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetScale(param: AppsV1ApiReplaceNamespacedReplicaSetScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.replaceNamespacedReplicaSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedReplicaSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicaSet>> {
        return this.api.replaceNamespacedReplicaSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicaSet
     * @param param the request object
     */
    public replaceNamespacedReplicaSetStatus(param: AppsV1ApiReplaceNamespacedReplicaSetStatusRequest, options?: ConfigurationOptions): Promise<V1ReplicaSet> {
        return this.api.replaceNamespacedReplicaSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetWithHttpInfo(param: AppsV1ApiReplaceNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.replaceNamespacedStatefulSetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSet(param: AppsV1ApiReplaceNamespacedStatefulSetRequest, options?: ConfigurationOptions): Promise<V1StatefulSet> {
        return this.api.replaceNamespacedStatefulSet(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetScaleWithHttpInfo(param: AppsV1ApiReplaceNamespacedStatefulSetScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedStatefulSetScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetScale(param: AppsV1ApiReplaceNamespacedStatefulSetScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.replaceNamespacedStatefulSetScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetStatusWithHttpInfo(param: AppsV1ApiReplaceNamespacedStatefulSetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StatefulSet>> {
        return this.api.replaceNamespacedStatefulSetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified StatefulSet
     * @param param the request object
     */
    public replaceNamespacedStatefulSetStatus(param: AppsV1ApiReplaceNamespacedStatefulSetStatusRequest, options?: ConfigurationOptions): Promise<V1StatefulSet> {
        return this.api.replaceNamespacedStatefulSetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableAuthenticationApi } from "./ObservableAPI.js";
import { AuthenticationApiRequestFactory, AuthenticationApiResponseProcessor} from "../apis/AuthenticationApi.js";

export interface AuthenticationApiGetAPIGroupRequest {
}

export class ObjectAuthenticationApi {
    private api: ObservableAuthenticationApi

    public constructor(configuration: Configuration, requestFactory?: AuthenticationApiRequestFactory, responseProcessor?: AuthenticationApiResponseProcessor) {
        this.api = new ObservableAuthenticationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AuthenticationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AuthenticationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAuthenticationV1Api } from "./ObservableAPI.js";
import { AuthenticationV1ApiRequestFactory, AuthenticationV1ApiResponseProcessor} from "../apis/AuthenticationV1Api.js";

export interface AuthenticationV1ApiCreateSelfSubjectReviewRequest {
    /**
     * 
     * @type V1SelfSubjectReview
     * @memberof AuthenticationV1ApicreateSelfSubjectReview
     */
    body: V1SelfSubjectReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateSelfSubjectReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateSelfSubjectReview
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateSelfSubjectReview
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateSelfSubjectReview
     */
    pretty?: string
}

export interface AuthenticationV1ApiCreateTokenReviewRequest {
    /**
     * 
     * @type V1TokenReview
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    body: V1TokenReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AuthenticationV1ApicreateTokenReview
     */
    pretty?: string
}

export interface AuthenticationV1ApiGetAPIResourcesRequest {
}

export class ObjectAuthenticationV1Api {
    private api: ObservableAuthenticationV1Api

    public constructor(configuration: Configuration, requestFactory?: AuthenticationV1ApiRequestFactory, responseProcessor?: AuthenticationV1ApiResponseProcessor) {
        this.api = new ObservableAuthenticationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a SelfSubjectReview
     * @param param the request object
     */
    public createSelfSubjectReviewWithHttpInfo(param: AuthenticationV1ApiCreateSelfSubjectReviewRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1SelfSubjectReview>> {
        return this.api.createSelfSubjectReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectReview
     * @param param the request object
     */
    public createSelfSubjectReview(param: AuthenticationV1ApiCreateSelfSubjectReviewRequest, options?: ConfigurationOptions): Promise<V1SelfSubjectReview> {
        return this.api.createSelfSubjectReview(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a TokenReview
     * @param param the request object
     */
    public createTokenReviewWithHttpInfo(param: AuthenticationV1ApiCreateTokenReviewRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1TokenReview>> {
        return this.api.createTokenReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a TokenReview
     * @param param the request object
     */
    public createTokenReview(param: AuthenticationV1ApiCreateTokenReviewRequest, options?: ConfigurationOptions): Promise<V1TokenReview> {
        return this.api.createTokenReview(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AuthenticationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AuthenticationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

}

import { ObservableAuthorizationApi } from "./ObservableAPI.js";
import { AuthorizationApiRequestFactory, AuthorizationApiResponseProcessor} from "../apis/AuthorizationApi.js";

export interface AuthorizationApiGetAPIGroupRequest {
}

export class ObjectAuthorizationApi {
    private api: ObservableAuthorizationApi

    public constructor(configuration: Configuration, requestFactory?: AuthorizationApiRequestFactory, responseProcessor?: AuthorizationApiResponseProcessor) {
        this.api = new ObservableAuthorizationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AuthorizationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AuthorizationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAuthorizationV1Api } from "./ObservableAPI.js";
import { AuthorizationV1ApiRequestFactory, AuthorizationV1ApiResponseProcessor} from "../apis/AuthorizationV1Api.js";

export interface AuthorizationV1ApiCreateNamespacedLocalSubjectAccessReviewRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    namespace: string
    /**
     * 
     * @type V1LocalSubjectAccessReview
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    body: V1LocalSubjectAccessReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateNamespacedLocalSubjectAccessReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiCreateSelfSubjectAccessReviewRequest {
    /**
     * 
     * @type V1SelfSubjectAccessReview
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    body: V1SelfSubjectAccessReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectAccessReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiCreateSelfSubjectRulesReviewRequest {
    /**
     * 
     * @type V1SelfSubjectRulesReview
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    body: V1SelfSubjectRulesReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSelfSubjectRulesReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiCreateSubjectAccessReviewRequest {
    /**
     * 
     * @type V1SubjectAccessReview
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    body: V1SubjectAccessReview
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AuthorizationV1ApicreateSubjectAccessReview
     */
    pretty?: string
}

export interface AuthorizationV1ApiGetAPIResourcesRequest {
}

export class ObjectAuthorizationV1Api {
    private api: ObservableAuthorizationV1Api

    public constructor(configuration: Configuration, requestFactory?: AuthorizationV1ApiRequestFactory, responseProcessor?: AuthorizationV1ApiResponseProcessor) {
        this.api = new ObservableAuthorizationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a LocalSubjectAccessReview
     * @param param the request object
     */
    public createNamespacedLocalSubjectAccessReviewWithHttpInfo(param: AuthorizationV1ApiCreateNamespacedLocalSubjectAccessReviewRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1LocalSubjectAccessReview>> {
        return this.api.createNamespacedLocalSubjectAccessReviewWithHttpInfo(param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a LocalSubjectAccessReview
     * @param param the request object
     */
    public createNamespacedLocalSubjectAccessReview(param: AuthorizationV1ApiCreateNamespacedLocalSubjectAccessReviewRequest, options?: ConfigurationOptions): Promise<V1LocalSubjectAccessReview> {
        return this.api.createNamespacedLocalSubjectAccessReview(param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectAccessReview
     * @param param the request object
     */
    public createSelfSubjectAccessReviewWithHttpInfo(param: AuthorizationV1ApiCreateSelfSubjectAccessReviewRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1SelfSubjectAccessReview>> {
        return this.api.createSelfSubjectAccessReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectAccessReview
     * @param param the request object
     */
    public createSelfSubjectAccessReview(param: AuthorizationV1ApiCreateSelfSubjectAccessReviewRequest, options?: ConfigurationOptions): Promise<V1SelfSubjectAccessReview> {
        return this.api.createSelfSubjectAccessReview(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectRulesReview
     * @param param the request object
     */
    public createSelfSubjectRulesReviewWithHttpInfo(param: AuthorizationV1ApiCreateSelfSubjectRulesReviewRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1SelfSubjectRulesReview>> {
        return this.api.createSelfSubjectRulesReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a SelfSubjectRulesReview
     * @param param the request object
     */
    public createSelfSubjectRulesReview(param: AuthorizationV1ApiCreateSelfSubjectRulesReviewRequest, options?: ConfigurationOptions): Promise<V1SelfSubjectRulesReview> {
        return this.api.createSelfSubjectRulesReview(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a SubjectAccessReview
     * @param param the request object
     */
    public createSubjectAccessReviewWithHttpInfo(param: AuthorizationV1ApiCreateSubjectAccessReviewRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1SubjectAccessReview>> {
        return this.api.createSubjectAccessReviewWithHttpInfo(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a SubjectAccessReview
     * @param param the request object
     */
    public createSubjectAccessReview(param: AuthorizationV1ApiCreateSubjectAccessReviewRequest, options?: ConfigurationOptions): Promise<V1SubjectAccessReview> {
        return this.api.createSubjectAccessReview(param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AuthorizationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AuthorizationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

}

import { ObservableAutoscalingApi } from "./ObservableAPI.js";
import { AutoscalingApiRequestFactory, AutoscalingApiResponseProcessor} from "../apis/AutoscalingApi.js";

export interface AutoscalingApiGetAPIGroupRequest {
}

export class ObjectAutoscalingApi {
    private api: ObservableAutoscalingApi

    public constructor(configuration: Configuration, requestFactory?: AutoscalingApiRequestFactory, responseProcessor?: AutoscalingApiResponseProcessor) {
        this.api = new ObservableAutoscalingApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: AutoscalingApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: AutoscalingApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableAutoscalingV1Api } from "./ObservableAPI.js";
import { AutoscalingV1ApiRequestFactory, AutoscalingV1ApiResponseProcessor} from "../apis/AutoscalingV1Api.js";

export interface AutoscalingV1ApiCreateNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    body: V1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApicreateNamespacedHorizontalPodAutoscaler
     */
    fieldValidation?: string
}

export interface AutoscalingV1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV1ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV1ApiDeleteNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV1ApideleteNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV1ApiGetAPIResourcesRequest {
}

export interface AutoscalingV1ApiListHorizontalPodAutoscalerForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    watch?: boolean
}

export interface AutoscalingV1ApiListNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApilistNamespacedHorizontalPodAutoscaler
     */
    watch?: boolean
}

export interface AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscaler
     */
    force?: boolean
}

export interface AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV1ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    force?: boolean
}

export interface AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
}

export interface AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
}

export interface AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    body: V1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscaler
     */
    fieldValidation?: string
}

export interface AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type V1HorizontalPodAutoscaler
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    body: V1HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV1ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    fieldValidation?: string
}

export class ObjectAutoscalingV1Api {
    private api: ObservableAutoscalingV1Api

    public constructor(configuration: Configuration, requestFactory?: AutoscalingV1ApiRequestFactory, responseProcessor?: AutoscalingV1ApiResponseProcessor) {
        this.api = new ObservableAutoscalingV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.createNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscaler> {
        return this.api.createNamespacedHorizontalPodAutoscaler(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AutoscalingV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AutoscalingV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param: AutoscalingV1ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscalerList>> {
        return this.api.listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespaces(param: AutoscalingV1ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscalerList> {
        return this.api.listHorizontalPodAutoscalerForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiListNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscalerList>> {
        return this.api.listNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiListNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscalerList> {
        return this.api.listNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV1ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV1ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscaler(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV1ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<V1HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableAutoscalingV2Api } from "./ObservableAPI.js";
import { AutoscalingV2ApiRequestFactory, AutoscalingV2ApiResponseProcessor} from "../apis/AutoscalingV2Api.js";

export interface AutoscalingV2ApiCreateNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApicreateNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V2HorizontalPodAutoscaler
     * @memberof AutoscalingV2ApicreateNamespacedHorizontalPodAutoscaler
     */
    body: V2HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApicreateNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApicreateNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApicreateNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApicreateNamespacedHorizontalPodAutoscaler
     */
    fieldValidation?: string
}

export interface AutoscalingV2ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV2ApideleteCollectionNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV2ApiDeleteNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof AutoscalingV2ApideleteNamespacedHorizontalPodAutoscaler
     */
    body?: V1DeleteOptions
}

export interface AutoscalingV2ApiGetAPIResourcesRequest {
}

export interface AutoscalingV2ApiListHorizontalPodAutoscalerForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApilistHorizontalPodAutoscalerForAllNamespaces
     */
    watch?: boolean
}

export interface AutoscalingV2ApiListNamespacedHorizontalPodAutoscalerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApilistNamespacedHorizontalPodAutoscaler
     */
    watch?: boolean
}

export interface AutoscalingV2ApiPatchNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscaler
     */
    force?: boolean
}

export interface AutoscalingV2ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof AutoscalingV2ApipatchNamespacedHorizontalPodAutoscalerStatus
     */
    force?: boolean
}

export interface AutoscalingV2ApiReadNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireadNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireadNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireadNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
}

export interface AutoscalingV2ApiReadNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireadNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
}

export interface AutoscalingV2ApiReplaceNamespacedHorizontalPodAutoscalerRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    namespace: string
    /**
     * 
     * @type V2HorizontalPodAutoscaler
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    body: V2HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscaler
     */
    fieldValidation?: string
}

export interface AutoscalingV2ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest {
    /**
     * name of the HorizontalPodAutoscaler
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    namespace: string
    /**
     * 
     * @type V2HorizontalPodAutoscaler
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    body: V2HorizontalPodAutoscaler
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof AutoscalingV2ApireplaceNamespacedHorizontalPodAutoscalerStatus
     */
    fieldValidation?: string
}

export class ObjectAutoscalingV2Api {
    private api: ObservableAutoscalingV2Api

    public constructor(configuration: Configuration, requestFactory?: AutoscalingV2ApiRequestFactory, responseProcessor?: AutoscalingV2ApiResponseProcessor) {
        this.api = new ObservableAutoscalingV2Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscaler>> {
        return this.api.createNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a HorizontalPodAutoscaler
     * @param param the request object
     */
    public createNamespacedHorizontalPodAutoscaler(param: AutoscalingV2ApiCreateNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscaler> {
        return this.api.createNamespacedHorizontalPodAutoscaler(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteCollectionNamespacedHorizontalPodAutoscaler(param: AutoscalingV2ApiDeleteCollectionNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a HorizontalPodAutoscaler
     * @param param the request object
     */
    public deleteNamespacedHorizontalPodAutoscaler(param: AutoscalingV2ApiDeleteNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: AutoscalingV2ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: AutoscalingV2ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param: AutoscalingV2ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscalerList>> {
        return this.api.listHorizontalPodAutoscalerForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listHorizontalPodAutoscalerForAllNamespaces(param: AutoscalingV2ApiListHorizontalPodAutoscalerForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscalerList> {
        return this.api.listHorizontalPodAutoscalerForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2ApiListNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscalerList>> {
        return this.api.listNamespacedHorizontalPodAutoscalerWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind HorizontalPodAutoscaler
     * @param param the request object
     */
    public listNamespacedHorizontalPodAutoscaler(param: AutoscalingV2ApiListNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscalerList> {
        return this.api.listNamespacedHorizontalPodAutoscaler(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscaler(param: AutoscalingV2ApiPatchNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscaler>> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public patchNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2ApiPatchNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscaler> {
        return this.api.patchNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscaler(param: AutoscalingV2ApiReadNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscaler>> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public readNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2ApiReadNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscaler> {
        return this.api.readNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param: AutoscalingV2ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscaler(param: AutoscalingV2ApiReplaceNamespacedHorizontalPodAutoscalerRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscaler(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param: AutoscalingV2ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V2HorizontalPodAutoscaler>> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified HorizontalPodAutoscaler
     * @param param the request object
     */
    public replaceNamespacedHorizontalPodAutoscalerStatus(param: AutoscalingV2ApiReplaceNamespacedHorizontalPodAutoscalerStatusRequest, options?: ConfigurationOptions): Promise<V2HorizontalPodAutoscaler> {
        return this.api.replaceNamespacedHorizontalPodAutoscalerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableBatchApi } from "./ObservableAPI.js";
import { BatchApiRequestFactory, BatchApiResponseProcessor} from "../apis/BatchApi.js";

export interface BatchApiGetAPIGroupRequest {
}

export class ObjectBatchApi {
    private api: ObservableBatchApi

    public constructor(configuration: Configuration, requestFactory?: BatchApiRequestFactory, responseProcessor?: BatchApiResponseProcessor) {
        this.api = new ObservableBatchApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: BatchApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: BatchApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableBatchV1Api } from "./ObservableAPI.js";
import { BatchV1ApiRequestFactory, BatchV1ApiResponseProcessor} from "../apis/BatchV1Api.js";

export interface BatchV1ApiCreateNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type V1CronJob
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    body: V1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedCronJob
     */
    fieldValidation?: string
}

export interface BatchV1ApiCreateNamespacedJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    namespace: string
    /**
     * 
     * @type V1Job
     * @memberof BatchV1ApicreateNamespacedJob
     */
    body: V1Job
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApicreateNamespacedJob
     */
    fieldValidation?: string
}

export interface BatchV1ApiDeleteCollectionNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteCollectionNamespacedCronJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiDeleteCollectionNamespacedJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteCollectionNamespacedJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiDeleteNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteNamespacedCronJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiDeleteNamespacedJobRequest {
    /**
     * name of the Job
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApideleteNamespacedJob
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteNamespacedJob
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApideleteNamespacedJob
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApideleteNamespacedJob
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof BatchV1ApideleteNamespacedJob
     */
    body?: V1DeleteOptions
}

export interface BatchV1ApiGetAPIResourcesRequest {
}

export interface BatchV1ApiListCronJobForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistCronJobForAllNamespaces
     */
    watch?: boolean
}

export interface BatchV1ApiListJobForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistJobForAllNamespaces
     */
    watch?: boolean
}

export interface BatchV1ApiListNamespacedCronJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistNamespacedCronJob
     */
    watch?: boolean
}

export interface BatchV1ApiListNamespacedJobRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistNamespacedJob
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistNamespacedJob
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApilistNamespacedJob
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistNamespacedJob
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof BatchV1ApilistNamespacedJob
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApilistNamespacedJob
     */
    watch?: boolean
}

export interface BatchV1ApiPatchNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedCronJob
     */
    force?: boolean
}

export interface BatchV1ApiPatchNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedCronJobStatus
     */
    force?: boolean
}

export interface BatchV1ApiPatchNamespacedJobRequest {
    /**
     * name of the Job
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedJob
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJob
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedJob
     */
    force?: boolean
}

export interface BatchV1ApiPatchNamespacedJobStatusRequest {
    /**
     * name of the Job
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof BatchV1ApipatchNamespacedJobStatus
     */
    force?: boolean
}

export interface BatchV1ApiReadNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJob
     */
    pretty?: string
}

export interface BatchV1ApiReadNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJobStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedCronJobStatus
     */
    pretty?: string
}

export interface BatchV1ApiReadNamespacedJobRequest {
    /**
     * name of the Job
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedJob
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedJob
     */
    pretty?: string
}

export interface BatchV1ApiReadNamespacedJobStatusRequest {
    /**
     * name of the Job
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedJobStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireadNamespacedJobStatus
     */
    pretty?: string
}

export interface BatchV1ApiReplaceNamespacedCronJobRequest {
    /**
     * name of the CronJob
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    namespace: string
    /**
     * 
     * @type V1CronJob
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    body: V1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJob
     */
    fieldValidation?: string
}

export interface BatchV1ApiReplaceNamespacedCronJobStatusRequest {
    /**
     * name of the CronJob
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    namespace: string
    /**
     * 
     * @type V1CronJob
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    body: V1CronJob
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedCronJobStatus
     */
    fieldValidation?: string
}

export interface BatchV1ApiReplaceNamespacedJobRequest {
    /**
     * name of the Job
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    namespace: string
    /**
     * 
     * @type V1Job
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    body: V1Job
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJob
     */
    fieldValidation?: string
}

export interface BatchV1ApiReplaceNamespacedJobStatusRequest {
    /**
     * name of the Job
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    namespace: string
    /**
     * 
     * @type V1Job
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    body: V1Job
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof BatchV1ApireplaceNamespacedJobStatus
     */
    fieldValidation?: string
}

export class ObjectBatchV1Api {
    private api: ObservableBatchV1Api

    public constructor(configuration: Configuration, requestFactory?: BatchV1ApiRequestFactory, responseProcessor?: BatchV1ApiResponseProcessor) {
        this.api = new ObservableBatchV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CronJob
     * @param param the request object
     */
    public createNamespacedCronJobWithHttpInfo(param: BatchV1ApiCreateNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJob>> {
        return this.api.createNamespacedCronJobWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CronJob
     * @param param the request object
     */
    public createNamespacedCronJob(param: BatchV1ApiCreateNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<V1CronJob> {
        return this.api.createNamespacedCronJob(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Job
     * @param param the request object
     */
    public createNamespacedJobWithHttpInfo(param: BatchV1ApiCreateNamespacedJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Job>> {
        return this.api.createNamespacedJobWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Job
     * @param param the request object
     */
    public createNamespacedJob(param: BatchV1ApiCreateNamespacedJobRequest, options?: ConfigurationOptions): Promise<V1Job> {
        return this.api.createNamespacedJob(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of CronJob
     * @param param the request object
     */
    public deleteCollectionNamespacedCronJobWithHttpInfo(param: BatchV1ApiDeleteCollectionNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedCronJobWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CronJob
     * @param param the request object
     */
    public deleteCollectionNamespacedCronJob(param: BatchV1ApiDeleteCollectionNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedCronJob(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Job
     * @param param the request object
     */
    public deleteCollectionNamespacedJobWithHttpInfo(param: BatchV1ApiDeleteCollectionNamespacedJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedJobWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Job
     * @param param the request object
     */
    public deleteCollectionNamespacedJob(param: BatchV1ApiDeleteCollectionNamespacedJobRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedJob(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CronJob
     * @param param the request object
     */
    public deleteNamespacedCronJobWithHttpInfo(param: BatchV1ApiDeleteNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CronJob
     * @param param the request object
     */
    public deleteNamespacedCronJob(param: BatchV1ApiDeleteNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedCronJob(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Job
     * @param param the request object
     */
    public deleteNamespacedJobWithHttpInfo(param: BatchV1ApiDeleteNamespacedJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedJobWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Job
     * @param param the request object
     */
    public deleteNamespacedJob(param: BatchV1ApiDeleteNamespacedJobRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedJob(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: BatchV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: BatchV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listCronJobForAllNamespacesWithHttpInfo(param: BatchV1ApiListCronJobForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJobList>> {
        return this.api.listCronJobForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listCronJobForAllNamespaces(param: BatchV1ApiListCronJobForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1CronJobList> {
        return this.api.listCronJobForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listJobForAllNamespacesWithHttpInfo(param: BatchV1ApiListJobForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1JobList>> {
        return this.api.listJobForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listJobForAllNamespaces(param: BatchV1ApiListJobForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1JobList> {
        return this.api.listJobForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listNamespacedCronJobWithHttpInfo(param: BatchV1ApiListNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJobList>> {
        return this.api.listNamespacedCronJobWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CronJob
     * @param param the request object
     */
    public listNamespacedCronJob(param: BatchV1ApiListNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<V1CronJobList> {
        return this.api.listNamespacedCronJob(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listNamespacedJobWithHttpInfo(param: BatchV1ApiListNamespacedJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1JobList>> {
        return this.api.listNamespacedJobWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Job
     * @param param the request object
     */
    public listNamespacedJob(param: BatchV1ApiListNamespacedJobRequest, options?: ConfigurationOptions): Promise<V1JobList> {
        return this.api.listNamespacedJob(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobWithHttpInfo(param: BatchV1ApiPatchNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJob>> {
        return this.api.patchNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJob(param: BatchV1ApiPatchNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<V1CronJob> {
        return this.api.patchNamespacedCronJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobStatusWithHttpInfo(param: BatchV1ApiPatchNamespacedCronJobStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJob>> {
        return this.api.patchNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CronJob
     * @param param the request object
     */
    public patchNamespacedCronJobStatus(param: BatchV1ApiPatchNamespacedCronJobStatusRequest, options?: ConfigurationOptions): Promise<V1CronJob> {
        return this.api.patchNamespacedCronJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Job
     * @param param the request object
     */
    public patchNamespacedJobWithHttpInfo(param: BatchV1ApiPatchNamespacedJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Job>> {
        return this.api.patchNamespacedJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Job
     * @param param the request object
     */
    public patchNamespacedJob(param: BatchV1ApiPatchNamespacedJobRequest, options?: ConfigurationOptions): Promise<V1Job> {
        return this.api.patchNamespacedJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Job
     * @param param the request object
     */
    public patchNamespacedJobStatusWithHttpInfo(param: BatchV1ApiPatchNamespacedJobStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Job>> {
        return this.api.patchNamespacedJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Job
     * @param param the request object
     */
    public patchNamespacedJobStatus(param: BatchV1ApiPatchNamespacedJobStatusRequest, options?: ConfigurationOptions): Promise<V1Job> {
        return this.api.patchNamespacedJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobWithHttpInfo(param: BatchV1ApiReadNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJob>> {
        return this.api.readNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJob(param: BatchV1ApiReadNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<V1CronJob> {
        return this.api.readNamespacedCronJob(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobStatusWithHttpInfo(param: BatchV1ApiReadNamespacedCronJobStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJob>> {
        return this.api.readNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CronJob
     * @param param the request object
     */
    public readNamespacedCronJobStatus(param: BatchV1ApiReadNamespacedCronJobStatusRequest, options?: ConfigurationOptions): Promise<V1CronJob> {
        return this.api.readNamespacedCronJobStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Job
     * @param param the request object
     */
    public readNamespacedJobWithHttpInfo(param: BatchV1ApiReadNamespacedJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Job>> {
        return this.api.readNamespacedJobWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Job
     * @param param the request object
     */
    public readNamespacedJob(param: BatchV1ApiReadNamespacedJobRequest, options?: ConfigurationOptions): Promise<V1Job> {
        return this.api.readNamespacedJob(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Job
     * @param param the request object
     */
    public readNamespacedJobStatusWithHttpInfo(param: BatchV1ApiReadNamespacedJobStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Job>> {
        return this.api.readNamespacedJobStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Job
     * @param param the request object
     */
    public readNamespacedJobStatus(param: BatchV1ApiReadNamespacedJobStatusRequest, options?: ConfigurationOptions): Promise<V1Job> {
        return this.api.readNamespacedJobStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobWithHttpInfo(param: BatchV1ApiReplaceNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJob>> {
        return this.api.replaceNamespacedCronJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJob(param: BatchV1ApiReplaceNamespacedCronJobRequest, options?: ConfigurationOptions): Promise<V1CronJob> {
        return this.api.replaceNamespacedCronJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobStatusWithHttpInfo(param: BatchV1ApiReplaceNamespacedCronJobStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CronJob>> {
        return this.api.replaceNamespacedCronJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified CronJob
     * @param param the request object
     */
    public replaceNamespacedCronJobStatus(param: BatchV1ApiReplaceNamespacedCronJobStatusRequest, options?: ConfigurationOptions): Promise<V1CronJob> {
        return this.api.replaceNamespacedCronJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Job
     * @param param the request object
     */
    public replaceNamespacedJobWithHttpInfo(param: BatchV1ApiReplaceNamespacedJobRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Job>> {
        return this.api.replaceNamespacedJobWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Job
     * @param param the request object
     */
    public replaceNamespacedJob(param: BatchV1ApiReplaceNamespacedJobRequest, options?: ConfigurationOptions): Promise<V1Job> {
        return this.api.replaceNamespacedJob(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Job
     * @param param the request object
     */
    public replaceNamespacedJobStatusWithHttpInfo(param: BatchV1ApiReplaceNamespacedJobStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Job>> {
        return this.api.replaceNamespacedJobStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Job
     * @param param the request object
     */
    public replaceNamespacedJobStatus(param: BatchV1ApiReplaceNamespacedJobStatusRequest, options?: ConfigurationOptions): Promise<V1Job> {
        return this.api.replaceNamespacedJobStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCertificatesApi } from "./ObservableAPI.js";
import { CertificatesApiRequestFactory, CertificatesApiResponseProcessor} from "../apis/CertificatesApi.js";

export interface CertificatesApiGetAPIGroupRequest {
}

export class ObjectCertificatesApi {
    private api: ObservableCertificatesApi

    public constructor(configuration: Configuration, requestFactory?: CertificatesApiRequestFactory, responseProcessor?: CertificatesApiResponseProcessor) {
        this.api = new ObservableCertificatesApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: CertificatesApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: CertificatesApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableCertificatesV1Api } from "./ObservableAPI.js";
import { CertificatesV1ApiRequestFactory, CertificatesV1ApiResponseProcessor} from "../apis/CertificatesV1Api.js";

export interface CertificatesV1ApiCreateCertificateSigningRequestRequest {
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApicreateCertificateSigningRequest
     */
    fieldValidation?: string
}

export interface CertificatesV1ApiDeleteCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1ApideleteCertificateSigningRequest
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1ApiDeleteCollectionCertificateSigningRequestRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1ApideleteCollectionCertificateSigningRequest
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1ApiGetAPIResourcesRequest {
}

export interface CertificatesV1ApiListCertificateSigningRequestRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApilistCertificateSigningRequest
     */
    watch?: boolean
}

export interface CertificatesV1ApiPatchCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificateSigningRequest
     */
    force?: boolean
}

export interface CertificatesV1ApiPatchCertificateSigningRequestApprovalRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificateSigningRequestApproval
     */
    force?: boolean
}

export interface CertificatesV1ApiPatchCertificateSigningRequestStatusRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1ApipatchCertificateSigningRequestStatus
     */
    force?: boolean
}

export interface CertificatesV1ApiReadCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequest
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequest
     */
    pretty?: string
}

export interface CertificatesV1ApiReadCertificateSigningRequestApprovalRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestApproval
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestApproval
     */
    pretty?: string
}

export interface CertificatesV1ApiReadCertificateSigningRequestStatusRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireadCertificateSigningRequestStatus
     */
    pretty?: string
}

export interface CertificatesV1ApiReplaceCertificateSigningRequestRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    name: string
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequest
     */
    fieldValidation?: string
}

export interface CertificatesV1ApiReplaceCertificateSigningRequestApprovalRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    name: string
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestApproval
     */
    fieldValidation?: string
}

export interface CertificatesV1ApiReplaceCertificateSigningRequestStatusRequest {
    /**
     * name of the CertificateSigningRequest
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    name: string
    /**
     * 
     * @type V1CertificateSigningRequest
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    body: V1CertificateSigningRequest
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1ApireplaceCertificateSigningRequestStatus
     */
    fieldValidation?: string
}

export class ObjectCertificatesV1Api {
    private api: ObservableCertificatesV1Api

    public constructor(configuration: Configuration, requestFactory?: CertificatesV1ApiRequestFactory, responseProcessor?: CertificatesV1ApiResponseProcessor) {
        this.api = new ObservableCertificatesV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CertificateSigningRequest
     * @param param the request object
     */
    public createCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiCreateCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.createCertificateSigningRequestWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CertificateSigningRequest
     * @param param the request object
     */
    public createCertificateSigningRequest(param: CertificatesV1ApiCreateCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.createCertificateSigningRequest(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete a CertificateSigningRequest
     * @param param the request object
     */
    public deleteCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiDeleteCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCertificateSigningRequestWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CertificateSigningRequest
     * @param param the request object
     */
    public deleteCertificateSigningRequest(param: CertificatesV1ApiDeleteCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCertificateSigningRequest(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of CertificateSigningRequest
     * @param param the request object
     */
    public deleteCollectionCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiDeleteCollectionCertificateSigningRequestRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCertificateSigningRequestWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CertificateSigningRequest
     * @param param the request object
     */
    public deleteCollectionCertificateSigningRequest(param: CertificatesV1ApiDeleteCollectionCertificateSigningRequestRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionCertificateSigningRequest(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CertificatesV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CertificatesV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CertificateSigningRequest
     * @param param the request object
     */
    public listCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiListCertificateSigningRequestRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequestList>> {
        return this.api.listCertificateSigningRequestWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CertificateSigningRequest
     * @param param the request object
     */
    public listCertificateSigningRequest(param: CertificatesV1ApiListCertificateSigningRequestRequest = {}, options?: ConfigurationOptions): Promise<V1CertificateSigningRequestList> {
        return this.api.listCertificateSigningRequest(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiPatchCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.patchCertificateSigningRequestWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequest(param: CertificatesV1ApiPatchCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.patchCertificateSigningRequest(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestApprovalWithHttpInfo(param: CertificatesV1ApiPatchCertificateSigningRequestApprovalRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.patchCertificateSigningRequestApprovalWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestApproval(param: CertificatesV1ApiPatchCertificateSigningRequestApprovalRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.patchCertificateSigningRequestApproval(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestStatusWithHttpInfo(param: CertificatesV1ApiPatchCertificateSigningRequestStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.patchCertificateSigningRequestStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public patchCertificateSigningRequestStatus(param: CertificatesV1ApiPatchCertificateSigningRequestStatusRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.patchCertificateSigningRequestStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiReadCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.readCertificateSigningRequestWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequest(param: CertificatesV1ApiReadCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.readCertificateSigningRequest(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestApprovalWithHttpInfo(param: CertificatesV1ApiReadCertificateSigningRequestApprovalRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.readCertificateSigningRequestApprovalWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestApproval(param: CertificatesV1ApiReadCertificateSigningRequestApprovalRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.readCertificateSigningRequestApproval(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestStatusWithHttpInfo(param: CertificatesV1ApiReadCertificateSigningRequestStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.readCertificateSigningRequestStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public readCertificateSigningRequestStatus(param: CertificatesV1ApiReadCertificateSigningRequestStatusRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.readCertificateSigningRequestStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestWithHttpInfo(param: CertificatesV1ApiReplaceCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.replaceCertificateSigningRequestWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequest(param: CertificatesV1ApiReplaceCertificateSigningRequestRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.replaceCertificateSigningRequest(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestApprovalWithHttpInfo(param: CertificatesV1ApiReplaceCertificateSigningRequestApprovalRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.replaceCertificateSigningRequestApprovalWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace approval of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestApproval(param: CertificatesV1ApiReplaceCertificateSigningRequestApprovalRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.replaceCertificateSigningRequestApproval(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestStatusWithHttpInfo(param: CertificatesV1ApiReplaceCertificateSigningRequestStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CertificateSigningRequest>> {
        return this.api.replaceCertificateSigningRequestStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified CertificateSigningRequest
     * @param param the request object
     */
    public replaceCertificateSigningRequestStatus(param: CertificatesV1ApiReplaceCertificateSigningRequestStatusRequest, options?: ConfigurationOptions): Promise<V1CertificateSigningRequest> {
        return this.api.replaceCertificateSigningRequestStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCertificatesV1alpha1Api } from "./ObservableAPI.js";
import { CertificatesV1alpha1ApiRequestFactory, CertificatesV1alpha1ApiResponseProcessor} from "../apis/CertificatesV1alpha1Api.js";

export interface CertificatesV1alpha1ApiCreateClusterTrustBundleRequest {
    /**
     * 
     * @type V1alpha1ClusterTrustBundle
     * @memberof CertificatesV1alpha1ApicreateClusterTrustBundle
     */
    body: V1alpha1ClusterTrustBundle
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApicreateClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApicreateClusterTrustBundle
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApicreateClusterTrustBundle
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApicreateClusterTrustBundle
     */
    fieldValidation?: string
}

export interface CertificatesV1alpha1ApiDeleteClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1alpha1ApideleteClusterTrustBundle
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1alpha1ApiDeleteCollectionClusterTrustBundleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1alpha1ApideleteCollectionClusterTrustBundle
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1alpha1ApiGetAPIResourcesRequest {
}

export interface CertificatesV1alpha1ApiListClusterTrustBundleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApilistClusterTrustBundle
     */
    watch?: boolean
}

export interface CertificatesV1alpha1ApiPatchClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApipatchClusterTrustBundle
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1alpha1ApipatchClusterTrustBundle
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApipatchClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApipatchClusterTrustBundle
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApipatchClusterTrustBundle
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApipatchClusterTrustBundle
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1alpha1ApipatchClusterTrustBundle
     */
    force?: boolean
}

export interface CertificatesV1alpha1ApiReadClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApireadClusterTrustBundle
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApireadClusterTrustBundle
     */
    pretty?: string
}

export interface CertificatesV1alpha1ApiReplaceClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApireplaceClusterTrustBundle
     */
    name: string
    /**
     * 
     * @type V1alpha1ClusterTrustBundle
     * @memberof CertificatesV1alpha1ApireplaceClusterTrustBundle
     */
    body: V1alpha1ClusterTrustBundle
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApireplaceClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApireplaceClusterTrustBundle
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApireplaceClusterTrustBundle
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1alpha1ApireplaceClusterTrustBundle
     */
    fieldValidation?: string
}

export class ObjectCertificatesV1alpha1Api {
    private api: ObservableCertificatesV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: CertificatesV1alpha1ApiRequestFactory, responseProcessor?: CertificatesV1alpha1ApiResponseProcessor) {
        this.api = new ObservableCertificatesV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ClusterTrustBundle
     * @param param the request object
     */
    public createClusterTrustBundleWithHttpInfo(param: CertificatesV1alpha1ApiCreateClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1ClusterTrustBundle>> {
        return this.api.createClusterTrustBundleWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ClusterTrustBundle
     * @param param the request object
     */
    public createClusterTrustBundle(param: CertificatesV1alpha1ApiCreateClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1alpha1ClusterTrustBundle> {
        return this.api.createClusterTrustBundle(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete a ClusterTrustBundle
     * @param param the request object
     */
    public deleteClusterTrustBundleWithHttpInfo(param: CertificatesV1alpha1ApiDeleteClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterTrustBundleWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterTrustBundle
     * @param param the request object
     */
    public deleteClusterTrustBundle(param: CertificatesV1alpha1ApiDeleteClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteClusterTrustBundle(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterTrustBundle
     * @param param the request object
     */
    public deleteCollectionClusterTrustBundleWithHttpInfo(param: CertificatesV1alpha1ApiDeleteCollectionClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterTrustBundleWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterTrustBundle
     * @param param the request object
     */
    public deleteCollectionClusterTrustBundle(param: CertificatesV1alpha1ApiDeleteCollectionClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionClusterTrustBundle(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CertificatesV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CertificatesV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterTrustBundle
     * @param param the request object
     */
    public listClusterTrustBundleWithHttpInfo(param: CertificatesV1alpha1ApiListClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1ClusterTrustBundleList>> {
        return this.api.listClusterTrustBundleWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterTrustBundle
     * @param param the request object
     */
    public listClusterTrustBundle(param: CertificatesV1alpha1ApiListClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<V1alpha1ClusterTrustBundleList> {
        return this.api.listClusterTrustBundle(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ClusterTrustBundle
     * @param param the request object
     */
    public patchClusterTrustBundleWithHttpInfo(param: CertificatesV1alpha1ApiPatchClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1ClusterTrustBundle>> {
        return this.api.patchClusterTrustBundleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterTrustBundle
     * @param param the request object
     */
    public patchClusterTrustBundle(param: CertificatesV1alpha1ApiPatchClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1alpha1ClusterTrustBundle> {
        return this.api.patchClusterTrustBundle(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified ClusterTrustBundle
     * @param param the request object
     */
    public readClusterTrustBundleWithHttpInfo(param: CertificatesV1alpha1ApiReadClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1ClusterTrustBundle>> {
        return this.api.readClusterTrustBundleWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterTrustBundle
     * @param param the request object
     */
    public readClusterTrustBundle(param: CertificatesV1alpha1ApiReadClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1alpha1ClusterTrustBundle> {
        return this.api.readClusterTrustBundle(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ClusterTrustBundle
     * @param param the request object
     */
    public replaceClusterTrustBundleWithHttpInfo(param: CertificatesV1alpha1ApiReplaceClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1ClusterTrustBundle>> {
        return this.api.replaceClusterTrustBundleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ClusterTrustBundle
     * @param param the request object
     */
    public replaceClusterTrustBundle(param: CertificatesV1alpha1ApiReplaceClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1alpha1ClusterTrustBundle> {
        return this.api.replaceClusterTrustBundle(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCertificatesV1beta1Api } from "./ObservableAPI.js";
import { CertificatesV1beta1ApiRequestFactory, CertificatesV1beta1ApiResponseProcessor} from "../apis/CertificatesV1beta1Api.js";

export interface CertificatesV1beta1ApiCreateClusterTrustBundleRequest {
    /**
     * 
     * @type V1beta1ClusterTrustBundle
     * @memberof CertificatesV1beta1ApicreateClusterTrustBundle
     */
    body: V1beta1ClusterTrustBundle
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApicreateClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApicreateClusterTrustBundle
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApicreateClusterTrustBundle
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApicreateClusterTrustBundle
     */
    fieldValidation?: string
}

export interface CertificatesV1beta1ApiDeleteClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1beta1ApideleteClusterTrustBundle
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1beta1ApiDeleteCollectionClusterTrustBundleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CertificatesV1beta1ApideleteCollectionClusterTrustBundle
     */
    body?: V1DeleteOptions
}

export interface CertificatesV1beta1ApiGetAPIResourcesRequest {
}

export interface CertificatesV1beta1ApiListClusterTrustBundleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApilistClusterTrustBundle
     */
    watch?: boolean
}

export interface CertificatesV1beta1ApiPatchClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApipatchClusterTrustBundle
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CertificatesV1beta1ApipatchClusterTrustBundle
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApipatchClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApipatchClusterTrustBundle
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApipatchClusterTrustBundle
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApipatchClusterTrustBundle
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CertificatesV1beta1ApipatchClusterTrustBundle
     */
    force?: boolean
}

export interface CertificatesV1beta1ApiReadClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApireadClusterTrustBundle
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApireadClusterTrustBundle
     */
    pretty?: string
}

export interface CertificatesV1beta1ApiReplaceClusterTrustBundleRequest {
    /**
     * name of the ClusterTrustBundle
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApireplaceClusterTrustBundle
     */
    name: string
    /**
     * 
     * @type V1beta1ClusterTrustBundle
     * @memberof CertificatesV1beta1ApireplaceClusterTrustBundle
     */
    body: V1beta1ClusterTrustBundle
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApireplaceClusterTrustBundle
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApireplaceClusterTrustBundle
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApireplaceClusterTrustBundle
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CertificatesV1beta1ApireplaceClusterTrustBundle
     */
    fieldValidation?: string
}

export class ObjectCertificatesV1beta1Api {
    private api: ObservableCertificatesV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: CertificatesV1beta1ApiRequestFactory, responseProcessor?: CertificatesV1beta1ApiResponseProcessor) {
        this.api = new ObservableCertificatesV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ClusterTrustBundle
     * @param param the request object
     */
    public createClusterTrustBundleWithHttpInfo(param: CertificatesV1beta1ApiCreateClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ClusterTrustBundle>> {
        return this.api.createClusterTrustBundleWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ClusterTrustBundle
     * @param param the request object
     */
    public createClusterTrustBundle(param: CertificatesV1beta1ApiCreateClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1beta1ClusterTrustBundle> {
        return this.api.createClusterTrustBundle(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete a ClusterTrustBundle
     * @param param the request object
     */
    public deleteClusterTrustBundleWithHttpInfo(param: CertificatesV1beta1ApiDeleteClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterTrustBundleWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterTrustBundle
     * @param param the request object
     */
    public deleteClusterTrustBundle(param: CertificatesV1beta1ApiDeleteClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteClusterTrustBundle(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterTrustBundle
     * @param param the request object
     */
    public deleteCollectionClusterTrustBundleWithHttpInfo(param: CertificatesV1beta1ApiDeleteCollectionClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterTrustBundleWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterTrustBundle
     * @param param the request object
     */
    public deleteCollectionClusterTrustBundle(param: CertificatesV1beta1ApiDeleteCollectionClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionClusterTrustBundle(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CertificatesV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CertificatesV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterTrustBundle
     * @param param the request object
     */
    public listClusterTrustBundleWithHttpInfo(param: CertificatesV1beta1ApiListClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ClusterTrustBundleList>> {
        return this.api.listClusterTrustBundleWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterTrustBundle
     * @param param the request object
     */
    public listClusterTrustBundle(param: CertificatesV1beta1ApiListClusterTrustBundleRequest = {}, options?: ConfigurationOptions): Promise<V1beta1ClusterTrustBundleList> {
        return this.api.listClusterTrustBundle(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ClusterTrustBundle
     * @param param the request object
     */
    public patchClusterTrustBundleWithHttpInfo(param: CertificatesV1beta1ApiPatchClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ClusterTrustBundle>> {
        return this.api.patchClusterTrustBundleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterTrustBundle
     * @param param the request object
     */
    public patchClusterTrustBundle(param: CertificatesV1beta1ApiPatchClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1beta1ClusterTrustBundle> {
        return this.api.patchClusterTrustBundle(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified ClusterTrustBundle
     * @param param the request object
     */
    public readClusterTrustBundleWithHttpInfo(param: CertificatesV1beta1ApiReadClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ClusterTrustBundle>> {
        return this.api.readClusterTrustBundleWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterTrustBundle
     * @param param the request object
     */
    public readClusterTrustBundle(param: CertificatesV1beta1ApiReadClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1beta1ClusterTrustBundle> {
        return this.api.readClusterTrustBundle(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ClusterTrustBundle
     * @param param the request object
     */
    public replaceClusterTrustBundleWithHttpInfo(param: CertificatesV1beta1ApiReplaceClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ClusterTrustBundle>> {
        return this.api.replaceClusterTrustBundleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ClusterTrustBundle
     * @param param the request object
     */
    public replaceClusterTrustBundle(param: CertificatesV1beta1ApiReplaceClusterTrustBundleRequest, options?: ConfigurationOptions): Promise<V1beta1ClusterTrustBundle> {
        return this.api.replaceClusterTrustBundle(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCoordinationApi } from "./ObservableAPI.js";
import { CoordinationApiRequestFactory, CoordinationApiResponseProcessor} from "../apis/CoordinationApi.js";

export interface CoordinationApiGetAPIGroupRequest {
}

export class ObjectCoordinationApi {
    private api: ObservableCoordinationApi

    public constructor(configuration: Configuration, requestFactory?: CoordinationApiRequestFactory, responseProcessor?: CoordinationApiResponseProcessor) {
        this.api = new ObservableCoordinationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: CoordinationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: CoordinationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableCoordinationV1Api } from "./ObservableAPI.js";
import { CoordinationV1ApiRequestFactory, CoordinationV1ApiResponseProcessor} from "../apis/CoordinationV1Api.js";

export interface CoordinationV1ApiCreateNamespacedLeaseRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    namespace: string
    /**
     * 
     * @type V1Lease
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    body: V1Lease
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApicreateNamespacedLease
     */
    fieldValidation?: string
}

export interface CoordinationV1ApiDeleteCollectionNamespacedLeaseRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1ApideleteCollectionNamespacedLease
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1ApiDeleteNamespacedLeaseRequest {
    /**
     * name of the Lease
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1ApideleteNamespacedLease
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1ApiGetAPIResourcesRequest {
}

export interface CoordinationV1ApiListLeaseForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApilistLeaseForAllNamespaces
     */
    watch?: boolean
}

export interface CoordinationV1ApiListNamespacedLeaseRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApilistNamespacedLease
     */
    watch?: boolean
}

export interface CoordinationV1ApiPatchNamespacedLeaseRequest {
    /**
     * name of the Lease
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1ApipatchNamespacedLease
     */
    force?: boolean
}

export interface CoordinationV1ApiReadNamespacedLeaseRequest {
    /**
     * name of the Lease
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireadNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireadNamespacedLease
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireadNamespacedLease
     */
    pretty?: string
}

export interface CoordinationV1ApiReplaceNamespacedLeaseRequest {
    /**
     * name of the Lease
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    namespace: string
    /**
     * 
     * @type V1Lease
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    body: V1Lease
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1ApireplaceNamespacedLease
     */
    fieldValidation?: string
}

export class ObjectCoordinationV1Api {
    private api: ObservableCoordinationV1Api

    public constructor(configuration: Configuration, requestFactory?: CoordinationV1ApiRequestFactory, responseProcessor?: CoordinationV1ApiResponseProcessor) {
        this.api = new ObservableCoordinationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a Lease
     * @param param the request object
     */
    public createNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiCreateNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Lease>> {
        return this.api.createNamespacedLeaseWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Lease
     * @param param the request object
     */
    public createNamespacedLease(param: CoordinationV1ApiCreateNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<V1Lease> {
        return this.api.createNamespacedLease(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of Lease
     * @param param the request object
     */
    public deleteCollectionNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiDeleteCollectionNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedLeaseWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Lease
     * @param param the request object
     */
    public deleteCollectionNamespacedLease(param: CoordinationV1ApiDeleteCollectionNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedLease(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a Lease
     * @param param the request object
     */
    public deleteNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiDeleteNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Lease
     * @param param the request object
     */
    public deleteNamespacedLease(param: CoordinationV1ApiDeleteNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedLease(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CoordinationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CoordinationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listLeaseForAllNamespacesWithHttpInfo(param: CoordinationV1ApiListLeaseForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1LeaseList>> {
        return this.api.listLeaseForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listLeaseForAllNamespaces(param: CoordinationV1ApiListLeaseForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1LeaseList> {
        return this.api.listLeaseForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiListNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1LeaseList>> {
        return this.api.listNamespacedLeaseWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Lease
     * @param param the request object
     */
    public listNamespacedLease(param: CoordinationV1ApiListNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<V1LeaseList> {
        return this.api.listNamespacedLease(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified Lease
     * @param param the request object
     */
    public patchNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiPatchNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Lease>> {
        return this.api.patchNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Lease
     * @param param the request object
     */
    public patchNamespacedLease(param: CoordinationV1ApiPatchNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<V1Lease> {
        return this.api.patchNamespacedLease(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified Lease
     * @param param the request object
     */
    public readNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiReadNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Lease>> {
        return this.api.readNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Lease
     * @param param the request object
     */
    public readNamespacedLease(param: CoordinationV1ApiReadNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<V1Lease> {
        return this.api.readNamespacedLease(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified Lease
     * @param param the request object
     */
    public replaceNamespacedLeaseWithHttpInfo(param: CoordinationV1ApiReplaceNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Lease>> {
        return this.api.replaceNamespacedLeaseWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Lease
     * @param param the request object
     */
    public replaceNamespacedLease(param: CoordinationV1ApiReplaceNamespacedLeaseRequest, options?: ConfigurationOptions): Promise<V1Lease> {
        return this.api.replaceNamespacedLease(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCoordinationV1alpha2Api } from "./ObservableAPI.js";
import { CoordinationV1alpha2ApiRequestFactory, CoordinationV1alpha2ApiResponseProcessor} from "../apis/CoordinationV1alpha2Api.js";

export interface CoordinationV1alpha2ApiCreateNamespacedLeaseCandidateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApicreateNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * 
     * @type V1alpha2LeaseCandidate
     * @memberof CoordinationV1alpha2ApicreateNamespacedLeaseCandidate
     */
    body: V1alpha2LeaseCandidate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApicreateNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApicreateNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApicreateNamespacedLeaseCandidate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApicreateNamespacedLeaseCandidate
     */
    fieldValidation?: string
}

export interface CoordinationV1alpha2ApiDeleteCollectionNamespacedLeaseCandidateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1alpha2ApideleteCollectionNamespacedLeaseCandidate
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1alpha2ApiDeleteNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1alpha2ApideleteNamespacedLeaseCandidate
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1alpha2ApiGetAPIResourcesRequest {
}

export interface CoordinationV1alpha2ApiListLeaseCandidateForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApilistLeaseCandidateForAllNamespaces
     */
    watch?: boolean
}

export interface CoordinationV1alpha2ApiListNamespacedLeaseCandidateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApilistNamespacedLeaseCandidate
     */
    watch?: boolean
}

export interface CoordinationV1alpha2ApiPatchNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1alpha2ApipatchNamespacedLeaseCandidate
     */
    force?: boolean
}

export interface CoordinationV1alpha2ApiReadNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireadNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireadNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireadNamespacedLeaseCandidate
     */
    pretty?: string
}

export interface CoordinationV1alpha2ApiReplaceNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireplaceNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireplaceNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * 
     * @type V1alpha2LeaseCandidate
     * @memberof CoordinationV1alpha2ApireplaceNamespacedLeaseCandidate
     */
    body: V1alpha2LeaseCandidate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireplaceNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireplaceNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireplaceNamespacedLeaseCandidate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1alpha2ApireplaceNamespacedLeaseCandidate
     */
    fieldValidation?: string
}

export class ObjectCoordinationV1alpha2Api {
    private api: ObservableCoordinationV1alpha2Api

    public constructor(configuration: Configuration, requestFactory?: CoordinationV1alpha2ApiRequestFactory, responseProcessor?: CoordinationV1alpha2ApiResponseProcessor) {
        this.api = new ObservableCoordinationV1alpha2Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a LeaseCandidate
     * @param param the request object
     */
    public createNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1alpha2ApiCreateNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha2LeaseCandidate>> {
        return this.api.createNamespacedLeaseCandidateWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a LeaseCandidate
     * @param param the request object
     */
    public createNamespacedLeaseCandidate(param: CoordinationV1alpha2ApiCreateNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1alpha2LeaseCandidate> {
        return this.api.createNamespacedLeaseCandidate(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of LeaseCandidate
     * @param param the request object
     */
    public deleteCollectionNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1alpha2ApiDeleteCollectionNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedLeaseCandidateWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of LeaseCandidate
     * @param param the request object
     */
    public deleteCollectionNamespacedLeaseCandidate(param: CoordinationV1alpha2ApiDeleteCollectionNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedLeaseCandidate(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a LeaseCandidate
     * @param param the request object
     */
    public deleteNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1alpha2ApiDeleteNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a LeaseCandidate
     * @param param the request object
     */
    public deleteNamespacedLeaseCandidate(param: CoordinationV1alpha2ApiDeleteNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedLeaseCandidate(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CoordinationV1alpha2ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CoordinationV1alpha2ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listLeaseCandidateForAllNamespacesWithHttpInfo(param: CoordinationV1alpha2ApiListLeaseCandidateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha2LeaseCandidateList>> {
        return this.api.listLeaseCandidateForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listLeaseCandidateForAllNamespaces(param: CoordinationV1alpha2ApiListLeaseCandidateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1alpha2LeaseCandidateList> {
        return this.api.listLeaseCandidateForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1alpha2ApiListNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha2LeaseCandidateList>> {
        return this.api.listNamespacedLeaseCandidateWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listNamespacedLeaseCandidate(param: CoordinationV1alpha2ApiListNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1alpha2LeaseCandidateList> {
        return this.api.listNamespacedLeaseCandidate(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified LeaseCandidate
     * @param param the request object
     */
    public patchNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1alpha2ApiPatchNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha2LeaseCandidate>> {
        return this.api.patchNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified LeaseCandidate
     * @param param the request object
     */
    public patchNamespacedLeaseCandidate(param: CoordinationV1alpha2ApiPatchNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1alpha2LeaseCandidate> {
        return this.api.patchNamespacedLeaseCandidate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified LeaseCandidate
     * @param param the request object
     */
    public readNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1alpha2ApiReadNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha2LeaseCandidate>> {
        return this.api.readNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified LeaseCandidate
     * @param param the request object
     */
    public readNamespacedLeaseCandidate(param: CoordinationV1alpha2ApiReadNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1alpha2LeaseCandidate> {
        return this.api.readNamespacedLeaseCandidate(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified LeaseCandidate
     * @param param the request object
     */
    public replaceNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1alpha2ApiReplaceNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha2LeaseCandidate>> {
        return this.api.replaceNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified LeaseCandidate
     * @param param the request object
     */
    public replaceNamespacedLeaseCandidate(param: CoordinationV1alpha2ApiReplaceNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1alpha2LeaseCandidate> {
        return this.api.replaceNamespacedLeaseCandidate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCoordinationV1beta1Api } from "./ObservableAPI.js";
import { CoordinationV1beta1ApiRequestFactory, CoordinationV1beta1ApiResponseProcessor} from "../apis/CoordinationV1beta1Api.js";

export interface CoordinationV1beta1ApiCreateNamespacedLeaseCandidateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApicreateNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * 
     * @type V1beta1LeaseCandidate
     * @memberof CoordinationV1beta1ApicreateNamespacedLeaseCandidate
     */
    body: V1beta1LeaseCandidate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApicreateNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApicreateNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApicreateNamespacedLeaseCandidate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApicreateNamespacedLeaseCandidate
     */
    fieldValidation?: string
}

export interface CoordinationV1beta1ApiDeleteCollectionNamespacedLeaseCandidateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1beta1ApideleteCollectionNamespacedLeaseCandidate
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1beta1ApiDeleteNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoordinationV1beta1ApideleteNamespacedLeaseCandidate
     */
    body?: V1DeleteOptions
}

export interface CoordinationV1beta1ApiGetAPIResourcesRequest {
}

export interface CoordinationV1beta1ApiListLeaseCandidateForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApilistLeaseCandidateForAllNamespaces
     */
    watch?: boolean
}

export interface CoordinationV1beta1ApiListNamespacedLeaseCandidateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApilistNamespacedLeaseCandidate
     */
    watch?: boolean
}

export interface CoordinationV1beta1ApiPatchNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoordinationV1beta1ApipatchNamespacedLeaseCandidate
     */
    force?: boolean
}

export interface CoordinationV1beta1ApiReadNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireadNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireadNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireadNamespacedLeaseCandidate
     */
    pretty?: string
}

export interface CoordinationV1beta1ApiReplaceNamespacedLeaseCandidateRequest {
    /**
     * name of the LeaseCandidate
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireplaceNamespacedLeaseCandidate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireplaceNamespacedLeaseCandidate
     */
    namespace: string
    /**
     * 
     * @type V1beta1LeaseCandidate
     * @memberof CoordinationV1beta1ApireplaceNamespacedLeaseCandidate
     */
    body: V1beta1LeaseCandidate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireplaceNamespacedLeaseCandidate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireplaceNamespacedLeaseCandidate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireplaceNamespacedLeaseCandidate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoordinationV1beta1ApireplaceNamespacedLeaseCandidate
     */
    fieldValidation?: string
}

export class ObjectCoordinationV1beta1Api {
    private api: ObservableCoordinationV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: CoordinationV1beta1ApiRequestFactory, responseProcessor?: CoordinationV1beta1ApiResponseProcessor) {
        this.api = new ObservableCoordinationV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a LeaseCandidate
     * @param param the request object
     */
    public createNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1beta1ApiCreateNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1LeaseCandidate>> {
        return this.api.createNamespacedLeaseCandidateWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a LeaseCandidate
     * @param param the request object
     */
    public createNamespacedLeaseCandidate(param: CoordinationV1beta1ApiCreateNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1beta1LeaseCandidate> {
        return this.api.createNamespacedLeaseCandidate(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of LeaseCandidate
     * @param param the request object
     */
    public deleteCollectionNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1beta1ApiDeleteCollectionNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedLeaseCandidateWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of LeaseCandidate
     * @param param the request object
     */
    public deleteCollectionNamespacedLeaseCandidate(param: CoordinationV1beta1ApiDeleteCollectionNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedLeaseCandidate(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a LeaseCandidate
     * @param param the request object
     */
    public deleteNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1beta1ApiDeleteNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a LeaseCandidate
     * @param param the request object
     */
    public deleteNamespacedLeaseCandidate(param: CoordinationV1beta1ApiDeleteNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedLeaseCandidate(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CoordinationV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CoordinationV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listLeaseCandidateForAllNamespacesWithHttpInfo(param: CoordinationV1beta1ApiListLeaseCandidateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1LeaseCandidateList>> {
        return this.api.listLeaseCandidateForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listLeaseCandidateForAllNamespaces(param: CoordinationV1beta1ApiListLeaseCandidateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1beta1LeaseCandidateList> {
        return this.api.listLeaseCandidateForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1beta1ApiListNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1LeaseCandidateList>> {
        return this.api.listNamespacedLeaseCandidateWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LeaseCandidate
     * @param param the request object
     */
    public listNamespacedLeaseCandidate(param: CoordinationV1beta1ApiListNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1beta1LeaseCandidateList> {
        return this.api.listNamespacedLeaseCandidate(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified LeaseCandidate
     * @param param the request object
     */
    public patchNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1beta1ApiPatchNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1LeaseCandidate>> {
        return this.api.patchNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified LeaseCandidate
     * @param param the request object
     */
    public patchNamespacedLeaseCandidate(param: CoordinationV1beta1ApiPatchNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1beta1LeaseCandidate> {
        return this.api.patchNamespacedLeaseCandidate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified LeaseCandidate
     * @param param the request object
     */
    public readNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1beta1ApiReadNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1LeaseCandidate>> {
        return this.api.readNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified LeaseCandidate
     * @param param the request object
     */
    public readNamespacedLeaseCandidate(param: CoordinationV1beta1ApiReadNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1beta1LeaseCandidate> {
        return this.api.readNamespacedLeaseCandidate(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified LeaseCandidate
     * @param param the request object
     */
    public replaceNamespacedLeaseCandidateWithHttpInfo(param: CoordinationV1beta1ApiReplaceNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1LeaseCandidate>> {
        return this.api.replaceNamespacedLeaseCandidateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified LeaseCandidate
     * @param param the request object
     */
    public replaceNamespacedLeaseCandidate(param: CoordinationV1beta1ApiReplaceNamespacedLeaseCandidateRequest, options?: ConfigurationOptions): Promise<V1beta1LeaseCandidate> {
        return this.api.replaceNamespacedLeaseCandidate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCoreApi } from "./ObservableAPI.js";
import { CoreApiRequestFactory, CoreApiResponseProcessor} from "../apis/CoreApi.js";

export interface CoreApiGetAPIVersionsRequest {
}

export class ObjectCoreApi {
    private api: ObservableCoreApi

    public constructor(configuration: Configuration, requestFactory?: CoreApiRequestFactory, responseProcessor?: CoreApiResponseProcessor) {
        this.api = new ObservableCoreApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersionsWithHttpInfo(param: CoreApiGetAPIVersionsRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIVersions>> {
        return this.api.getAPIVersionsWithHttpInfo( options).toPromise();
    }

    /**
     * get available API versions
     * @param param the request object
     */
    public getAPIVersions(param: CoreApiGetAPIVersionsRequest = {}, options?: ConfigurationOptions): Promise<V1APIVersions> {
        return this.api.getAPIVersions( options).toPromise();
    }

}

import { ObservableCoreV1Api } from "./ObservableAPI.js";
import { CoreV1ApiRequestFactory, CoreV1ApiResponseProcessor} from "../apis/CoreV1Api.js";

export interface CoreV1ApiConnectDeleteNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectDeleteNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectDeleteNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectDeleteNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectDeleteNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectGetNamespacedPodAttachRequest {
    /**
     * name of the PodAttachOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    namespace: string
    /**
     * The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    container?: string
    /**
     * Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    stderr?: boolean
    /**
     * Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    stdin?: boolean
    /**
     * Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodAttach
     */
    tty?: boolean
}

export interface CoreV1ApiConnectGetNamespacedPodExecRequest {
    /**
     * name of the PodExecOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    namespace: string
    /**
     * Command is the remote command to execute. argv array. Not executed within a shell.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    command?: string
    /**
     * Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    container?: string
    /**
     * Redirect the standard error stream of the pod for this call.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    stderr?: boolean
    /**
     * Redirect the standard input stream of the pod for this call. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    stdin?: boolean
    /**
     * Redirect the standard output stream of the pod for this call.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectGetNamespacedPodExec
     */
    tty?: boolean
}

export interface CoreV1ApiConnectGetNamespacedPodPortforwardRequest {
    /**
     * name of the PodPortForwardOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodPortforward
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodPortforward
     */
    namespace: string
    /**
     * List of ports to forward Required when using WebSockets
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApiconnectGetNamespacedPodPortforward
     */
    ports?: number
}

export interface CoreV1ApiConnectGetNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectGetNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectGetNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectGetNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectGetNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectHeadNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectHeadNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectHeadNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectHeadNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectHeadNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectOptionsNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectOptionsNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectOptionsNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectOptionsNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectOptionsNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPatchNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPatchNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPatchNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPatchNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPatchNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPostNamespacedPodAttachRequest {
    /**
     * name of the PodAttachOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    namespace: string
    /**
     * The container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    container?: string
    /**
     * Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    stderr?: boolean
    /**
     * Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    stdin?: boolean
    /**
     * Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodAttach
     */
    tty?: boolean
}

export interface CoreV1ApiConnectPostNamespacedPodExecRequest {
    /**
     * name of the PodExecOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    namespace: string
    /**
     * Command is the remote command to execute. argv array. Not executed within a shell.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    command?: string
    /**
     * Container in which to execute the command. Defaults to only container if there is only one container in the pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    container?: string
    /**
     * Redirect the standard error stream of the pod for this call.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    stderr?: boolean
    /**
     * Redirect the standard input stream of the pod for this call. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    stdin?: boolean
    /**
     * Redirect the standard output stream of the pod for this call.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    stdout?: boolean
    /**
     * TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApiconnectPostNamespacedPodExec
     */
    tty?: boolean
}

export interface CoreV1ApiConnectPostNamespacedPodPortforwardRequest {
    /**
     * name of the PodPortForwardOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodPortforward
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodPortforward
     */
    namespace: string
    /**
     * List of ports to forward Required when using WebSockets
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApiconnectPostNamespacedPodPortforward
     */
    ports?: number
}

export interface CoreV1ApiConnectPostNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPostNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPostNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPostNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPostNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPutNamespacedPodProxyRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxy
     */
    namespace: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest {
    /**
     * name of the PodProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedPodProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPutNamespacedServiceProxyRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxy
     */
    namespace: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest {
    /**
     * name of the ServiceProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    namespace: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    path: string
    /**
     * Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q&#x3D;user:kimchy. Path is _search?q&#x3D;user:kimchy.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNamespacedServiceProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiConnectPutNodeProxyRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxy
     */
    name: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxy
     */
    path?: string
}

export interface CoreV1ApiConnectPutNodeProxyWithPathRequest {
    /**
     * name of the NodeProxyOptions
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxyWithPath
     */
    name: string
    /**
     * path to the resource
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxyWithPath
     */
    path: string
    /**
     * Path is the URL path to use for the current proxy request to node.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApiconnectPutNodeProxyWithPath
     */
    path2?: string
}

export interface CoreV1ApiCreateNamespaceRequest {
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApicreateNamespace
     */
    body: V1Namespace
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespace
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespace
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespace
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    namespace: string
    /**
     * 
     * @type V1Binding
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    body: V1Binding
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedBinding
     */
    pretty?: string
}

export interface CoreV1ApiCreateNamespacedConfigMapRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    namespace: string
    /**
     * 
     * @type V1ConfigMap
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    body: V1ConfigMap
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedConfigMap
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedEndpointsRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    namespace: string
    /**
     * 
     * @type V1Endpoints
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    body: V1Endpoints
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEndpoints
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type CoreV1Event
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    body: CoreV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedEvent
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedLimitRangeRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    namespace: string
    /**
     * 
     * @type V1LimitRange
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    body: V1LimitRange
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedLimitRange
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * 
     * @type V1PersistentVolumeClaim
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    body: V1PersistentVolumeClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPersistentVolumeClaim
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedPodRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApicreateNamespacedPod
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPod
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedPodBindingRequest {
    /**
     * name of the Binding
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    namespace: string
    /**
     * 
     * @type V1Binding
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    body: V1Binding
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodBinding
     */
    pretty?: string
}

export interface CoreV1ApiCreateNamespacedPodEvictionRequest {
    /**
     * name of the Eviction
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    namespace: string
    /**
     * 
     * @type V1Eviction
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    body: V1Eviction
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodEviction
     */
    pretty?: string
}

export interface CoreV1ApiCreateNamespacedPodTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    namespace: string
    /**
     * 
     * @type V1PodTemplate
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    body: V1PodTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedPodTemplate
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedReplicationControllerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    namespace: string
    /**
     * 
     * @type V1ReplicationController
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    body: V1ReplicationController
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedReplicationController
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedResourceQuotaRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    namespace: string
    /**
     * 
     * @type V1ResourceQuota
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    body: V1ResourceQuota
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedResourceQuota
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedSecretRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    namespace: string
    /**
     * 
     * @type V1Secret
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    body: V1Secret
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedSecret
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedServiceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    namespace: string
    /**
     * 
     * @type V1Service
     * @memberof CoreV1ApicreateNamespacedService
     */
    body: V1Service
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedService
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedServiceAccountRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    namespace: string
    /**
     * 
     * @type V1ServiceAccount
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    body: V1ServiceAccount
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccount
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreateNamespacedServiceAccountTokenRequest {
    /**
     * name of the TokenRequest
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    namespace: string
    /**
     * 
     * @type AuthenticationV1TokenRequest
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    body: AuthenticationV1TokenRequest
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNamespacedServiceAccountToken
     */
    pretty?: string
}

export interface CoreV1ApiCreateNodeRequest {
    /**
     * 
     * @type V1Node
     * @memberof CoreV1ApicreateNode
     */
    body: V1Node
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNode
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreateNode
     */
    fieldValidation?: string
}

export interface CoreV1ApiCreatePersistentVolumeRequest {
    /**
     * 
     * @type V1PersistentVolume
     * @memberof CoreV1ApicreatePersistentVolume
     */
    body: V1PersistentVolume
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreatePersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreatePersistentVolume
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreatePersistentVolume
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApicreatePersistentVolume
     */
    fieldValidation?: string
}

export interface CoreV1ApiDeleteCollectionNamespacedConfigMapRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedConfigMap
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedEndpointsRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedEndpoints
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedLimitRange
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedPersistentVolumeClaim
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedPodRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedPod
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedPodTemplate
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedReplicationController
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedResourceQuota
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedSecretRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedSecret
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedServiceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedService
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNamespacedServiceAccount
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionNodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNode
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNode
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNode
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionNode
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionNode
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionNode
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionNode
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteCollectionPersistentVolumeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteCollectionPersistentVolume
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespaceRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespace
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespace
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespace
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespace
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespace
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedConfigMap
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedEndpoints
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedLimitRange
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedPersistentVolumeClaim
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedPodRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedPod
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPod
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPod
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPod
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedPod
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedPodTemplate
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedReplicationController
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedResourceQuota
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedSecretRequest {
    /**
     * name of the Secret
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedSecret
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedServiceRequest {
    /**
     * name of the Service
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedService
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedService
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedService
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedService
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedService
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNamespacedServiceAccount
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeleteNodeRequest {
    /**
     * name of the Node
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideleteNode
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNode
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideleteNode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideleteNode
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideleteNode
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiDeletePersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApideletePersistentVolume
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideletePersistentVolume
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApideletePersistentVolume
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApideletePersistentVolume
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CoreV1ApideletePersistentVolume
     */
    body?: V1DeleteOptions
}

export interface CoreV1ApiGetAPIResourcesRequest {
}

export interface CoreV1ApiListComponentStatusRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistComponentStatus
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistComponentStatus
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistComponentStatus
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistComponentStatus
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistComponentStatus
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistComponentStatus
     */
    watch?: boolean
}

export interface CoreV1ApiListConfigMapForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistConfigMapForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListEndpointsForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistEndpointsForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListEventForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistEventForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListLimitRangeForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistLimitRangeForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespaceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespace
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespace
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespace
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespace
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespace
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespace
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedConfigMapRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedConfigMap
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedEndpointsRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEndpoints
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEvent
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedEvent
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEvent
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedEvent
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedLimitRangeRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedLimitRange
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedPersistentVolumeClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPersistentVolumeClaim
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedPodRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPod
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedPod
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPod
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPod
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedPod
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPod
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedPodTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedPodTemplate
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedReplicationControllerRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedReplicationController
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedResourceQuotaRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedResourceQuota
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedSecretRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedSecret
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedSecret
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedSecret
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedSecret
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedSecret
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedSecret
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedServiceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedService
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedService
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedService
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedService
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedService
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedService
     */
    watch?: boolean
}

export interface CoreV1ApiListNamespacedServiceAccountRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNamespacedServiceAccount
     */
    watch?: boolean
}

export interface CoreV1ApiListNodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNode
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNode
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNode
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNode
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNode
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistNode
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNode
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistNode
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistNode
     */
    watch?: boolean
}

export interface CoreV1ApiListPersistentVolumeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolume
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPersistentVolume
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolume
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolume
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPersistentVolume
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolume
     */
    watch?: boolean
}

export interface CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPersistentVolumeClaimForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListPodForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPodForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListPodTemplateForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistPodTemplateForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListReplicationControllerForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistReplicationControllerForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListResourceQuotaForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistResourceQuotaForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListSecretForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistSecretForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListServiceAccountForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistServiceAccountForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiListServiceForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApilistServiceForAllNamespaces
     */
    watch?: boolean
}

export interface CoreV1ApiPatchNamespaceRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespace
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespace
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespace
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespaceStatusRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespaceStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedConfigMap
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedEndpoints
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedEvent
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedLimitRange
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaim
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest {
    /**
     * name of the PersistentVolumeClaim
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPersistentVolumeClaimStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPod
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPod
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPod
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPodEphemeralcontainers
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodResizeRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPodResize
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodStatusRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPodStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedPodTemplate
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedReplicationController
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedReplicationControllerScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedReplicationControllerScale
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedReplicationControllerStatusRequest {
    /**
     * name of the ReplicationController
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedReplicationControllerStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedResourceQuota
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedResourceQuotaStatusRequest {
    /**
     * name of the ResourceQuota
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedResourceQuotaStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedSecretRequest {
    /**
     * name of the Secret
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedSecret
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedServiceRequest {
    /**
     * name of the Service
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedService
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedService
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedService
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedServiceAccount
     */
    force?: boolean
}

export interface CoreV1ApiPatchNamespacedServiceStatusRequest {
    /**
     * name of the Service
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNamespacedServiceStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchNodeRequest {
    /**
     * name of the Node
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNode
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNode
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNode
     */
    force?: boolean
}

export interface CoreV1ApiPatchNodeStatusRequest {
    /**
     * name of the Node
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchNodeStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchNodeStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchNodeStatus
     */
    force?: boolean
}

export interface CoreV1ApiPatchPersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchPersistentVolume
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolume
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchPersistentVolume
     */
    force?: boolean
}

export interface CoreV1ApiPatchPersistentVolumeStatusRequest {
    /**
     * name of the PersistentVolume
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApipatchPersistentVolumeStatus
     */
    force?: boolean
}

export interface CoreV1ApiReadComponentStatusRequest {
    /**
     * name of the ComponentStatus
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadComponentStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadComponentStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespaceRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespace
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespace
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespaceStatusRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespaceStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespaceStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedConfigMap
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedConfigMap
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedEndpoints
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedEndpoints
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedEvent
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedLimitRange
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedLimitRange
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaim
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest {
    /**
     * name of the PersistentVolumeClaim
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaimStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPersistentVolumeClaimStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPod
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPod
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodEphemeralcontainersRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodEphemeralcontainers
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodEphemeralcontainers
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodEphemeralcontainers
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodLogRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    namespace: string
    /**
     * The container for which to stream logs. Defaults to only container if there is one container in the pod.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    container?: string
    /**
     * Follow the log stream of the pod. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    follow?: boolean
    /**
     * insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real kubelet.  If the kubelet is configured to verify the apiserver\&#39;s TLS credentials, it does not mean the connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept the actual log data coming from the real kubelet).
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    insecureSkipTLSVerifyBackend?: boolean
    /**
     * If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    limitBytes?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    pretty?: string
    /**
     * Return previous terminated container logs. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    previous?: boolean
    /**
     * A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    sinceSeconds?: number
    /**
     * Specify which container log stream to return to the client. Acceptable values are \&quot;All\&quot;, \&quot;Stdout\&quot; and \&quot;Stderr\&quot;. If not specified, \&quot;All\&quot; is used, and both stdout and stderr are returned interleaved. Note that when \&quot;TailLines\&quot; is specified, \&quot;Stream\&quot; can only be set to nil or \&quot;All\&quot;.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    stream?: string
    /**
     * If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime. Note that when \&quot;TailLines\&quot; is specified, \&quot;Stream\&quot; can only be set to nil or \&quot;All\&quot;.
     * Defaults to: undefined
     * @type number
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    tailLines?: number
    /**
     * If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
     * Defaults to: undefined
     * @type boolean
     * @memberof CoreV1ApireadNamespacedPodLog
     */
    timestamps?: boolean
}

export interface CoreV1ApiReadNamespacedPodResizeRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodResize
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodResize
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodResize
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodStatusRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedPodTemplate
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationController
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationController
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedReplicationControllerScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerScale
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerScale
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedReplicationControllerStatusRequest {
    /**
     * name of the ReplicationController
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedReplicationControllerStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuota
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuota
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedResourceQuotaStatusRequest {
    /**
     * name of the ResourceQuota
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuotaStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuotaStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedResourceQuotaStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedSecretRequest {
    /**
     * name of the Secret
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedSecret
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedSecret
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedServiceRequest {
    /**
     * name of the Service
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedService
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedService
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceAccount
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceAccount
     */
    pretty?: string
}

export interface CoreV1ApiReadNamespacedServiceStatusRequest {
    /**
     * name of the Service
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNamespacedServiceStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadNodeRequest {
    /**
     * name of the Node
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNode
     */
    pretty?: string
}

export interface CoreV1ApiReadNodeStatusRequest {
    /**
     * name of the Node
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNodeStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadNodeStatus
     */
    pretty?: string
}

export interface CoreV1ApiReadPersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadPersistentVolume
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadPersistentVolume
     */
    pretty?: string
}

export interface CoreV1ApiReadPersistentVolumeStatusRequest {
    /**
     * name of the PersistentVolume
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadPersistentVolumeStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireadPersistentVolumeStatus
     */
    pretty?: string
}

export interface CoreV1ApiReplaceNamespaceRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    name: string
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApireplaceNamespace
     */
    body: V1Namespace
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespace
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespaceFinalizeRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    name: string
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    body: V1Namespace
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    fieldValidation?: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceFinalize
     */
    pretty?: string
}

export interface CoreV1ApiReplaceNamespaceStatusRequest {
    /**
     * name of the Namespace
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    name: string
    /**
     * 
     * @type V1Namespace
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    body: V1Namespace
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespaceStatus
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedConfigMapRequest {
    /**
     * name of the ConfigMap
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    namespace: string
    /**
     * 
     * @type V1ConfigMap
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    body: V1ConfigMap
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedConfigMap
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedEndpointsRequest {
    /**
     * name of the Endpoints
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    namespace: string
    /**
     * 
     * @type V1Endpoints
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    body: V1Endpoints
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEndpoints
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type CoreV1Event
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    body: CoreV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedEvent
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedLimitRangeRequest {
    /**
     * name of the LimitRange
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    namespace: string
    /**
     * 
     * @type V1LimitRange
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    body: V1LimitRange
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedLimitRange
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest {
    /**
     * name of the PersistentVolumeClaim
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    namespace: string
    /**
     * 
     * @type V1PersistentVolumeClaim
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    body: V1PersistentVolumeClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaim
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest {
    /**
     * name of the PersistentVolumeClaim
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    namespace: string
    /**
     * 
     * @type V1PersistentVolumeClaim
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    body: V1PersistentVolumeClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPersistentVolumeClaimStatus
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedPodRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPod
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodEphemeralcontainers
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedPodResizeRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodResize
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodResize
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApireplaceNamespacedPodResize
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodResize
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodResize
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodResize
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodResize
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedPodStatusRequest {
    /**
     * name of the Pod
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    namespace: string
    /**
     * 
     * @type V1Pod
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    body: V1Pod
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodStatus
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedPodTemplateRequest {
    /**
     * name of the PodTemplate
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    namespace: string
    /**
     * 
     * @type V1PodTemplate
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    body: V1PodTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedPodTemplate
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerRequest {
    /**
     * name of the ReplicationController
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    namespace: string
    /**
     * 
     * @type V1ReplicationController
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    body: V1ReplicationController
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationController
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest {
    /**
     * name of the Scale
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    namespace: string
    /**
     * 
     * @type V1Scale
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    body: V1Scale
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerScale
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest {
    /**
     * name of the ReplicationController
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    namespace: string
    /**
     * 
     * @type V1ReplicationController
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    body: V1ReplicationController
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedReplicationControllerStatus
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedResourceQuotaRequest {
    /**
     * name of the ResourceQuota
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    namespace: string
    /**
     * 
     * @type V1ResourceQuota
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    body: V1ResourceQuota
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuota
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest {
    /**
     * name of the ResourceQuota
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    namespace: string
    /**
     * 
     * @type V1ResourceQuota
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    body: V1ResourceQuota
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedResourceQuotaStatus
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedSecretRequest {
    /**
     * name of the Secret
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    namespace: string
    /**
     * 
     * @type V1Secret
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    body: V1Secret
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedSecret
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedServiceRequest {
    /**
     * name of the Service
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    namespace: string
    /**
     * 
     * @type V1Service
     * @memberof CoreV1ApireplaceNamespacedService
     */
    body: V1Service
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedService
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedServiceAccountRequest {
    /**
     * name of the ServiceAccount
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    namespace: string
    /**
     * 
     * @type V1ServiceAccount
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    body: V1ServiceAccount
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceAccount
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNamespacedServiceStatusRequest {
    /**
     * name of the Service
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    namespace: string
    /**
     * 
     * @type V1Service
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    body: V1Service
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNamespacedServiceStatus
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNodeRequest {
    /**
     * name of the Node
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    name: string
    /**
     * 
     * @type V1Node
     * @memberof CoreV1ApireplaceNode
     */
    body: V1Node
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNode
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplaceNodeStatusRequest {
    /**
     * name of the Node
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    name: string
    /**
     * 
     * @type V1Node
     * @memberof CoreV1ApireplaceNodeStatus
     */
    body: V1Node
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplaceNodeStatus
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplacePersistentVolumeRequest {
    /**
     * name of the PersistentVolume
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    name: string
    /**
     * 
     * @type V1PersistentVolume
     * @memberof CoreV1ApireplacePersistentVolume
     */
    body: V1PersistentVolume
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolume
     */
    fieldValidation?: string
}

export interface CoreV1ApiReplacePersistentVolumeStatusRequest {
    /**
     * name of the PersistentVolume
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    name: string
    /**
     * 
     * @type V1PersistentVolume
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    body: V1PersistentVolume
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof CoreV1ApireplacePersistentVolumeStatus
     */
    fieldValidation?: string
}

export class ObjectCoreV1Api {
    private api: ObservableCoreV1Api

    public constructor(configuration: Configuration, requestFactory?: CoreV1ApiRequestFactory, responseProcessor?: CoreV1ApiResponseProcessor) {
        this.api = new ObservableCoreV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxy(param: CoreV1ApiConnectDeleteNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectDeleteNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Pod
     * @param param the request object
     */
    public connectDeleteNamespacedPodProxyWithPath(param: CoreV1ApiConnectDeleteNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectDeleteNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxy(param: CoreV1ApiConnectDeleteNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectDeleteNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Service
     * @param param the request object
     */
    public connectDeleteNamespacedServiceProxyWithPath(param: CoreV1ApiConnectDeleteNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectDeleteNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxyWithHttpInfo(param: CoreV1ApiConnectDeleteNodeProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxy(param: CoreV1ApiConnectDeleteNodeProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectDeleteNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectDeleteNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectDeleteNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect DELETE requests to proxy of Node
     * @param param the request object
     */
    public connectDeleteNodeProxyWithPath(param: CoreV1ApiConnectDeleteNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectDeleteNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to attach of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodAttachWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodAttachRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodAttachWithHttpInfo(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to attach of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodAttach(param: CoreV1ApiConnectGetNamespacedPodAttachRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNamespacedPodAttach(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to exec of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodExecWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodExecRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodExecWithHttpInfo(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to exec of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodExec(param: CoreV1ApiConnectGetNamespacedPodExecRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNamespacedPodExec(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect GET requests to portforward of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodPortforwardWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodPortforwardRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodPortforwardWithHttpInfo(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect GET requests to portforward of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodPortforward(param: CoreV1ApiConnectGetNamespacedPodPortforwardRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNamespacedPodPortforward(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxy(param: CoreV1ApiConnectGetNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Pod
     * @param param the request object
     */
    public connectGetNamespacedPodProxyWithPath(param: CoreV1ApiConnectGetNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectGetNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxy(param: CoreV1ApiConnectGetNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Service
     * @param param the request object
     */
    public connectGetNamespacedServiceProxyWithPath(param: CoreV1ApiConnectGetNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxyWithHttpInfo(param: CoreV1ApiConnectGetNodeProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxy(param: CoreV1ApiConnectGetNodeProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectGetNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectGetNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect GET requests to proxy of Node
     * @param param the request object
     */
    public connectGetNodeProxyWithPath(param: CoreV1ApiConnectGetNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectGetNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxy(param: CoreV1ApiConnectHeadNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectHeadNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Pod
     * @param param the request object
     */
    public connectHeadNamespacedPodProxyWithPath(param: CoreV1ApiConnectHeadNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectHeadNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxy(param: CoreV1ApiConnectHeadNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectHeadNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectHeadNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Service
     * @param param the request object
     */
    public connectHeadNamespacedServiceProxyWithPath(param: CoreV1ApiConnectHeadNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectHeadNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxyWithHttpInfo(param: CoreV1ApiConnectHeadNodeProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectHeadNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxy(param: CoreV1ApiConnectHeadNodeProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectHeadNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectHeadNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectHeadNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect HEAD requests to proxy of Node
     * @param param the request object
     */
    public connectHeadNodeProxyWithPath(param: CoreV1ApiConnectHeadNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectHeadNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxy(param: CoreV1ApiConnectOptionsNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectOptionsNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     * @param param the request object
     */
    public connectOptionsNamespacedPodProxyWithPath(param: CoreV1ApiConnectOptionsNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectOptionsNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxy(param: CoreV1ApiConnectOptionsNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectOptionsNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     * @param param the request object
     */
    public connectOptionsNamespacedServiceProxyWithPath(param: CoreV1ApiConnectOptionsNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectOptionsNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxyWithHttpInfo(param: CoreV1ApiConnectOptionsNodeProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxy(param: CoreV1ApiConnectOptionsNodeProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectOptionsNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectOptionsNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectOptionsNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     * @param param the request object
     */
    public connectOptionsNodeProxyWithPath(param: CoreV1ApiConnectOptionsNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectOptionsNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxy(param: CoreV1ApiConnectPatchNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPatchNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Pod
     * @param param the request object
     */
    public connectPatchNamespacedPodProxyWithPath(param: CoreV1ApiConnectPatchNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPatchNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxy(param: CoreV1ApiConnectPatchNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPatchNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPatchNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Service
     * @param param the request object
     */
    public connectPatchNamespacedServiceProxyWithPath(param: CoreV1ApiConnectPatchNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPatchNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxyWithHttpInfo(param: CoreV1ApiConnectPatchNodeProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPatchNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxy(param: CoreV1ApiConnectPatchNodeProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPatchNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPatchNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPatchNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PATCH requests to proxy of Node
     * @param param the request object
     */
    public connectPatchNodeProxyWithPath(param: CoreV1ApiConnectPatchNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPatchNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to attach of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodAttachWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodAttachRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodAttachWithHttpInfo(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to attach of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodAttach(param: CoreV1ApiConnectPostNamespacedPodAttachRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNamespacedPodAttach(param.name, param.namespace, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to exec of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodExecWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodExecRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodExecWithHttpInfo(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to exec of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodExec(param: CoreV1ApiConnectPostNamespacedPodExecRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNamespacedPodExec(param.name, param.namespace, param.command, param.container, param.stderr, param.stdin, param.stdout, param.tty,  options).toPromise();
    }

    /**
     * connect POST requests to portforward of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodPortforwardWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodPortforwardRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodPortforwardWithHttpInfo(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect POST requests to portforward of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodPortforward(param: CoreV1ApiConnectPostNamespacedPodPortforwardRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNamespacedPodPortforward(param.name, param.namespace, param.ports,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxy(param: CoreV1ApiConnectPostNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Pod
     * @param param the request object
     */
    public connectPostNamespacedPodProxyWithPath(param: CoreV1ApiConnectPostNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectPostNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxy(param: CoreV1ApiConnectPostNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Service
     * @param param the request object
     */
    public connectPostNamespacedServiceProxyWithPath(param: CoreV1ApiConnectPostNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxyWithHttpInfo(param: CoreV1ApiConnectPostNodeProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxy(param: CoreV1ApiConnectPostNodeProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPostNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPostNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect POST requests to proxy of Node
     * @param param the request object
     */
    public connectPostNodeProxyWithPath(param: CoreV1ApiConnectPostNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPostNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxyWithHttpInfo(param: CoreV1ApiConnectPutNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedPodProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxy(param: CoreV1ApiConnectPutNamespacedPodProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPutNamespacedPodProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedPodProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Pod
     * @param param the request object
     */
    public connectPutNamespacedPodProxyWithPath(param: CoreV1ApiConnectPutNamespacedPodProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPutNamespacedPodProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxyWithHttpInfo(param: CoreV1ApiConnectPutNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedServiceProxyWithHttpInfo(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxy(param: CoreV1ApiConnectPutNamespacedServiceProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPutNamespacedServiceProxy(param.name, param.namespace, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPutNamespacedServiceProxyWithPathWithHttpInfo(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Service
     * @param param the request object
     */
    public connectPutNamespacedServiceProxyWithPath(param: CoreV1ApiConnectPutNamespacedServiceProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPutNamespacedServiceProxyWithPath(param.name, param.namespace, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxyWithHttpInfo(param: CoreV1ApiConnectPutNodeProxyRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPutNodeProxyWithHttpInfo(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxy(param: CoreV1ApiConnectPutNodeProxyRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPutNodeProxy(param.name, param.path,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxyWithPathWithHttpInfo(param: CoreV1ApiConnectPutNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.connectPutNodeProxyWithPathWithHttpInfo(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * connect PUT requests to proxy of Node
     * @param param the request object
     */
    public connectPutNodeProxyWithPath(param: CoreV1ApiConnectPutNodeProxyWithPathRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.connectPutNodeProxyWithPath(param.name, param.path, param.path2,  options).toPromise();
    }

    /**
     * create a Namespace
     * @param param the request object
     */
    public createNamespaceWithHttpInfo(param: CoreV1ApiCreateNamespaceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.createNamespaceWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Namespace
     * @param param the request object
     */
    public createNamespace(param: CoreV1ApiCreateNamespaceRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.createNamespace(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Binding
     * @param param the request object
     */
    public createNamespacedBindingWithHttpInfo(param: CoreV1ApiCreateNamespacedBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Binding>> {
        return this.api.createNamespacedBindingWithHttpInfo(param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a Binding
     * @param param the request object
     */
    public createNamespacedBinding(param: CoreV1ApiCreateNamespacedBindingRequest, options?: ConfigurationOptions): Promise<V1Binding> {
        return this.api.createNamespacedBinding(param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a ConfigMap
     * @param param the request object
     */
    public createNamespacedConfigMapWithHttpInfo(param: CoreV1ApiCreateNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.createNamespacedConfigMapWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ConfigMap
     * @param param the request object
     */
    public createNamespacedConfigMap(param: CoreV1ApiCreateNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<V1ConfigMap> {
        return this.api.createNamespacedConfigMap(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create Endpoints
     * @param param the request object
     */
    public createNamespacedEndpointsWithHttpInfo(param: CoreV1ApiCreateNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Endpoints>> {
        return this.api.createNamespacedEndpointsWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create Endpoints
     * @param param the request object
     */
    public createNamespacedEndpoints(param: CoreV1ApiCreateNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<V1Endpoints> {
        return this.api.createNamespacedEndpoints(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEventWithHttpInfo(param: CoreV1ApiCreateNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<CoreV1Event>> {
        return this.api.createNamespacedEventWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEvent(param: CoreV1ApiCreateNamespacedEventRequest, options?: ConfigurationOptions): Promise<CoreV1Event> {
        return this.api.createNamespacedEvent(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a LimitRange
     * @param param the request object
     */
    public createNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiCreateNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1LimitRange>> {
        return this.api.createNamespacedLimitRangeWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a LimitRange
     * @param param the request object
     */
    public createNamespacedLimitRange(param: CoreV1ApiCreateNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<V1LimitRange> {
        return this.api.createNamespacedLimitRange(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PersistentVolumeClaim
     * @param param the request object
     */
    public createNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.createNamespacedPersistentVolumeClaimWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PersistentVolumeClaim
     * @param param the request object
     */
    public createNamespacedPersistentVolumeClaim(param: CoreV1ApiCreateNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.createNamespacedPersistentVolumeClaim(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Pod
     * @param param the request object
     */
    public createNamespacedPodWithHttpInfo(param: CoreV1ApiCreateNamespacedPodRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.createNamespacedPodWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Pod
     * @param param the request object
     */
    public createNamespacedPod(param: CoreV1ApiCreateNamespacedPodRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.createNamespacedPod(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create binding of a Pod
     * @param param the request object
     */
    public createNamespacedPodBindingWithHttpInfo(param: CoreV1ApiCreateNamespacedPodBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Binding>> {
        return this.api.createNamespacedPodBindingWithHttpInfo(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create binding of a Pod
     * @param param the request object
     */
    public createNamespacedPodBinding(param: CoreV1ApiCreateNamespacedPodBindingRequest, options?: ConfigurationOptions): Promise<V1Binding> {
        return this.api.createNamespacedPodBinding(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create eviction of a Pod
     * @param param the request object
     */
    public createNamespacedPodEvictionWithHttpInfo(param: CoreV1ApiCreateNamespacedPodEvictionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Eviction>> {
        return this.api.createNamespacedPodEvictionWithHttpInfo(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create eviction of a Pod
     * @param param the request object
     */
    public createNamespacedPodEviction(param: CoreV1ApiCreateNamespacedPodEvictionRequest, options?: ConfigurationOptions): Promise<V1Eviction> {
        return this.api.createNamespacedPodEviction(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a PodTemplate
     * @param param the request object
     */
    public createNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiCreateNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.createNamespacedPodTemplateWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PodTemplate
     * @param param the request object
     */
    public createNamespacedPodTemplate(param: CoreV1ApiCreateNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<V1PodTemplate> {
        return this.api.createNamespacedPodTemplate(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ReplicationController
     * @param param the request object
     */
    public createNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiCreateNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.createNamespacedReplicationControllerWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ReplicationController
     * @param param the request object
     */
    public createNamespacedReplicationController(param: CoreV1ApiCreateNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<V1ReplicationController> {
        return this.api.createNamespacedReplicationController(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceQuota
     * @param param the request object
     */
    public createNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiCreateNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.createNamespacedResourceQuotaWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceQuota
     * @param param the request object
     */
    public createNamespacedResourceQuota(param: CoreV1ApiCreateNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.createNamespacedResourceQuota(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Secret
     * @param param the request object
     */
    public createNamespacedSecretWithHttpInfo(param: CoreV1ApiCreateNamespacedSecretRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Secret>> {
        return this.api.createNamespacedSecretWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Secret
     * @param param the request object
     */
    public createNamespacedSecret(param: CoreV1ApiCreateNamespacedSecretRequest, options?: ConfigurationOptions): Promise<V1Secret> {
        return this.api.createNamespacedSecret(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Service
     * @param param the request object
     */
    public createNamespacedServiceWithHttpInfo(param: CoreV1ApiCreateNamespacedServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.createNamespacedServiceWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Service
     * @param param the request object
     */
    public createNamespacedService(param: CoreV1ApiCreateNamespacedServiceRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.createNamespacedService(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiCreateNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.createNamespacedServiceAccountWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccount(param: CoreV1ApiCreateNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<V1ServiceAccount> {
        return this.api.createNamespacedServiceAccount(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create token of a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccountTokenWithHttpInfo(param: CoreV1ApiCreateNamespacedServiceAccountTokenRequest, options?: ConfigurationOptions): Promise<HttpInfo<AuthenticationV1TokenRequest>> {
        return this.api.createNamespacedServiceAccountTokenWithHttpInfo(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create token of a ServiceAccount
     * @param param the request object
     */
    public createNamespacedServiceAccountToken(param: CoreV1ApiCreateNamespacedServiceAccountTokenRequest, options?: ConfigurationOptions): Promise<AuthenticationV1TokenRequest> {
        return this.api.createNamespacedServiceAccountToken(param.name, param.namespace, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * create a Node
     * @param param the request object
     */
    public createNodeWithHttpInfo(param: CoreV1ApiCreateNodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Node>> {
        return this.api.createNodeWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Node
     * @param param the request object
     */
    public createNode(param: CoreV1ApiCreateNodeRequest, options?: ConfigurationOptions): Promise<V1Node> {
        return this.api.createNode(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PersistentVolume
     * @param param the request object
     */
    public createPersistentVolumeWithHttpInfo(param: CoreV1ApiCreatePersistentVolumeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.createPersistentVolumeWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PersistentVolume
     * @param param the request object
     */
    public createPersistentVolume(param: CoreV1ApiCreatePersistentVolumeRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.createPersistentVolume(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of ConfigMap
     * @param param the request object
     */
    public deleteCollectionNamespacedConfigMapWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedConfigMapWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ConfigMap
     * @param param the request object
     */
    public deleteCollectionNamespacedConfigMap(param: CoreV1ApiDeleteCollectionNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedConfigMap(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Endpoints
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointsWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEndpointsWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Endpoints
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpoints(param: CoreV1ApiDeleteCollectionNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEndpoints(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEventWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEventWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEvent(param: CoreV1ApiDeleteCollectionNamespacedEventRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEvent(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of LimitRange
     * @param param the request object
     */
    public deleteCollectionNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedLimitRangeWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of LimitRange
     * @param param the request object
     */
    public deleteCollectionNamespacedLimitRange(param: CoreV1ApiDeleteCollectionNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedLimitRange(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolumeClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPersistentVolumeClaimWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolumeClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedPersistentVolumeClaim(param: CoreV1ApiDeleteCollectionNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPersistentVolumeClaim(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Pod
     * @param param the request object
     */
    public deleteCollectionNamespacedPodWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedPodRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPodWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Pod
     * @param param the request object
     */
    public deleteCollectionNamespacedPod(param: CoreV1ApiDeleteCollectionNamespacedPodRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPod(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPodTemplateWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedPodTemplate(param: CoreV1ApiDeleteCollectionNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPodTemplate(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicationController
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedReplicationControllerWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ReplicationController
     * @param param the request object
     */
    public deleteCollectionNamespacedReplicationController(param: CoreV1ApiDeleteCollectionNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedReplicationController(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceQuota
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceQuotaWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceQuota
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceQuota(param: CoreV1ApiDeleteCollectionNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceQuota(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Secret
     * @param param the request object
     */
    public deleteCollectionNamespacedSecretWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedSecretRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedSecretWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Secret
     * @param param the request object
     */
    public deleteCollectionNamespacedSecret(param: CoreV1ApiDeleteCollectionNamespacedSecretRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedSecret(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Service
     * @param param the request object
     */
    public deleteCollectionNamespacedServiceWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedServiceWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Service
     * @param param the request object
     */
    public deleteCollectionNamespacedService(param: CoreV1ApiDeleteCollectionNamespacedServiceRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedService(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceAccount
     * @param param the request object
     */
    public deleteCollectionNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedServiceAccountWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceAccount
     * @param param the request object
     */
    public deleteCollectionNamespacedServiceAccount(param: CoreV1ApiDeleteCollectionNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedServiceAccount(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Node
     * @param param the request object
     */
    public deleteCollectionNodeWithHttpInfo(param: CoreV1ApiDeleteCollectionNodeRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNodeWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Node
     * @param param the request object
     */
    public deleteCollectionNode(param: CoreV1ApiDeleteCollectionNodeRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNode(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolume
     * @param param the request object
     */
    public deleteCollectionPersistentVolumeWithHttpInfo(param: CoreV1ApiDeleteCollectionPersistentVolumeRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPersistentVolumeWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PersistentVolume
     * @param param the request object
     */
    public deleteCollectionPersistentVolume(param: CoreV1ApiDeleteCollectionPersistentVolumeRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionPersistentVolume(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a Namespace
     * @param param the request object
     */
    public deleteNamespaceWithHttpInfo(param: CoreV1ApiDeleteNamespaceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespaceWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Namespace
     * @param param the request object
     */
    public deleteNamespace(param: CoreV1ApiDeleteNamespaceRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespace(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ConfigMap
     * @param param the request object
     */
    public deleteNamespacedConfigMapWithHttpInfo(param: CoreV1ApiDeleteNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ConfigMap
     * @param param the request object
     */
    public deleteNamespacedConfigMap(param: CoreV1ApiDeleteNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedConfigMap(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete Endpoints
     * @param param the request object
     */
    public deleteNamespacedEndpointsWithHttpInfo(param: CoreV1ApiDeleteNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete Endpoints
     * @param param the request object
     */
    public deleteNamespacedEndpoints(param: CoreV1ApiDeleteNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedEndpoints(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEventWithHttpInfo(param: CoreV1ApiDeleteNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEvent(param: CoreV1ApiDeleteNamespacedEventRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedEvent(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a LimitRange
     * @param param the request object
     */
    public deleteNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiDeleteNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a LimitRange
     * @param param the request object
     */
    public deleteNamespacedLimitRange(param: CoreV1ApiDeleteNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedLimitRange(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolumeClaim
     * @param param the request object
     */
    public deleteNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.deleteNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolumeClaim
     * @param param the request object
     */
    public deleteNamespacedPersistentVolumeClaim(param: CoreV1ApiDeleteNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.deleteNamespacedPersistentVolumeClaim(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Pod
     * @param param the request object
     */
    public deleteNamespacedPodWithHttpInfo(param: CoreV1ApiDeleteNamespacedPodRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.deleteNamespacedPodWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Pod
     * @param param the request object
     */
    public deleteNamespacedPod(param: CoreV1ApiDeleteNamespacedPodRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.deleteNamespacedPod(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodTemplate
     * @param param the request object
     */
    public deleteNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiDeleteNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.deleteNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodTemplate
     * @param param the request object
     */
    public deleteNamespacedPodTemplate(param: CoreV1ApiDeleteNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<V1PodTemplate> {
        return this.api.deleteNamespacedPodTemplate(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicationController
     * @param param the request object
     */
    public deleteNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiDeleteNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ReplicationController
     * @param param the request object
     */
    public deleteNamespacedReplicationController(param: CoreV1ApiDeleteNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedReplicationController(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceQuota
     * @param param the request object
     */
    public deleteNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiDeleteNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.deleteNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceQuota
     * @param param the request object
     */
    public deleteNamespacedResourceQuota(param: CoreV1ApiDeleteNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.deleteNamespacedResourceQuota(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Secret
     * @param param the request object
     */
    public deleteNamespacedSecretWithHttpInfo(param: CoreV1ApiDeleteNamespacedSecretRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedSecretWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Secret
     * @param param the request object
     */
    public deleteNamespacedSecret(param: CoreV1ApiDeleteNamespacedSecretRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedSecret(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Service
     * @param param the request object
     */
    public deleteNamespacedServiceWithHttpInfo(param: CoreV1ApiDeleteNamespacedServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.deleteNamespacedServiceWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Service
     * @param param the request object
     */
    public deleteNamespacedService(param: CoreV1ApiDeleteNamespacedServiceRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.deleteNamespacedService(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceAccount
     * @param param the request object
     */
    public deleteNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiDeleteNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.deleteNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceAccount
     * @param param the request object
     */
    public deleteNamespacedServiceAccount(param: CoreV1ApiDeleteNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<V1ServiceAccount> {
        return this.api.deleteNamespacedServiceAccount(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Node
     * @param param the request object
     */
    public deleteNodeWithHttpInfo(param: CoreV1ApiDeleteNodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNodeWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Node
     * @param param the request object
     */
    public deleteNode(param: CoreV1ApiDeleteNodeRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNode(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolume
     * @param param the request object
     */
    public deletePersistentVolumeWithHttpInfo(param: CoreV1ApiDeletePersistentVolumeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.deletePersistentVolumeWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PersistentVolume
     * @param param the request object
     */
    public deletePersistentVolume(param: CoreV1ApiDeletePersistentVolumeRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.deletePersistentVolume(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CoreV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CoreV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list objects of kind ComponentStatus
     * @param param the request object
     */
    public listComponentStatusWithHttpInfo(param: CoreV1ApiListComponentStatusRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ComponentStatusList>> {
        return this.api.listComponentStatusWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list objects of kind ComponentStatus
     * @param param the request object
     */
    public listComponentStatus(param: CoreV1ApiListComponentStatusRequest = {}, options?: ConfigurationOptions): Promise<V1ComponentStatusList> {
        return this.api.listComponentStatus(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listConfigMapForAllNamespacesWithHttpInfo(param: CoreV1ApiListConfigMapForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ConfigMapList>> {
        return this.api.listConfigMapForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listConfigMapForAllNamespaces(param: CoreV1ApiListConfigMapForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1ConfigMapList> {
        return this.api.listConfigMapForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listEndpointsForAllNamespacesWithHttpInfo(param: CoreV1ApiListEndpointsForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointsList>> {
        return this.api.listEndpointsForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listEndpointsForAllNamespaces(param: CoreV1ApiListEndpointsForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1EndpointsList> {
        return this.api.listEndpointsForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespacesWithHttpInfo(param: CoreV1ApiListEventForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<CoreV1EventList>> {
        return this.api.listEventForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespaces(param: CoreV1ApiListEventForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<CoreV1EventList> {
        return this.api.listEventForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listLimitRangeForAllNamespacesWithHttpInfo(param: CoreV1ApiListLimitRangeForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1LimitRangeList>> {
        return this.api.listLimitRangeForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listLimitRangeForAllNamespaces(param: CoreV1ApiListLimitRangeForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1LimitRangeList> {
        return this.api.listLimitRangeForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Namespace
     * @param param the request object
     */
    public listNamespaceWithHttpInfo(param: CoreV1ApiListNamespaceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1NamespaceList>> {
        return this.api.listNamespaceWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Namespace
     * @param param the request object
     */
    public listNamespace(param: CoreV1ApiListNamespaceRequest = {}, options?: ConfigurationOptions): Promise<V1NamespaceList> {
        return this.api.listNamespace(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listNamespacedConfigMapWithHttpInfo(param: CoreV1ApiListNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ConfigMapList>> {
        return this.api.listNamespacedConfigMapWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ConfigMap
     * @param param the request object
     */
    public listNamespacedConfigMap(param: CoreV1ApiListNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<V1ConfigMapList> {
        return this.api.listNamespacedConfigMap(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listNamespacedEndpointsWithHttpInfo(param: CoreV1ApiListNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointsList>> {
        return this.api.listNamespacedEndpointsWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Endpoints
     * @param param the request object
     */
    public listNamespacedEndpoints(param: CoreV1ApiListNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<V1EndpointsList> {
        return this.api.listNamespacedEndpoints(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEventWithHttpInfo(param: CoreV1ApiListNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<CoreV1EventList>> {
        return this.api.listNamespacedEventWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEvent(param: CoreV1ApiListNamespacedEventRequest, options?: ConfigurationOptions): Promise<CoreV1EventList> {
        return this.api.listNamespacedEvent(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiListNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1LimitRangeList>> {
        return this.api.listNamespacedLimitRangeWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind LimitRange
     * @param param the request object
     */
    public listNamespacedLimitRange(param: CoreV1ApiListNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<V1LimitRangeList> {
        return this.api.listNamespacedLimitRange(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiListNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaimList>> {
        return this.api.listNamespacedPersistentVolumeClaimWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listNamespacedPersistentVolumeClaim(param: CoreV1ApiListNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaimList> {
        return this.api.listNamespacedPersistentVolumeClaim(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listNamespacedPodWithHttpInfo(param: CoreV1ApiListNamespacedPodRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodList>> {
        return this.api.listNamespacedPodWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listNamespacedPod(param: CoreV1ApiListNamespacedPodRequest, options?: ConfigurationOptions): Promise<V1PodList> {
        return this.api.listNamespacedPod(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiListNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodTemplateList>> {
        return this.api.listNamespacedPodTemplateWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listNamespacedPodTemplate(param: CoreV1ApiListNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<V1PodTemplateList> {
        return this.api.listNamespacedPodTemplate(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiListNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationControllerList>> {
        return this.api.listNamespacedReplicationControllerWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listNamespacedReplicationController(param: CoreV1ApiListNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<V1ReplicationControllerList> {
        return this.api.listNamespacedReplicationController(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiListNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuotaList>> {
        return this.api.listNamespacedResourceQuotaWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listNamespacedResourceQuota(param: CoreV1ApiListNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<V1ResourceQuotaList> {
        return this.api.listNamespacedResourceQuota(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listNamespacedSecretWithHttpInfo(param: CoreV1ApiListNamespacedSecretRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1SecretList>> {
        return this.api.listNamespacedSecretWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listNamespacedSecret(param: CoreV1ApiListNamespacedSecretRequest, options?: ConfigurationOptions): Promise<V1SecretList> {
        return this.api.listNamespacedSecret(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listNamespacedServiceWithHttpInfo(param: CoreV1ApiListNamespacedServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceList>> {
        return this.api.listNamespacedServiceWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listNamespacedService(param: CoreV1ApiListNamespacedServiceRequest, options?: ConfigurationOptions): Promise<V1ServiceList> {
        return this.api.listNamespacedService(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiListNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceAccountList>> {
        return this.api.listNamespacedServiceAccountWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listNamespacedServiceAccount(param: CoreV1ApiListNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<V1ServiceAccountList> {
        return this.api.listNamespacedServiceAccount(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Node
     * @param param the request object
     */
    public listNodeWithHttpInfo(param: CoreV1ApiListNodeRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1NodeList>> {
        return this.api.listNodeWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Node
     * @param param the request object
     */
    public listNode(param: CoreV1ApiListNodeRequest = {}, options?: ConfigurationOptions): Promise<V1NodeList> {
        return this.api.listNode(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolume
     * @param param the request object
     */
    public listPersistentVolumeWithHttpInfo(param: CoreV1ApiListPersistentVolumeRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeList>> {
        return this.api.listPersistentVolumeWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolume
     * @param param the request object
     */
    public listPersistentVolume(param: CoreV1ApiListPersistentVolumeRequest = {}, options?: ConfigurationOptions): Promise<V1PersistentVolumeList> {
        return this.api.listPersistentVolume(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listPersistentVolumeClaimForAllNamespacesWithHttpInfo(param: CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaimList>> {
        return this.api.listPersistentVolumeClaimForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     * @param param the request object
     */
    public listPersistentVolumeClaimForAllNamespaces(param: CoreV1ApiListPersistentVolumeClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaimList> {
        return this.api.listPersistentVolumeClaimForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listPodForAllNamespacesWithHttpInfo(param: CoreV1ApiListPodForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1PodList>> {
        return this.api.listPodForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Pod
     * @param param the request object
     */
    public listPodForAllNamespaces(param: CoreV1ApiListPodForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1PodList> {
        return this.api.listPodForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listPodTemplateForAllNamespacesWithHttpInfo(param: CoreV1ApiListPodTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1PodTemplateList>> {
        return this.api.listPodTemplateForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodTemplate
     * @param param the request object
     */
    public listPodTemplateForAllNamespaces(param: CoreV1ApiListPodTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1PodTemplateList> {
        return this.api.listPodTemplateForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listReplicationControllerForAllNamespacesWithHttpInfo(param: CoreV1ApiListReplicationControllerForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationControllerList>> {
        return this.api.listReplicationControllerForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ReplicationController
     * @param param the request object
     */
    public listReplicationControllerForAllNamespaces(param: CoreV1ApiListReplicationControllerForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1ReplicationControllerList> {
        return this.api.listReplicationControllerForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listResourceQuotaForAllNamespacesWithHttpInfo(param: CoreV1ApiListResourceQuotaForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuotaList>> {
        return this.api.listResourceQuotaForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceQuota
     * @param param the request object
     */
    public listResourceQuotaForAllNamespaces(param: CoreV1ApiListResourceQuotaForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1ResourceQuotaList> {
        return this.api.listResourceQuotaForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listSecretForAllNamespacesWithHttpInfo(param: CoreV1ApiListSecretForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1SecretList>> {
        return this.api.listSecretForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Secret
     * @param param the request object
     */
    public listSecretForAllNamespaces(param: CoreV1ApiListSecretForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1SecretList> {
        return this.api.listSecretForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listServiceAccountForAllNamespacesWithHttpInfo(param: CoreV1ApiListServiceAccountForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceAccountList>> {
        return this.api.listServiceAccountForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceAccount
     * @param param the request object
     */
    public listServiceAccountForAllNamespaces(param: CoreV1ApiListServiceAccountForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1ServiceAccountList> {
        return this.api.listServiceAccountForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listServiceForAllNamespacesWithHttpInfo(param: CoreV1ApiListServiceForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceList>> {
        return this.api.listServiceForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Service
     * @param param the request object
     */
    public listServiceForAllNamespaces(param: CoreV1ApiListServiceForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1ServiceList> {
        return this.api.listServiceForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified Namespace
     * @param param the request object
     */
    public patchNamespaceWithHttpInfo(param: CoreV1ApiPatchNamespaceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.patchNamespaceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Namespace
     * @param param the request object
     */
    public patchNamespace(param: CoreV1ApiPatchNamespaceRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.patchNamespace(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Namespace
     * @param param the request object
     */
    public patchNamespaceStatusWithHttpInfo(param: CoreV1ApiPatchNamespaceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.patchNamespaceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Namespace
     * @param param the request object
     */
    public patchNamespaceStatus(param: CoreV1ApiPatchNamespaceStatusRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.patchNamespaceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ConfigMap
     * @param param the request object
     */
    public patchNamespacedConfigMapWithHttpInfo(param: CoreV1ApiPatchNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.patchNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ConfigMap
     * @param param the request object
     */
    public patchNamespacedConfigMap(param: CoreV1ApiPatchNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<V1ConfigMap> {
        return this.api.patchNamespacedConfigMap(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Endpoints
     * @param param the request object
     */
    public patchNamespacedEndpointsWithHttpInfo(param: CoreV1ApiPatchNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Endpoints>> {
        return this.api.patchNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Endpoints
     * @param param the request object
     */
    public patchNamespacedEndpoints(param: CoreV1ApiPatchNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<V1Endpoints> {
        return this.api.patchNamespacedEndpoints(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEventWithHttpInfo(param: CoreV1ApiPatchNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<CoreV1Event>> {
        return this.api.patchNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEvent(param: CoreV1ApiPatchNamespacedEventRequest, options?: ConfigurationOptions): Promise<CoreV1Event> {
        return this.api.patchNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified LimitRange
     * @param param the request object
     */
    public patchNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiPatchNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1LimitRange>> {
        return this.api.patchNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified LimitRange
     * @param param the request object
     */
    public patchNamespacedLimitRange(param: CoreV1ApiPatchNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<V1LimitRange> {
        return this.api.patchNamespacedLimitRange(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.patchNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaim(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.patchNamespacedPersistentVolumeClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaimStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.patchNamespacedPersistentVolumeClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public patchNamespacedPersistentVolumeClaimStatus(param: CoreV1ApiPatchNamespacedPersistentVolumeClaimStatusRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.patchNamespacedPersistentVolumeClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodWithHttpInfo(param: CoreV1ApiPatchNamespacedPodRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.patchNamespacedPodWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Pod
     * @param param the request object
     */
    public patchNamespacedPod(param: CoreV1ApiPatchNamespacedPodRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.patchNamespacedPod(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodEphemeralcontainersWithHttpInfo(param: CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.patchNamespacedPodEphemeralcontainersWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodEphemeralcontainers(param: CoreV1ApiPatchNamespacedPodEphemeralcontainersRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.patchNamespacedPodEphemeralcontainers(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update resize of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodResizeWithHttpInfo(param: CoreV1ApiPatchNamespacedPodResizeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.patchNamespacedPodResizeWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update resize of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodResize(param: CoreV1ApiPatchNamespacedPodResizeRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.patchNamespacedPodResize(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedPodStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.patchNamespacedPodStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Pod
     * @param param the request object
     */
    public patchNamespacedPodStatus(param: CoreV1ApiPatchNamespacedPodStatusRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.patchNamespacedPodStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodTemplate
     * @param param the request object
     */
    public patchNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiPatchNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.patchNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodTemplate
     * @param param the request object
     */
    public patchNamespacedPodTemplate(param: CoreV1ApiPatchNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<V1PodTemplate> {
        return this.api.patchNamespacedPodTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiPatchNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.patchNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationController(param: CoreV1ApiPatchNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<V1ReplicationController> {
        return this.api.patchNamespacedReplicationController(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerScaleWithHttpInfo(param: CoreV1ApiPatchNamespacedReplicationControllerScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.patchNamespacedReplicationControllerScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerScale(param: CoreV1ApiPatchNamespacedReplicationControllerScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.patchNamespacedReplicationControllerScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedReplicationControllerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.patchNamespacedReplicationControllerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ReplicationController
     * @param param the request object
     */
    public patchNamespacedReplicationControllerStatus(param: CoreV1ApiPatchNamespacedReplicationControllerStatusRequest, options?: ConfigurationOptions): Promise<V1ReplicationController> {
        return this.api.patchNamespacedReplicationControllerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiPatchNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.patchNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuota(param: CoreV1ApiPatchNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.patchNamespacedResourceQuota(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuotaStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedResourceQuotaStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.patchNamespacedResourceQuotaStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceQuota
     * @param param the request object
     */
    public patchNamespacedResourceQuotaStatus(param: CoreV1ApiPatchNamespacedResourceQuotaStatusRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.patchNamespacedResourceQuotaStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Secret
     * @param param the request object
     */
    public patchNamespacedSecretWithHttpInfo(param: CoreV1ApiPatchNamespacedSecretRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Secret>> {
        return this.api.patchNamespacedSecretWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Secret
     * @param param the request object
     */
    public patchNamespacedSecret(param: CoreV1ApiPatchNamespacedSecretRequest, options?: ConfigurationOptions): Promise<V1Secret> {
        return this.api.patchNamespacedSecret(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Service
     * @param param the request object
     */
    public patchNamespacedServiceWithHttpInfo(param: CoreV1ApiPatchNamespacedServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.patchNamespacedServiceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Service
     * @param param the request object
     */
    public patchNamespacedService(param: CoreV1ApiPatchNamespacedServiceRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.patchNamespacedService(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceAccount
     * @param param the request object
     */
    public patchNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiPatchNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.patchNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceAccount
     * @param param the request object
     */
    public patchNamespacedServiceAccount(param: CoreV1ApiPatchNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<V1ServiceAccount> {
        return this.api.patchNamespacedServiceAccount(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Service
     * @param param the request object
     */
    public patchNamespacedServiceStatusWithHttpInfo(param: CoreV1ApiPatchNamespacedServiceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.patchNamespacedServiceStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Service
     * @param param the request object
     */
    public patchNamespacedServiceStatus(param: CoreV1ApiPatchNamespacedServiceStatusRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.patchNamespacedServiceStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Node
     * @param param the request object
     */
    public patchNodeWithHttpInfo(param: CoreV1ApiPatchNodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Node>> {
        return this.api.patchNodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Node
     * @param param the request object
     */
    public patchNode(param: CoreV1ApiPatchNodeRequest, options?: ConfigurationOptions): Promise<V1Node> {
        return this.api.patchNode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Node
     * @param param the request object
     */
    public patchNodeStatusWithHttpInfo(param: CoreV1ApiPatchNodeStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Node>> {
        return this.api.patchNodeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Node
     * @param param the request object
     */
    public patchNodeStatus(param: CoreV1ApiPatchNodeStatusRequest, options?: ConfigurationOptions): Promise<V1Node> {
        return this.api.patchNodeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolumeWithHttpInfo(param: CoreV1ApiPatchPersistentVolumeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.patchPersistentVolumeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolume(param: CoreV1ApiPatchPersistentVolumeRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.patchPersistentVolume(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolumeStatusWithHttpInfo(param: CoreV1ApiPatchPersistentVolumeStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.patchPersistentVolumeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PersistentVolume
     * @param param the request object
     */
    public patchPersistentVolumeStatus(param: CoreV1ApiPatchPersistentVolumeStatusRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.patchPersistentVolumeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified ComponentStatus
     * @param param the request object
     */
    public readComponentStatusWithHttpInfo(param: CoreV1ApiReadComponentStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ComponentStatus>> {
        return this.api.readComponentStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ComponentStatus
     * @param param the request object
     */
    public readComponentStatus(param: CoreV1ApiReadComponentStatusRequest, options?: ConfigurationOptions): Promise<V1ComponentStatus> {
        return this.api.readComponentStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Namespace
     * @param param the request object
     */
    public readNamespaceWithHttpInfo(param: CoreV1ApiReadNamespaceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.readNamespaceWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Namespace
     * @param param the request object
     */
    public readNamespace(param: CoreV1ApiReadNamespaceRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.readNamespace(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Namespace
     * @param param the request object
     */
    public readNamespaceStatusWithHttpInfo(param: CoreV1ApiReadNamespaceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.readNamespaceStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Namespace
     * @param param the request object
     */
    public readNamespaceStatus(param: CoreV1ApiReadNamespaceStatusRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.readNamespaceStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ConfigMap
     * @param param the request object
     */
    public readNamespacedConfigMapWithHttpInfo(param: CoreV1ApiReadNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.readNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ConfigMap
     * @param param the request object
     */
    public readNamespacedConfigMap(param: CoreV1ApiReadNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<V1ConfigMap> {
        return this.api.readNamespacedConfigMap(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Endpoints
     * @param param the request object
     */
    public readNamespacedEndpointsWithHttpInfo(param: CoreV1ApiReadNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Endpoints>> {
        return this.api.readNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Endpoints
     * @param param the request object
     */
    public readNamespacedEndpoints(param: CoreV1ApiReadNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<V1Endpoints> {
        return this.api.readNamespacedEndpoints(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEventWithHttpInfo(param: CoreV1ApiReadNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<CoreV1Event>> {
        return this.api.readNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEvent(param: CoreV1ApiReadNamespacedEventRequest, options?: ConfigurationOptions): Promise<CoreV1Event> {
        return this.api.readNamespacedEvent(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified LimitRange
     * @param param the request object
     */
    public readNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiReadNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1LimitRange>> {
        return this.api.readNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified LimitRange
     * @param param the request object
     */
    public readNamespacedLimitRange(param: CoreV1ApiReadNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<V1LimitRange> {
        return this.api.readNamespacedLimitRange(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiReadNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.readNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaim(param: CoreV1ApiReadNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.readNamespacedPersistentVolumeClaim(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaimStatusWithHttpInfo(param: CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.readNamespacedPersistentVolumeClaimStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public readNamespacedPersistentVolumeClaimStatus(param: CoreV1ApiReadNamespacedPersistentVolumeClaimStatusRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.readNamespacedPersistentVolumeClaimStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Pod
     * @param param the request object
     */
    public readNamespacedPodWithHttpInfo(param: CoreV1ApiReadNamespacedPodRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.readNamespacedPodWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Pod
     * @param param the request object
     */
    public readNamespacedPod(param: CoreV1ApiReadNamespacedPodRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.readNamespacedPod(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodEphemeralcontainersWithHttpInfo(param: CoreV1ApiReadNamespacedPodEphemeralcontainersRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.readNamespacedPodEphemeralcontainersWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodEphemeralcontainers(param: CoreV1ApiReadNamespacedPodEphemeralcontainersRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.readNamespacedPodEphemeralcontainers(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read log of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodLogWithHttpInfo(param: CoreV1ApiReadNamespacedPodLogRequest, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.readNamespacedPodLogWithHttpInfo(param.name, param.namespace, param.container, param.follow, param.insecureSkipTLSVerifyBackend, param.limitBytes, param.pretty, param.previous, param.sinceSeconds, param.stream, param.tailLines, param.timestamps,  options).toPromise();
    }

    /**
     * read log of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodLog(param: CoreV1ApiReadNamespacedPodLogRequest, options?: ConfigurationOptions): Promise<string> {
        return this.api.readNamespacedPodLog(param.name, param.namespace, param.container, param.follow, param.insecureSkipTLSVerifyBackend, param.limitBytes, param.pretty, param.previous, param.sinceSeconds, param.stream, param.tailLines, param.timestamps,  options).toPromise();
    }

    /**
     * read resize of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodResizeWithHttpInfo(param: CoreV1ApiReadNamespacedPodResizeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.readNamespacedPodResizeWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read resize of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodResize(param: CoreV1ApiReadNamespacedPodResizeRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.readNamespacedPodResize(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodStatusWithHttpInfo(param: CoreV1ApiReadNamespacedPodStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.readNamespacedPodStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Pod
     * @param param the request object
     */
    public readNamespacedPodStatus(param: CoreV1ApiReadNamespacedPodStatusRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.readNamespacedPodStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodTemplate
     * @param param the request object
     */
    public readNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiReadNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.readNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodTemplate
     * @param param the request object
     */
    public readNamespacedPodTemplate(param: CoreV1ApiReadNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<V1PodTemplate> {
        return this.api.readNamespacedPodTemplate(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiReadNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.readNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationController(param: CoreV1ApiReadNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<V1ReplicationController> {
        return this.api.readNamespacedReplicationController(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerScaleWithHttpInfo(param: CoreV1ApiReadNamespacedReplicationControllerScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.readNamespacedReplicationControllerScaleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read scale of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerScale(param: CoreV1ApiReadNamespacedReplicationControllerScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.readNamespacedReplicationControllerScale(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerStatusWithHttpInfo(param: CoreV1ApiReadNamespacedReplicationControllerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.readNamespacedReplicationControllerStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ReplicationController
     * @param param the request object
     */
    public readNamespacedReplicationControllerStatus(param: CoreV1ApiReadNamespacedReplicationControllerStatusRequest, options?: ConfigurationOptions): Promise<V1ReplicationController> {
        return this.api.readNamespacedReplicationControllerStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiReadNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.readNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuota(param: CoreV1ApiReadNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.readNamespacedResourceQuota(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuotaStatusWithHttpInfo(param: CoreV1ApiReadNamespacedResourceQuotaStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.readNamespacedResourceQuotaStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceQuota
     * @param param the request object
     */
    public readNamespacedResourceQuotaStatus(param: CoreV1ApiReadNamespacedResourceQuotaStatusRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.readNamespacedResourceQuotaStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Secret
     * @param param the request object
     */
    public readNamespacedSecretWithHttpInfo(param: CoreV1ApiReadNamespacedSecretRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Secret>> {
        return this.api.readNamespacedSecretWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Secret
     * @param param the request object
     */
    public readNamespacedSecret(param: CoreV1ApiReadNamespacedSecretRequest, options?: ConfigurationOptions): Promise<V1Secret> {
        return this.api.readNamespacedSecret(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Service
     * @param param the request object
     */
    public readNamespacedServiceWithHttpInfo(param: CoreV1ApiReadNamespacedServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.readNamespacedServiceWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Service
     * @param param the request object
     */
    public readNamespacedService(param: CoreV1ApiReadNamespacedServiceRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.readNamespacedService(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceAccount
     * @param param the request object
     */
    public readNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiReadNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.readNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceAccount
     * @param param the request object
     */
    public readNamespacedServiceAccount(param: CoreV1ApiReadNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<V1ServiceAccount> {
        return this.api.readNamespacedServiceAccount(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Service
     * @param param the request object
     */
    public readNamespacedServiceStatusWithHttpInfo(param: CoreV1ApiReadNamespacedServiceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.readNamespacedServiceStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Service
     * @param param the request object
     */
    public readNamespacedServiceStatus(param: CoreV1ApiReadNamespacedServiceStatusRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.readNamespacedServiceStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Node
     * @param param the request object
     */
    public readNodeWithHttpInfo(param: CoreV1ApiReadNodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Node>> {
        return this.api.readNodeWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Node
     * @param param the request object
     */
    public readNode(param: CoreV1ApiReadNodeRequest, options?: ConfigurationOptions): Promise<V1Node> {
        return this.api.readNode(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Node
     * @param param the request object
     */
    public readNodeStatusWithHttpInfo(param: CoreV1ApiReadNodeStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Node>> {
        return this.api.readNodeStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Node
     * @param param the request object
     */
    public readNodeStatus(param: CoreV1ApiReadNodeStatusRequest, options?: ConfigurationOptions): Promise<V1Node> {
        return this.api.readNodeStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolumeWithHttpInfo(param: CoreV1ApiReadPersistentVolumeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.readPersistentVolumeWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolume(param: CoreV1ApiReadPersistentVolumeRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.readPersistentVolume(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolumeStatusWithHttpInfo(param: CoreV1ApiReadPersistentVolumeStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.readPersistentVolumeStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PersistentVolume
     * @param param the request object
     */
    public readPersistentVolumeStatus(param: CoreV1ApiReadPersistentVolumeStatusRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.readPersistentVolumeStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceWithHttpInfo(param: CoreV1ApiReplaceNamespaceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.replaceNamespaceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Namespace
     * @param param the request object
     */
    public replaceNamespace(param: CoreV1ApiReplaceNamespaceRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.replaceNamespace(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace finalize of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceFinalizeWithHttpInfo(param: CoreV1ApiReplaceNamespaceFinalizeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.replaceNamespaceFinalizeWithHttpInfo(param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * replace finalize of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceFinalize(param: CoreV1ApiReplaceNamespaceFinalizeRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.replaceNamespaceFinalize(param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.pretty,  options).toPromise();
    }

    /**
     * replace status of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceStatusWithHttpInfo(param: CoreV1ApiReplaceNamespaceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Namespace>> {
        return this.api.replaceNamespaceStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Namespace
     * @param param the request object
     */
    public replaceNamespaceStatus(param: CoreV1ApiReplaceNamespaceStatusRequest, options?: ConfigurationOptions): Promise<V1Namespace> {
        return this.api.replaceNamespaceStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ConfigMap
     * @param param the request object
     */
    public replaceNamespacedConfigMapWithHttpInfo(param: CoreV1ApiReplaceNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ConfigMap>> {
        return this.api.replaceNamespacedConfigMapWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ConfigMap
     * @param param the request object
     */
    public replaceNamespacedConfigMap(param: CoreV1ApiReplaceNamespacedConfigMapRequest, options?: ConfigurationOptions): Promise<V1ConfigMap> {
        return this.api.replaceNamespacedConfigMap(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Endpoints
     * @param param the request object
     */
    public replaceNamespacedEndpointsWithHttpInfo(param: CoreV1ApiReplaceNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Endpoints>> {
        return this.api.replaceNamespacedEndpointsWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Endpoints
     * @param param the request object
     */
    public replaceNamespacedEndpoints(param: CoreV1ApiReplaceNamespacedEndpointsRequest, options?: ConfigurationOptions): Promise<V1Endpoints> {
        return this.api.replaceNamespacedEndpoints(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEventWithHttpInfo(param: CoreV1ApiReplaceNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<CoreV1Event>> {
        return this.api.replaceNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEvent(param: CoreV1ApiReplaceNamespacedEventRequest, options?: ConfigurationOptions): Promise<CoreV1Event> {
        return this.api.replaceNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified LimitRange
     * @param param the request object
     */
    public replaceNamespacedLimitRangeWithHttpInfo(param: CoreV1ApiReplaceNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1LimitRange>> {
        return this.api.replaceNamespacedLimitRangeWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified LimitRange
     * @param param the request object
     */
    public replaceNamespacedLimitRange(param: CoreV1ApiReplaceNamespacedLimitRangeRequest, options?: ConfigurationOptions): Promise<V1LimitRange> {
        return this.api.replaceNamespacedLimitRange(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaimWithHttpInfo(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.replaceNamespacedPersistentVolumeClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaim(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.replaceNamespacedPersistentVolumeClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaimStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolumeClaim>> {
        return this.api.replaceNamespacedPersistentVolumeClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     * @param param the request object
     */
    public replaceNamespacedPersistentVolumeClaimStatus(param: CoreV1ApiReplaceNamespacedPersistentVolumeClaimStatusRequest, options?: ConfigurationOptions): Promise<V1PersistentVolumeClaim> {
        return this.api.replaceNamespacedPersistentVolumeClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.replaceNamespacedPodWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPod(param: CoreV1ApiReplaceNamespacedPodRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.replaceNamespacedPod(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodEphemeralcontainersWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.replaceNamespacedPodEphemeralcontainersWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace ephemeralcontainers of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodEphemeralcontainers(param: CoreV1ApiReplaceNamespacedPodEphemeralcontainersRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.replaceNamespacedPodEphemeralcontainers(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace resize of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodResizeWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodResizeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.replaceNamespacedPodResizeWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace resize of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodResize(param: CoreV1ApiReplaceNamespacedPodResizeRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.replaceNamespacedPodResize(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Pod>> {
        return this.api.replaceNamespacedPodStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Pod
     * @param param the request object
     */
    public replaceNamespacedPodStatus(param: CoreV1ApiReplaceNamespacedPodStatusRequest, options?: ConfigurationOptions): Promise<V1Pod> {
        return this.api.replaceNamespacedPodStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PodTemplate
     * @param param the request object
     */
    public replaceNamespacedPodTemplateWithHttpInfo(param: CoreV1ApiReplaceNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodTemplate>> {
        return this.api.replaceNamespacedPodTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PodTemplate
     * @param param the request object
     */
    public replaceNamespacedPodTemplate(param: CoreV1ApiReplaceNamespacedPodTemplateRequest, options?: ConfigurationOptions): Promise<V1PodTemplate> {
        return this.api.replaceNamespacedPodTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerWithHttpInfo(param: CoreV1ApiReplaceNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.replaceNamespacedReplicationControllerWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationController(param: CoreV1ApiReplaceNamespacedReplicationControllerRequest, options?: ConfigurationOptions): Promise<V1ReplicationController> {
        return this.api.replaceNamespacedReplicationController(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerScaleWithHttpInfo(param: CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Scale>> {
        return this.api.replaceNamespacedReplicationControllerScaleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerScale(param: CoreV1ApiReplaceNamespacedReplicationControllerScaleRequest, options?: ConfigurationOptions): Promise<V1Scale> {
        return this.api.replaceNamespacedReplicationControllerScale(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ReplicationController>> {
        return this.api.replaceNamespacedReplicationControllerStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ReplicationController
     * @param param the request object
     */
    public replaceNamespacedReplicationControllerStatus(param: CoreV1ApiReplaceNamespacedReplicationControllerStatusRequest, options?: ConfigurationOptions): Promise<V1ReplicationController> {
        return this.api.replaceNamespacedReplicationControllerStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuotaWithHttpInfo(param: CoreV1ApiReplaceNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.replaceNamespacedResourceQuotaWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuota(param: CoreV1ApiReplaceNamespacedResourceQuotaRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.replaceNamespacedResourceQuota(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuotaStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ResourceQuota>> {
        return this.api.replaceNamespacedResourceQuotaStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceQuota
     * @param param the request object
     */
    public replaceNamespacedResourceQuotaStatus(param: CoreV1ApiReplaceNamespacedResourceQuotaStatusRequest, options?: ConfigurationOptions): Promise<V1ResourceQuota> {
        return this.api.replaceNamespacedResourceQuotaStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Secret
     * @param param the request object
     */
    public replaceNamespacedSecretWithHttpInfo(param: CoreV1ApiReplaceNamespacedSecretRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Secret>> {
        return this.api.replaceNamespacedSecretWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Secret
     * @param param the request object
     */
    public replaceNamespacedSecret(param: CoreV1ApiReplaceNamespacedSecretRequest, options?: ConfigurationOptions): Promise<V1Secret> {
        return this.api.replaceNamespacedSecret(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Service
     * @param param the request object
     */
    public replaceNamespacedServiceWithHttpInfo(param: CoreV1ApiReplaceNamespacedServiceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.replaceNamespacedServiceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Service
     * @param param the request object
     */
    public replaceNamespacedService(param: CoreV1ApiReplaceNamespacedServiceRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.replaceNamespacedService(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ServiceAccount
     * @param param the request object
     */
    public replaceNamespacedServiceAccountWithHttpInfo(param: CoreV1ApiReplaceNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceAccount>> {
        return this.api.replaceNamespacedServiceAccountWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ServiceAccount
     * @param param the request object
     */
    public replaceNamespacedServiceAccount(param: CoreV1ApiReplaceNamespacedServiceAccountRequest, options?: ConfigurationOptions): Promise<V1ServiceAccount> {
        return this.api.replaceNamespacedServiceAccount(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Service
     * @param param the request object
     */
    public replaceNamespacedServiceStatusWithHttpInfo(param: CoreV1ApiReplaceNamespacedServiceStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Service>> {
        return this.api.replaceNamespacedServiceStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Service
     * @param param the request object
     */
    public replaceNamespacedServiceStatus(param: CoreV1ApiReplaceNamespacedServiceStatusRequest, options?: ConfigurationOptions): Promise<V1Service> {
        return this.api.replaceNamespacedServiceStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Node
     * @param param the request object
     */
    public replaceNodeWithHttpInfo(param: CoreV1ApiReplaceNodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Node>> {
        return this.api.replaceNodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Node
     * @param param the request object
     */
    public replaceNode(param: CoreV1ApiReplaceNodeRequest, options?: ConfigurationOptions): Promise<V1Node> {
        return this.api.replaceNode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Node
     * @param param the request object
     */
    public replaceNodeStatusWithHttpInfo(param: CoreV1ApiReplaceNodeStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Node>> {
        return this.api.replaceNodeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Node
     * @param param the request object
     */
    public replaceNodeStatus(param: CoreV1ApiReplaceNodeStatusRequest, options?: ConfigurationOptions): Promise<V1Node> {
        return this.api.replaceNodeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolumeWithHttpInfo(param: CoreV1ApiReplacePersistentVolumeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.replacePersistentVolumeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolume(param: CoreV1ApiReplacePersistentVolumeRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.replacePersistentVolume(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolumeStatusWithHttpInfo(param: CoreV1ApiReplacePersistentVolumeStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PersistentVolume>> {
        return this.api.replacePersistentVolumeStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PersistentVolume
     * @param param the request object
     */
    public replacePersistentVolumeStatus(param: CoreV1ApiReplacePersistentVolumeStatusRequest, options?: ConfigurationOptions): Promise<V1PersistentVolume> {
        return this.api.replacePersistentVolumeStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableCustomObjectsApi } from "./ObservableAPI.js";
import { CustomObjectsApiRequestFactory, CustomObjectsApiResponseProcessor} from "../apis/CustomObjectsApi.js";

export interface CustomObjectsApiCreateClusterCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    plural: string
    /**
     * The JSON schema of the Resource to create.
     * @type any
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateClusterCustomObject
     */
    fieldValidation?: string
}

export interface CustomObjectsApiCreateNamespacedCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    namespace: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    plural: string
    /**
     * The JSON schema of the Resource to create.
     * @type any
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApicreateNamespacedCustomObject
     */
    fieldValidation?: string
}

export interface CustomObjectsApiDeleteClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    name: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    dryRun?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteClusterCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiDeleteCollectionClusterCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    pretty?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    labelSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    dryRun?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteCollectionClusterCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiDeleteCollectionNamespacedCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    namespace: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    pretty?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    labelSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    fieldSelector?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteCollectionNamespacedCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiDeleteNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    name: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    gracePeriodSeconds?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    propagationPolicy?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    dryRun?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof CustomObjectsApideleteNamespacedCustomObject
     */
    body?: V1DeleteOptions
}

export interface CustomObjectsApiGetAPIResourcesRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetAPIResources
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetAPIResources
     */
    version: string
}

export interface CustomObjectsApiGetClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObject
     */
    name: string
}

export interface CustomObjectsApiGetClusterCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectScale
     */
    name: string
}

export interface CustomObjectsApiGetClusterCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetClusterCustomObjectStatus
     */
    name: string
}

export interface CustomObjectsApiGetNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObject
     */
    name: string
}

export interface CustomObjectsApiGetNamespacedCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectScale
     */
    name: string
}

export interface CustomObjectsApiGetNamespacedCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApigetNamespacedCustomObjectStatus
     */
    name: string
}

export interface CustomObjectsApiListClusterCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    limit?: number
    /**
     * When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApilistClusterCustomObject
     */
    watch?: boolean
}

export interface CustomObjectsApiListCustomObjectForAllNamespacesRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    version: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    limit?: number
    /**
     * When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApilistCustomObjectForAllNamespaces
     */
    watch?: boolean
}

export interface CustomObjectsApiListNamespacedCustomObjectRequest {
    /**
     * The custom resource\&#39;s group name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    group: string
    /**
     * The custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    namespace: string
    /**
     * The custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    plural: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    limit?: number
    /**
     * When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    resourceVersionMatch?: string
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApilistNamespacedCustomObject
     */
    watch?: boolean
}

export interface CustomObjectsApiPatchClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to patch.
     * @type any
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApipatchClusterCustomObject
     */
    force?: boolean
}

export interface CustomObjectsApiPatchClusterCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApipatchClusterCustomObjectScale
     */
    force?: boolean
}

export interface CustomObjectsApiPatchClusterCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApipatchClusterCustomObjectStatus
     */
    force?: boolean
}

export interface CustomObjectsApiPatchNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to patch.
     * @type any
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApipatchNamespacedCustomObject
     */
    force?: boolean
}

export interface CustomObjectsApiPatchNamespacedCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApipatchNamespacedCustomObjectScale
     */
    force?: boolean
}

export interface CustomObjectsApiPatchNamespacedCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof CustomObjectsApipatchNamespacedCustomObjectStatus
     */
    force?: boolean
}

export interface CustomObjectsApiReplaceClusterCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    version: string
    /**
     * the custom object\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to replace.
     * @type any
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObject
     */
    fieldValidation?: string
}

export interface CustomObjectsApiReplaceClusterCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectScale
     */
    fieldValidation?: string
}

export interface CustomObjectsApiReplaceClusterCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    version: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceClusterCustomObjectStatus
     */
    fieldValidation?: string
}

export interface CustomObjectsApiReplaceNamespacedCustomObjectRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    name: string
    /**
     * The JSON schema of the Resource to replace.
     * @type any
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObject
     */
    fieldValidation?: string
}

export interface CustomObjectsApiReplaceNamespacedCustomObjectScaleRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectScale
     */
    fieldValidation?: string
}

export interface CustomObjectsApiReplaceNamespacedCustomObjectStatusRequest {
    /**
     * the custom resource\&#39;s group
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    group: string
    /**
     * the custom resource\&#39;s version
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    version: string
    /**
     * The custom resource\&#39;s namespace
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    namespace: string
    /**
     * the custom resource\&#39;s plural name. For TPRs this would be lowercase plural kind.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    plural: string
    /**
     * the custom object\&#39;s name
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    body: any
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered. (optional)
     * Defaults to: undefined
     * @type string
     * @memberof CustomObjectsApireplaceNamespacedCustomObjectStatus
     */
    fieldValidation?: string
}

export class ObjectCustomObjectsApi {
    private api: ObservableCustomObjectsApi

    public constructor(configuration: Configuration, requestFactory?: CustomObjectsApiRequestFactory, responseProcessor?: CustomObjectsApiResponseProcessor) {
        this.api = new ObservableCustomObjectsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * Creates a cluster scoped Custom object
     * @param param the request object
     */
    public createClusterCustomObjectWithHttpInfo(param: CustomObjectsApiCreateClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.createClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * Creates a cluster scoped Custom object
     * @param param the request object
     */
    public createClusterCustomObject(param: CustomObjectsApiCreateClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.createClusterCustomObject(param.group, param.version, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * Creates a namespace scoped Custom object
     * @param param the request object
     */
    public createNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiCreateNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.createNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * Creates a namespace scoped Custom object
     * @param param the request object
     */
    public createNamespacedCustomObject(param: CustomObjectsApiCreateNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.createNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * Deletes the specified cluster scoped custom object
     * @param param the request object
     */
    public deleteClusterCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.deleteClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Deletes the specified cluster scoped custom object
     * @param param the request object
     */
    public deleteClusterCustomObject(param: CustomObjectsApiDeleteClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.deleteClusterCustomObject(param.group, param.version, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Delete collection of cluster scoped custom objects
     * @param param the request object
     */
    public deleteCollectionClusterCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteCollectionClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.deleteCollectionClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.pretty, param.labelSelector, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Delete collection of cluster scoped custom objects
     * @param param the request object
     */
    public deleteCollectionClusterCustomObject(param: CustomObjectsApiDeleteCollectionClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.deleteCollectionClusterCustomObject(param.group, param.version, param.plural, param.pretty, param.labelSelector, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Delete collection of namespace scoped custom objects
     * @param param the request object
     */
    public deleteCollectionNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteCollectionNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.deleteCollectionNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.pretty, param.labelSelector, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.fieldSelector, param.body,  options).toPromise();
    }

    /**
     * Delete collection of namespace scoped custom objects
     * @param param the request object
     */
    public deleteCollectionNamespacedCustomObject(param: CustomObjectsApiDeleteCollectionNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.deleteCollectionNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.pretty, param.labelSelector, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.fieldSelector, param.body,  options).toPromise();
    }

    /**
     * Deletes the specified namespace scoped custom object
     * @param param the request object
     */
    public deleteNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiDeleteNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.deleteNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * Deletes the specified namespace scoped custom object
     * @param param the request object
     */
    public deleteNamespacedCustomObject(param: CustomObjectsApiDeleteNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.deleteNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name, param.gracePeriodSeconds, param.orphanDependents, param.propagationPolicy, param.dryRun, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: CustomObjectsApiGetAPIResourcesRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo(param.group, param.version,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: CustomObjectsApiGetAPIResourcesRequest, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources(param.group, param.version,  options).toPromise();
    }

    /**
     * Returns a cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObjectWithHttpInfo(param: CustomObjectsApiGetClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.getClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * Returns a cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObject(param: CustomObjectsApiGetClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.getClusterCustomObject(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified custom object
     * @param param the request object
     */
    public getClusterCustomObjectScaleWithHttpInfo(param: CustomObjectsApiGetClusterCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.getClusterCustomObjectScaleWithHttpInfo(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified custom object
     * @param param the request object
     */
    public getClusterCustomObjectScale(param: CustomObjectsApiGetClusterCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.getClusterCustomObjectScale(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObjectStatusWithHttpInfo(param: CustomObjectsApiGetClusterCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.getClusterCustomObjectStatusWithHttpInfo(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified cluster scoped custom object
     * @param param the request object
     */
    public getClusterCustomObjectStatus(param: CustomObjectsApiGetClusterCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.getClusterCustomObjectStatus(param.group, param.version, param.plural, param.name,  options).toPromise();
    }

    /**
     * Returns a namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiGetNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.getNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * Returns a namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObject(param: CustomObjectsApiGetNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.getNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectScaleWithHttpInfo(param: CustomObjectsApiGetNamespacedCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.getNamespacedCustomObjectScaleWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectScale(param: CustomObjectsApiGetNamespacedCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.getNamespacedCustomObjectScale(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectStatusWithHttpInfo(param: CustomObjectsApiGetNamespacedCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.getNamespacedCustomObjectStatusWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * read status of the specified namespace scoped custom object
     * @param param the request object
     */
    public getNamespacedCustomObjectStatus(param: CustomObjectsApiGetNamespacedCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.getNamespacedCustomObjectStatus(param.group, param.version, param.namespace, param.plural, param.name,  options).toPromise();
    }

    /**
     * list or watch cluster scoped custom objects
     * @param param the request object
     */
    public listClusterCustomObjectWithHttpInfo(param: CustomObjectsApiListClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.listClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch cluster scoped custom objects
     * @param param the request object
     */
    public listClusterCustomObject(param: CustomObjectsApiListClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.listClusterCustomObject(param.group, param.version, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch namespace scoped custom objects
     * @param param the request object
     */
    public listCustomObjectForAllNamespacesWithHttpInfo(param: CustomObjectsApiListCustomObjectForAllNamespacesRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.listCustomObjectForAllNamespacesWithHttpInfo(param.group, param.version, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch namespace scoped custom objects
     * @param param the request object
     */
    public listCustomObjectForAllNamespaces(param: CustomObjectsApiListCustomObjectForAllNamespacesRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.listCustomObjectForAllNamespaces(param.group, param.version, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch namespace scoped custom objects
     * @param param the request object
     */
    public listNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiListNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.listNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch namespace scoped custom objects
     * @param param the request object
     */
    public listNamespacedCustomObject(param: CustomObjectsApiListNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.listNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * patch the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectWithHttpInfo(param: CustomObjectsApiPatchClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.patchClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * patch the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObject(param: CustomObjectsApiPatchClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.patchClusterCustomObject(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectScaleWithHttpInfo(param: CustomObjectsApiPatchClusterCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.patchClusterCustomObjectScaleWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectScale(param: CustomObjectsApiPatchClusterCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.patchClusterCustomObjectScale(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectStatusWithHttpInfo(param: CustomObjectsApiPatchClusterCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.patchClusterCustomObjectStatusWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified cluster scoped custom object
     * @param param the request object
     */
    public patchClusterCustomObjectStatus(param: CustomObjectsApiPatchClusterCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.patchClusterCustomObjectStatus(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * patch the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiPatchNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.patchNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * patch the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObject(param: CustomObjectsApiPatchNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.patchNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectScaleWithHttpInfo(param: CustomObjectsApiPatchNamespacedCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.patchNamespacedCustomObjectScaleWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectScale(param: CustomObjectsApiPatchNamespacedCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.patchNamespacedCustomObjectScale(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectStatusWithHttpInfo(param: CustomObjectsApiPatchNamespacedCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.patchNamespacedCustomObjectStatusWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified namespace scoped custom object
     * @param param the request object
     */
    public patchNamespacedCustomObjectStatus(param: CustomObjectsApiPatchNamespacedCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.patchNamespacedCustomObjectStatus(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * replace the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectWithHttpInfo(param: CustomObjectsApiReplaceClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.replaceClusterCustomObjectWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObject(param: CustomObjectsApiReplaceClusterCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.replaceClusterCustomObject(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectScaleWithHttpInfo(param: CustomObjectsApiReplaceClusterCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.replaceClusterCustomObjectScaleWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified cluster scoped custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectScale(param: CustomObjectsApiReplaceClusterCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.replaceClusterCustomObjectScale(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the cluster scoped specified custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectStatusWithHttpInfo(param: CustomObjectsApiReplaceClusterCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.replaceClusterCustomObjectStatusWithHttpInfo(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the cluster scoped specified custom object
     * @param param the request object
     */
    public replaceClusterCustomObjectStatus(param: CustomObjectsApiReplaceClusterCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.replaceClusterCustomObjectStatus(param.group, param.version, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectWithHttpInfo(param: CustomObjectsApiReplaceNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.replaceNamespacedCustomObjectWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObject(param: CustomObjectsApiReplaceNamespacedCustomObjectRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.replaceNamespacedCustomObject(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectScaleWithHttpInfo(param: CustomObjectsApiReplaceNamespacedCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.replaceNamespacedCustomObjectScaleWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace scale of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectScale(param: CustomObjectsApiReplaceNamespacedCustomObjectScaleRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.replaceNamespacedCustomObjectScale(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectStatusWithHttpInfo(param: CustomObjectsApiReplaceNamespacedCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<any>> {
        return this.api.replaceNamespacedCustomObjectStatusWithHttpInfo(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified namespace scoped custom object
     * @param param the request object
     */
    public replaceNamespacedCustomObjectStatus(param: CustomObjectsApiReplaceNamespacedCustomObjectStatusRequest, options?: ConfigurationOptions): Promise<any> {
        return this.api.replaceNamespacedCustomObjectStatus(param.group, param.version, param.namespace, param.plural, param.name, param.body, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableDiscoveryApi } from "./ObservableAPI.js";
import { DiscoveryApiRequestFactory, DiscoveryApiResponseProcessor} from "../apis/DiscoveryApi.js";

export interface DiscoveryApiGetAPIGroupRequest {
}

export class ObjectDiscoveryApi {
    private api: ObservableDiscoveryApi

    public constructor(configuration: Configuration, requestFactory?: DiscoveryApiRequestFactory, responseProcessor?: DiscoveryApiResponseProcessor) {
        this.api = new ObservableDiscoveryApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: DiscoveryApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: DiscoveryApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableDiscoveryV1Api } from "./ObservableAPI.js";
import { DiscoveryV1ApiRequestFactory, DiscoveryV1ApiResponseProcessor} from "../apis/DiscoveryV1Api.js";

export interface DiscoveryV1ApiCreateNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type V1EndpointSlice
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    body: V1EndpointSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApicreateNamespacedEndpointSlice
     */
    fieldValidation?: string
}

export interface DiscoveryV1ApiDeleteCollectionNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof DiscoveryV1ApideleteCollectionNamespacedEndpointSlice
     */
    body?: V1DeleteOptions
}

export interface DiscoveryV1ApiDeleteNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof DiscoveryV1ApideleteNamespacedEndpointSlice
     */
    body?: V1DeleteOptions
}

export interface DiscoveryV1ApiGetAPIResourcesRequest {
}

export interface DiscoveryV1ApiListEndpointSliceForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApilistEndpointSliceForAllNamespaces
     */
    watch?: boolean
}

export interface DiscoveryV1ApiListNamespacedEndpointSliceRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApilistNamespacedEndpointSlice
     */
    watch?: boolean
}

export interface DiscoveryV1ApiPatchNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof DiscoveryV1ApipatchNamespacedEndpointSlice
     */
    force?: boolean
}

export interface DiscoveryV1ApiReadNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireadNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireadNamespacedEndpointSlice
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireadNamespacedEndpointSlice
     */
    pretty?: string
}

export interface DiscoveryV1ApiReplaceNamespacedEndpointSliceRequest {
    /**
     * name of the EndpointSlice
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    namespace: string
    /**
     * 
     * @type V1EndpointSlice
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    body: V1EndpointSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof DiscoveryV1ApireplaceNamespacedEndpointSlice
     */
    fieldValidation?: string
}

export class ObjectDiscoveryV1Api {
    private api: ObservableDiscoveryV1Api

    public constructor(configuration: Configuration, requestFactory?: DiscoveryV1ApiRequestFactory, responseProcessor?: DiscoveryV1ApiResponseProcessor) {
        this.api = new ObservableDiscoveryV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an EndpointSlice
     * @param param the request object
     */
    public createNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiCreateNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.createNamespacedEndpointSliceWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an EndpointSlice
     * @param param the request object
     */
    public createNamespacedEndpointSlice(param: DiscoveryV1ApiCreateNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<V1EndpointSlice> {
        return this.api.createNamespacedEndpointSlice(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of EndpointSlice
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiDeleteCollectionNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEndpointSliceWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of EndpointSlice
     * @param param the request object
     */
    public deleteCollectionNamespacedEndpointSlice(param: DiscoveryV1ApiDeleteCollectionNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEndpointSlice(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an EndpointSlice
     * @param param the request object
     */
    public deleteNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiDeleteNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an EndpointSlice
     * @param param the request object
     */
    public deleteNamespacedEndpointSlice(param: DiscoveryV1ApiDeleteNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedEndpointSlice(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: DiscoveryV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: DiscoveryV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listEndpointSliceForAllNamespacesWithHttpInfo(param: DiscoveryV1ApiListEndpointSliceForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointSliceList>> {
        return this.api.listEndpointSliceForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listEndpointSliceForAllNamespaces(param: DiscoveryV1ApiListEndpointSliceForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1EndpointSliceList> {
        return this.api.listEndpointSliceForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiListNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointSliceList>> {
        return this.api.listNamespacedEndpointSliceWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind EndpointSlice
     * @param param the request object
     */
    public listNamespacedEndpointSlice(param: DiscoveryV1ApiListNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<V1EndpointSliceList> {
        return this.api.listNamespacedEndpointSlice(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified EndpointSlice
     * @param param the request object
     */
    public patchNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiPatchNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.patchNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified EndpointSlice
     * @param param the request object
     */
    public patchNamespacedEndpointSlice(param: DiscoveryV1ApiPatchNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<V1EndpointSlice> {
        return this.api.patchNamespacedEndpointSlice(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified EndpointSlice
     * @param param the request object
     */
    public readNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiReadNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.readNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified EndpointSlice
     * @param param the request object
     */
    public readNamespacedEndpointSlice(param: DiscoveryV1ApiReadNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<V1EndpointSlice> {
        return this.api.readNamespacedEndpointSlice(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified EndpointSlice
     * @param param the request object
     */
    public replaceNamespacedEndpointSliceWithHttpInfo(param: DiscoveryV1ApiReplaceNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1EndpointSlice>> {
        return this.api.replaceNamespacedEndpointSliceWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified EndpointSlice
     * @param param the request object
     */
    public replaceNamespacedEndpointSlice(param: DiscoveryV1ApiReplaceNamespacedEndpointSliceRequest, options?: ConfigurationOptions): Promise<V1EndpointSlice> {
        return this.api.replaceNamespacedEndpointSlice(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableEventsApi } from "./ObservableAPI.js";
import { EventsApiRequestFactory, EventsApiResponseProcessor} from "../apis/EventsApi.js";

export interface EventsApiGetAPIGroupRequest {
}

export class ObjectEventsApi {
    private api: ObservableEventsApi

    public constructor(configuration: Configuration, requestFactory?: EventsApiRequestFactory, responseProcessor?: EventsApiResponseProcessor) {
        this.api = new ObservableEventsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: EventsApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: EventsApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableEventsV1Api } from "./ObservableAPI.js";
import { EventsV1ApiRequestFactory, EventsV1ApiResponseProcessor} from "../apis/EventsV1Api.js";

export interface EventsV1ApiCreateNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type EventsV1Event
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    body: EventsV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApicreateNamespacedEvent
     */
    fieldValidation?: string
}

export interface EventsV1ApiDeleteCollectionNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof EventsV1ApideleteCollectionNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface EventsV1ApiDeleteNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof EventsV1ApideleteNamespacedEvent
     */
    body?: V1DeleteOptions
}

export interface EventsV1ApiGetAPIResourcesRequest {
}

export interface EventsV1ApiListEventForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApilistEventForAllNamespaces
     */
    watch?: boolean
}

export interface EventsV1ApiListNamespacedEventRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApilistNamespacedEvent
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApilistNamespacedEvent
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApilistNamespacedEvent
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApilistNamespacedEvent
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof EventsV1ApilistNamespacedEvent
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApilistNamespacedEvent
     */
    watch?: boolean
}

export interface EventsV1ApiPatchNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof EventsV1ApipatchNamespacedEvent
     */
    force?: boolean
}

export interface EventsV1ApiReadNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireadNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireadNamespacedEvent
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireadNamespacedEvent
     */
    pretty?: string
}

export interface EventsV1ApiReplaceNamespacedEventRequest {
    /**
     * name of the Event
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    namespace: string
    /**
     * 
     * @type EventsV1Event
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    body: EventsV1Event
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof EventsV1ApireplaceNamespacedEvent
     */
    fieldValidation?: string
}

export class ObjectEventsV1Api {
    private api: ObservableEventsV1Api

    public constructor(configuration: Configuration, requestFactory?: EventsV1ApiRequestFactory, responseProcessor?: EventsV1ApiResponseProcessor) {
        this.api = new ObservableEventsV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEventWithHttpInfo(param: EventsV1ApiCreateNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<EventsV1Event>> {
        return this.api.createNamespacedEventWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an Event
     * @param param the request object
     */
    public createNamespacedEvent(param: EventsV1ApiCreateNamespacedEventRequest, options?: ConfigurationOptions): Promise<EventsV1Event> {
        return this.api.createNamespacedEvent(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEventWithHttpInfo(param: EventsV1ApiDeleteCollectionNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedEventWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Event
     * @param param the request object
     */
    public deleteCollectionNamespacedEvent(param: EventsV1ApiDeleteCollectionNamespacedEventRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedEvent(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEventWithHttpInfo(param: EventsV1ApiDeleteNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Event
     * @param param the request object
     */
    public deleteNamespacedEvent(param: EventsV1ApiDeleteNamespacedEventRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedEvent(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: EventsV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: EventsV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespacesWithHttpInfo(param: EventsV1ApiListEventForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<EventsV1EventList>> {
        return this.api.listEventForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listEventForAllNamespaces(param: EventsV1ApiListEventForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<EventsV1EventList> {
        return this.api.listEventForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEventWithHttpInfo(param: EventsV1ApiListNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<EventsV1EventList>> {
        return this.api.listNamespacedEventWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Event
     * @param param the request object
     */
    public listNamespacedEvent(param: EventsV1ApiListNamespacedEventRequest, options?: ConfigurationOptions): Promise<EventsV1EventList> {
        return this.api.listNamespacedEvent(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEventWithHttpInfo(param: EventsV1ApiPatchNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<EventsV1Event>> {
        return this.api.patchNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Event
     * @param param the request object
     */
    public patchNamespacedEvent(param: EventsV1ApiPatchNamespacedEventRequest, options?: ConfigurationOptions): Promise<EventsV1Event> {
        return this.api.patchNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEventWithHttpInfo(param: EventsV1ApiReadNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<EventsV1Event>> {
        return this.api.readNamespacedEventWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Event
     * @param param the request object
     */
    public readNamespacedEvent(param: EventsV1ApiReadNamespacedEventRequest, options?: ConfigurationOptions): Promise<EventsV1Event> {
        return this.api.readNamespacedEvent(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEventWithHttpInfo(param: EventsV1ApiReplaceNamespacedEventRequest, options?: ConfigurationOptions): Promise<HttpInfo<EventsV1Event>> {
        return this.api.replaceNamespacedEventWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Event
     * @param param the request object
     */
    public replaceNamespacedEvent(param: EventsV1ApiReplaceNamespacedEventRequest, options?: ConfigurationOptions): Promise<EventsV1Event> {
        return this.api.replaceNamespacedEvent(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableFlowcontrolApiserverApi } from "./ObservableAPI.js";
import { FlowcontrolApiserverApiRequestFactory, FlowcontrolApiserverApiResponseProcessor} from "../apis/FlowcontrolApiserverApi.js";

export interface FlowcontrolApiserverApiGetAPIGroupRequest {
}

export class ObjectFlowcontrolApiserverApi {
    private api: ObservableFlowcontrolApiserverApi

    public constructor(configuration: Configuration, requestFactory?: FlowcontrolApiserverApiRequestFactory, responseProcessor?: FlowcontrolApiserverApiResponseProcessor) {
        this.api = new ObservableFlowcontrolApiserverApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: FlowcontrolApiserverApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: FlowcontrolApiserverApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableFlowcontrolApiserverV1Api } from "./ObservableAPI.js";
import { FlowcontrolApiserverV1ApiRequestFactory, FlowcontrolApiserverV1ApiResponseProcessor} from "../apis/FlowcontrolApiserverV1Api.js";

export interface FlowcontrolApiserverV1ApiCreateFlowSchemaRequest {
    /**
     * 
     * @type V1FlowSchema
     * @memberof FlowcontrolApiserverV1ApicreateFlowSchema
     */
    body: V1FlowSchema
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreateFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreateFlowSchema
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreateFlowSchema
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreateFlowSchema
     */
    fieldValidation?: string
}

export interface FlowcontrolApiserverV1ApiCreatePriorityLevelConfigurationRequest {
    /**
     * 
     * @type V1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1ApicreatePriorityLevelConfiguration
     */
    body: V1PriorityLevelConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreatePriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreatePriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreatePriorityLevelConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApicreatePriorityLevelConfiguration
     */
    fieldValidation?: string
}

export interface FlowcontrolApiserverV1ApiDeleteCollectionFlowSchemaRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1ApideleteCollectionFlowSchema
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1ApiDeleteCollectionPriorityLevelConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1ApideleteCollectionPriorityLevelConfiguration
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1ApiDeleteFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1ApideleteFlowSchema
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1ApiDeletePriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof FlowcontrolApiserverV1ApideletePriorityLevelConfiguration
     */
    body?: V1DeleteOptions
}

export interface FlowcontrolApiserverV1ApiGetAPIResourcesRequest {
}

export interface FlowcontrolApiserverV1ApiListFlowSchemaRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApilistFlowSchema
     */
    watch?: boolean
}

export interface FlowcontrolApiserverV1ApiListPriorityLevelConfigurationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApilistPriorityLevelConfiguration
     */
    watch?: boolean
}

export interface FlowcontrolApiserverV1ApiPatchFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchema
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchema
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchema
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchema
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchema
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchema
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1ApiPatchFlowSchemaStatusRequest {
    /**
     * name of the FlowSchema
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchemaStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchemaStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchemaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchemaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchemaStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchemaStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApipatchFlowSchemaStatus
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1ApiPatchPriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfiguration
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfiguration
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfiguration
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfiguration
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1ApiPatchPriorityLevelConfigurationStatusRequest {
    /**
     * name of the PriorityLevelConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfigurationStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfigurationStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfigurationStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfigurationStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfigurationStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfigurationStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof FlowcontrolApiserverV1ApipatchPriorityLevelConfigurationStatus
     */
    force?: boolean
}

export interface FlowcontrolApiserverV1ApiReadFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadFlowSchema
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadFlowSchema
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1ApiReadFlowSchemaStatusRequest {
    /**
     * name of the FlowSchema
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadFlowSchemaStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadFlowSchemaStatus
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1ApiReadPriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadPriorityLevelConfiguration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadPriorityLevelConfiguration
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1ApiReadPriorityLevelConfigurationStatusRequest {
    /**
     * name of the PriorityLevelConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadPriorityLevelConfigurationStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireadPriorityLevelConfigurationStatus
     */
    pretty?: string
}

export interface FlowcontrolApiserverV1ApiReplaceFlowSchemaRequest {
    /**
     * name of the FlowSchema
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchema
     */
    name: string
    /**
     * 
     * @type V1FlowSchema
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchema
     */
    body: V1FlowSchema
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchema
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchema
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchema
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchema
     */
    fieldValidation?: string
}

export interface FlowcontrolApiserverV1ApiReplaceFlowSchemaStatusRequest {
    /**
     * name of the FlowSchema
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchemaStatus
     */
    name: string
    /**
     * 
     * @type V1FlowSchema
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchemaStatus
     */
    body: V1FlowSchema
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchemaStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchemaStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchemaStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplaceFlowSchemaStatus
     */
    fieldValidation?: string
}

export interface FlowcontrolApiserverV1ApiReplacePriorityLevelConfigurationRequest {
    /**
     * name of the PriorityLevelConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfiguration
     */
    name: string
    /**
     * 
     * @type V1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfiguration
     */
    body: V1PriorityLevelConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfiguration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfiguration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfiguration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfiguration
     */
    fieldValidation?: string
}

export interface FlowcontrolApiserverV1ApiReplacePriorityLevelConfigurationStatusRequest {
    /**
     * name of the PriorityLevelConfiguration
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfigurationStatus
     */
    name: string
    /**
     * 
     * @type V1PriorityLevelConfiguration
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfigurationStatus
     */
    body: V1PriorityLevelConfiguration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfigurationStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfigurationStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfigurationStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof FlowcontrolApiserverV1ApireplacePriorityLevelConfigurationStatus
     */
    fieldValidation?: string
}

export class ObjectFlowcontrolApiserverV1Api {
    private api: ObservableFlowcontrolApiserverV1Api

    public constructor(configuration: Configuration, requestFactory?: FlowcontrolApiserverV1ApiRequestFactory, responseProcessor?: FlowcontrolApiserverV1ApiResponseProcessor) {
        this.api = new ObservableFlowcontrolApiserverV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a FlowSchema
     * @param param the request object
     */
    public createFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1ApiCreateFlowSchemaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchema>> {
        return this.api.createFlowSchemaWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a FlowSchema
     * @param param the request object
     */
    public createFlowSchema(param: FlowcontrolApiserverV1ApiCreateFlowSchemaRequest, options?: ConfigurationOptions): Promise<V1FlowSchema> {
        return this.api.createFlowSchema(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PriorityLevelConfiguration
     * @param param the request object
     */
    public createPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1ApiCreatePriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfiguration>> {
        return this.api.createPriorityLevelConfigurationWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PriorityLevelConfiguration
     * @param param the request object
     */
    public createPriorityLevelConfiguration(param: FlowcontrolApiserverV1ApiCreatePriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<V1PriorityLevelConfiguration> {
        return this.api.createPriorityLevelConfiguration(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of FlowSchema
     * @param param the request object
     */
    public deleteCollectionFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1ApiDeleteCollectionFlowSchemaRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionFlowSchemaWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of FlowSchema
     * @param param the request object
     */
    public deleteCollectionFlowSchema(param: FlowcontrolApiserverV1ApiDeleteCollectionFlowSchemaRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionFlowSchema(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PriorityLevelConfiguration
     * @param param the request object
     */
    public deleteCollectionPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1ApiDeleteCollectionPriorityLevelConfigurationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPriorityLevelConfigurationWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PriorityLevelConfiguration
     * @param param the request object
     */
    public deleteCollectionPriorityLevelConfiguration(param: FlowcontrolApiserverV1ApiDeleteCollectionPriorityLevelConfigurationRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionPriorityLevelConfiguration(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a FlowSchema
     * @param param the request object
     */
    public deleteFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1ApiDeleteFlowSchemaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteFlowSchemaWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a FlowSchema
     * @param param the request object
     */
    public deleteFlowSchema(param: FlowcontrolApiserverV1ApiDeleteFlowSchemaRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteFlowSchema(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityLevelConfiguration
     * @param param the request object
     */
    public deletePriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1ApiDeletePriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deletePriorityLevelConfigurationWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityLevelConfiguration
     * @param param the request object
     */
    public deletePriorityLevelConfiguration(param: FlowcontrolApiserverV1ApiDeletePriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deletePriorityLevelConfiguration(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: FlowcontrolApiserverV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: FlowcontrolApiserverV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind FlowSchema
     * @param param the request object
     */
    public listFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1ApiListFlowSchemaRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchemaList>> {
        return this.api.listFlowSchemaWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind FlowSchema
     * @param param the request object
     */
    public listFlowSchema(param: FlowcontrolApiserverV1ApiListFlowSchemaRequest = {}, options?: ConfigurationOptions): Promise<V1FlowSchemaList> {
        return this.api.listFlowSchema(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityLevelConfiguration
     * @param param the request object
     */
    public listPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1ApiListPriorityLevelConfigurationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfigurationList>> {
        return this.api.listPriorityLevelConfigurationWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityLevelConfiguration
     * @param param the request object
     */
    public listPriorityLevelConfiguration(param: FlowcontrolApiserverV1ApiListPriorityLevelConfigurationRequest = {}, options?: ConfigurationOptions): Promise<V1PriorityLevelConfigurationList> {
        return this.api.listPriorityLevelConfiguration(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1ApiPatchFlowSchemaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchema>> {
        return this.api.patchFlowSchemaWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchema(param: FlowcontrolApiserverV1ApiPatchFlowSchemaRequest, options?: ConfigurationOptions): Promise<V1FlowSchema> {
        return this.api.patchFlowSchema(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchemaStatusWithHttpInfo(param: FlowcontrolApiserverV1ApiPatchFlowSchemaStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchema>> {
        return this.api.patchFlowSchemaStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified FlowSchema
     * @param param the request object
     */
    public patchFlowSchemaStatus(param: FlowcontrolApiserverV1ApiPatchFlowSchemaStatusRequest, options?: ConfigurationOptions): Promise<V1FlowSchema> {
        return this.api.patchFlowSchemaStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1ApiPatchPriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfiguration>> {
        return this.api.patchPriorityLevelConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfiguration(param: FlowcontrolApiserverV1ApiPatchPriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<V1PriorityLevelConfiguration> {
        return this.api.patchPriorityLevelConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfigurationStatusWithHttpInfo(param: FlowcontrolApiserverV1ApiPatchPriorityLevelConfigurationStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfiguration>> {
        return this.api.patchPriorityLevelConfigurationStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public patchPriorityLevelConfigurationStatus(param: FlowcontrolApiserverV1ApiPatchPriorityLevelConfigurationStatusRequest, options?: ConfigurationOptions): Promise<V1PriorityLevelConfiguration> {
        return this.api.patchPriorityLevelConfigurationStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1ApiReadFlowSchemaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchema>> {
        return this.api.readFlowSchemaWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchema(param: FlowcontrolApiserverV1ApiReadFlowSchemaRequest, options?: ConfigurationOptions): Promise<V1FlowSchema> {
        return this.api.readFlowSchema(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchemaStatusWithHttpInfo(param: FlowcontrolApiserverV1ApiReadFlowSchemaStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchema>> {
        return this.api.readFlowSchemaStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified FlowSchema
     * @param param the request object
     */
    public readFlowSchemaStatus(param: FlowcontrolApiserverV1ApiReadFlowSchemaStatusRequest, options?: ConfigurationOptions): Promise<V1FlowSchema> {
        return this.api.readFlowSchemaStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1ApiReadPriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfiguration>> {
        return this.api.readPriorityLevelConfigurationWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfiguration(param: FlowcontrolApiserverV1ApiReadPriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<V1PriorityLevelConfiguration> {
        return this.api.readPriorityLevelConfiguration(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfigurationStatusWithHttpInfo(param: FlowcontrolApiserverV1ApiReadPriorityLevelConfigurationStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfiguration>> {
        return this.api.readPriorityLevelConfigurationStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public readPriorityLevelConfigurationStatus(param: FlowcontrolApiserverV1ApiReadPriorityLevelConfigurationStatusRequest, options?: ConfigurationOptions): Promise<V1PriorityLevelConfiguration> {
        return this.api.readPriorityLevelConfigurationStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchemaWithHttpInfo(param: FlowcontrolApiserverV1ApiReplaceFlowSchemaRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchema>> {
        return this.api.replaceFlowSchemaWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchema(param: FlowcontrolApiserverV1ApiReplaceFlowSchemaRequest, options?: ConfigurationOptions): Promise<V1FlowSchema> {
        return this.api.replaceFlowSchema(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchemaStatusWithHttpInfo(param: FlowcontrolApiserverV1ApiReplaceFlowSchemaStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1FlowSchema>> {
        return this.api.replaceFlowSchemaStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified FlowSchema
     * @param param the request object
     */
    public replaceFlowSchemaStatus(param: FlowcontrolApiserverV1ApiReplaceFlowSchemaStatusRequest, options?: ConfigurationOptions): Promise<V1FlowSchema> {
        return this.api.replaceFlowSchemaStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfigurationWithHttpInfo(param: FlowcontrolApiserverV1ApiReplacePriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfiguration>> {
        return this.api.replacePriorityLevelConfigurationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfiguration(param: FlowcontrolApiserverV1ApiReplacePriorityLevelConfigurationRequest, options?: ConfigurationOptions): Promise<V1PriorityLevelConfiguration> {
        return this.api.replacePriorityLevelConfiguration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfigurationStatusWithHttpInfo(param: FlowcontrolApiserverV1ApiReplacePriorityLevelConfigurationStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityLevelConfiguration>> {
        return this.api.replacePriorityLevelConfigurationStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PriorityLevelConfiguration
     * @param param the request object
     */
    public replacePriorityLevelConfigurationStatus(param: FlowcontrolApiserverV1ApiReplacePriorityLevelConfigurationStatusRequest, options?: ConfigurationOptions): Promise<V1PriorityLevelConfiguration> {
        return this.api.replacePriorityLevelConfigurationStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableInternalApiserverApi } from "./ObservableAPI.js";
import { InternalApiserverApiRequestFactory, InternalApiserverApiResponseProcessor} from "../apis/InternalApiserverApi.js";

export interface InternalApiserverApiGetAPIGroupRequest {
}

export class ObjectInternalApiserverApi {
    private api: ObservableInternalApiserverApi

    public constructor(configuration: Configuration, requestFactory?: InternalApiserverApiRequestFactory, responseProcessor?: InternalApiserverApiResponseProcessor) {
        this.api = new ObservableInternalApiserverApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: InternalApiserverApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: InternalApiserverApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableInternalApiserverV1alpha1Api } from "./ObservableAPI.js";
import { InternalApiserverV1alpha1ApiRequestFactory, InternalApiserverV1alpha1ApiResponseProcessor} from "../apis/InternalApiserverV1alpha1Api.js";

export interface InternalApiserverV1alpha1ApiCreateStorageVersionRequest {
    /**
     * 
     * @type V1alpha1StorageVersion
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    body: V1alpha1StorageVersion
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApicreateStorageVersion
     */
    fieldValidation?: string
}

export interface InternalApiserverV1alpha1ApiDeleteCollectionStorageVersionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof InternalApiserverV1alpha1ApideleteCollectionStorageVersion
     */
    body?: V1DeleteOptions
}

export interface InternalApiserverV1alpha1ApiDeleteStorageVersionRequest {
    /**
     * name of the StorageVersion
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof InternalApiserverV1alpha1ApideleteStorageVersion
     */
    body?: V1DeleteOptions
}

export interface InternalApiserverV1alpha1ApiGetAPIResourcesRequest {
}

export interface InternalApiserverV1alpha1ApiListStorageVersionRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApilistStorageVersion
     */
    watch?: boolean
}

export interface InternalApiserverV1alpha1ApiPatchStorageVersionRequest {
    /**
     * name of the StorageVersion
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    name: string
    /**
     * 
     * @type any
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersion
     */
    force?: boolean
}

export interface InternalApiserverV1alpha1ApiPatchStorageVersionStatusRequest {
    /**
     * name of the StorageVersion
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof InternalApiserverV1alpha1ApipatchStorageVersionStatus
     */
    force?: boolean
}

export interface InternalApiserverV1alpha1ApiReadStorageVersionRequest {
    /**
     * name of the StorageVersion
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersion
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersion
     */
    pretty?: string
}

export interface InternalApiserverV1alpha1ApiReadStorageVersionStatusRequest {
    /**
     * name of the StorageVersion
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersionStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireadStorageVersionStatus
     */
    pretty?: string
}

export interface InternalApiserverV1alpha1ApiReplaceStorageVersionRequest {
    /**
     * name of the StorageVersion
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    name: string
    /**
     * 
     * @type V1alpha1StorageVersion
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    body: V1alpha1StorageVersion
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersion
     */
    fieldValidation?: string
}

export interface InternalApiserverV1alpha1ApiReplaceStorageVersionStatusRequest {
    /**
     * name of the StorageVersion
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    name: string
    /**
     * 
     * @type V1alpha1StorageVersion
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    body: V1alpha1StorageVersion
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof InternalApiserverV1alpha1ApireplaceStorageVersionStatus
     */
    fieldValidation?: string
}

export class ObjectInternalApiserverV1alpha1Api {
    private api: ObservableInternalApiserverV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: InternalApiserverV1alpha1ApiRequestFactory, responseProcessor?: InternalApiserverV1alpha1ApiResponseProcessor) {
        this.api = new ObservableInternalApiserverV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a StorageVersion
     * @param param the request object
     */
    public createStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiCreateStorageVersionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.createStorageVersionWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a StorageVersion
     * @param param the request object
     */
    public createStorageVersion(param: InternalApiserverV1alpha1ApiCreateStorageVersionRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersion> {
        return this.api.createStorageVersion(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of StorageVersion
     * @param param the request object
     */
    public deleteCollectionStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiDeleteCollectionStorageVersionRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionStorageVersionWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StorageVersion
     * @param param the request object
     */
    public deleteCollectionStorageVersion(param: InternalApiserverV1alpha1ApiDeleteCollectionStorageVersionRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionStorageVersion(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a StorageVersion
     * @param param the request object
     */
    public deleteStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiDeleteStorageVersionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteStorageVersionWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StorageVersion
     * @param param the request object
     */
    public deleteStorageVersion(param: InternalApiserverV1alpha1ApiDeleteStorageVersionRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteStorageVersion(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: InternalApiserverV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: InternalApiserverV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind StorageVersion
     * @param param the request object
     */
    public listStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiListStorageVersionRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionList>> {
        return this.api.listStorageVersionWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StorageVersion
     * @param param the request object
     */
    public listStorageVersion(param: InternalApiserverV1alpha1ApiListStorageVersionRequest = {}, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionList> {
        return this.api.listStorageVersion(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiPatchStorageVersionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.patchStorageVersionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersion(param: InternalApiserverV1alpha1ApiPatchStorageVersionRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersion> {
        return this.api.patchStorageVersion(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersionStatusWithHttpInfo(param: InternalApiserverV1alpha1ApiPatchStorageVersionStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.patchStorageVersionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StorageVersion
     * @param param the request object
     */
    public patchStorageVersionStatus(param: InternalApiserverV1alpha1ApiPatchStorageVersionStatusRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersion> {
        return this.api.patchStorageVersionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiReadStorageVersionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.readStorageVersionWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersion(param: InternalApiserverV1alpha1ApiReadStorageVersionRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersion> {
        return this.api.readStorageVersion(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersionStatusWithHttpInfo(param: InternalApiserverV1alpha1ApiReadStorageVersionStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.readStorageVersionStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StorageVersion
     * @param param the request object
     */
    public readStorageVersionStatus(param: InternalApiserverV1alpha1ApiReadStorageVersionStatusRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersion> {
        return this.api.readStorageVersionStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersionWithHttpInfo(param: InternalApiserverV1alpha1ApiReplaceStorageVersionRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.replaceStorageVersionWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersion(param: InternalApiserverV1alpha1ApiReplaceStorageVersionRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersion> {
        return this.api.replaceStorageVersion(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersionStatusWithHttpInfo(param: InternalApiserverV1alpha1ApiReplaceStorageVersionStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersion>> {
        return this.api.replaceStorageVersionStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified StorageVersion
     * @param param the request object
     */
    public replaceStorageVersionStatus(param: InternalApiserverV1alpha1ApiReplaceStorageVersionStatusRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersion> {
        return this.api.replaceStorageVersionStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableLogsApi } from "./ObservableAPI.js";
import { LogsApiRequestFactory, LogsApiResponseProcessor} from "../apis/LogsApi.js";

export interface LogsApiLogFileHandlerRequest {
    /**
     * path to the log
     * Defaults to: undefined
     * @type string
     * @memberof LogsApilogFileHandler
     */
    logpath: string
}

export interface LogsApiLogFileListHandlerRequest {
}

export class ObjectLogsApi {
    private api: ObservableLogsApi

    public constructor(configuration: Configuration, requestFactory?: LogsApiRequestFactory, responseProcessor?: LogsApiResponseProcessor) {
        this.api = new ObservableLogsApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * @param param the request object
     */
    public logFileHandlerWithHttpInfo(param: LogsApiLogFileHandlerRequest, options?: ConfigurationOptions): Promise<HttpInfo<void>> {
        return this.api.logFileHandlerWithHttpInfo(param.logpath,  options).toPromise();
    }

    /**
     * @param param the request object
     */
    public logFileHandler(param: LogsApiLogFileHandlerRequest, options?: ConfigurationOptions): Promise<void> {
        return this.api.logFileHandler(param.logpath,  options).toPromise();
    }

    /**
     * @param param the request object
     */
    public logFileListHandlerWithHttpInfo(param: LogsApiLogFileListHandlerRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<void>> {
        return this.api.logFileListHandlerWithHttpInfo( options).toPromise();
    }

    /**
     * @param param the request object
     */
    public logFileListHandler(param: LogsApiLogFileListHandlerRequest = {}, options?: ConfigurationOptions): Promise<void> {
        return this.api.logFileListHandler( options).toPromise();
    }

}

import { ObservableNetworkingApi } from "./ObservableAPI.js";
import { NetworkingApiRequestFactory, NetworkingApiResponseProcessor} from "../apis/NetworkingApi.js";

export interface NetworkingApiGetAPIGroupRequest {
}

export class ObjectNetworkingApi {
    private api: ObservableNetworkingApi

    public constructor(configuration: Configuration, requestFactory?: NetworkingApiRequestFactory, responseProcessor?: NetworkingApiResponseProcessor) {
        this.api = new ObservableNetworkingApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: NetworkingApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: NetworkingApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableNetworkingV1Api } from "./ObservableAPI.js";
import { NetworkingV1ApiRequestFactory, NetworkingV1ApiResponseProcessor} from "../apis/NetworkingV1Api.js";

export interface NetworkingV1ApiCreateIPAddressRequest {
    /**
     * 
     * @type V1IPAddress
     * @memberof NetworkingV1ApicreateIPAddress
     */
    body: V1IPAddress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIPAddress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIPAddress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIPAddress
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiCreateIngressClassRequest {
    /**
     * 
     * @type V1IngressClass
     * @memberof NetworkingV1ApicreateIngressClass
     */
    body: V1IngressClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIngressClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIngressClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateIngressClass
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiCreateNamespacedIngressRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    namespace: string
    /**
     * 
     * @type V1Ingress
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    body: V1Ingress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedIngress
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiCreateNamespacedNetworkPolicyRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * 
     * @type V1NetworkPolicy
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    body: V1NetworkPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateNamespacedNetworkPolicy
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiCreateServiceCIDRRequest {
    /**
     * 
     * @type V1ServiceCIDR
     * @memberof NetworkingV1ApicreateServiceCIDR
     */
    body: V1ServiceCIDR
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateServiceCIDR
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateServiceCIDR
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApicreateServiceCIDR
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiDeleteCollectionIPAddressRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionIPAddress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteCollectionIngressClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionIngressClass
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteCollectionNamespacedIngressRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionNamespacedIngress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteCollectionNamespacedNetworkPolicyRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionNamespacedNetworkPolicy
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteCollectionServiceCIDRRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteCollectionServiceCIDR
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIPAddress
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIPAddress
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteIPAddress
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteIPAddress
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteIPAddress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIPAddress
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteIPAddress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteIngressClassRequest {
    /**
     * name of the IngressClass
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteIngressClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteIngressClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteIngressClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteIngressClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteIngressClass
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteNamespacedIngressRequest {
    /**
     * name of the Ingress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteNamespacedIngress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteNamespacedNetworkPolicy
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiDeleteServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1ApideleteServiceCIDR
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1ApiGetAPIResourcesRequest {
}

export interface NetworkingV1ApiListIPAddressRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIPAddress
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIPAddress
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIPAddress
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIPAddress
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIPAddress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistIPAddress
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIPAddress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIPAddress
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIPAddress
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistIPAddress
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIPAddress
     */
    watch?: boolean
}

export interface NetworkingV1ApiListIngressClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIngressClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistIngressClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIngressClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistIngressClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIngressClass
     */
    watch?: boolean
}

export interface NetworkingV1ApiListIngressForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistIngressForAllNamespaces
     */
    watch?: boolean
}

export interface NetworkingV1ApiListNamespacedIngressRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedIngress
     */
    watch?: boolean
}

export interface NetworkingV1ApiListNamespacedNetworkPolicyRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNamespacedNetworkPolicy
     */
    watch?: boolean
}

export interface NetworkingV1ApiListNetworkPolicyForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistNetworkPolicyForAllNamespaces
     */
    watch?: boolean
}

export interface NetworkingV1ApiListServiceCIDRRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApilistServiceCIDR
     */
    watch?: boolean
}

export interface NetworkingV1ApiPatchIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIPAddress
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchIPAddress
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIPAddress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIPAddress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIPAddress
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApipatchIPAddress
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchIngressClassRequest {
    /**
     * name of the IngressClass
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchIngressClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchIngressClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApipatchIngressClass
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchNamespacedIngressRequest {
    /**
     * name of the Ingress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApipatchNamespacedIngress
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchNamespacedIngressStatusRequest {
    /**
     * name of the Ingress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApipatchNamespacedIngressStatus
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApipatchNamespacedNetworkPolicy
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDR
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchServiceCIDR
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDR
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDR
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDR
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApipatchServiceCIDR
     */
    force?: boolean
}

export interface NetworkingV1ApiPatchServiceCIDRStatusRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDRStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1ApipatchServiceCIDRStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDRStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDRStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDRStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApipatchServiceCIDRStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1ApipatchServiceCIDRStatus
     */
    force?: boolean
}

export interface NetworkingV1ApiReadIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadIPAddress
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadIPAddress
     */
    pretty?: string
}

export interface NetworkingV1ApiReadIngressClassRequest {
    /**
     * name of the IngressClass
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadIngressClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadIngressClass
     */
    pretty?: string
}

export interface NetworkingV1ApiReadNamespacedIngressRequest {
    /**
     * name of the Ingress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngress
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngress
     */
    pretty?: string
}

export interface NetworkingV1ApiReadNamespacedIngressStatusRequest {
    /**
     * name of the Ingress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngressStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngressStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedIngressStatus
     */
    pretty?: string
}

export interface NetworkingV1ApiReadNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadNamespacedNetworkPolicy
     */
    pretty?: string
}

export interface NetworkingV1ApiReadServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadServiceCIDR
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadServiceCIDR
     */
    pretty?: string
}

export interface NetworkingV1ApiReadServiceCIDRStatusRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadServiceCIDRStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireadServiceCIDRStatus
     */
    pretty?: string
}

export interface NetworkingV1ApiReplaceIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIPAddress
     */
    name: string
    /**
     * 
     * @type V1IPAddress
     * @memberof NetworkingV1ApireplaceIPAddress
     */
    body: V1IPAddress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIPAddress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIPAddress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIPAddress
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiReplaceIngressClassRequest {
    /**
     * name of the IngressClass
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    name: string
    /**
     * 
     * @type V1IngressClass
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    body: V1IngressClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceIngressClass
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiReplaceNamespacedIngressRequest {
    /**
     * name of the Ingress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    namespace: string
    /**
     * 
     * @type V1Ingress
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    body: V1Ingress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngress
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiReplaceNamespacedIngressStatusRequest {
    /**
     * name of the Ingress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    namespace: string
    /**
     * 
     * @type V1Ingress
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    body: V1Ingress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedIngressStatus
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiReplaceNamespacedNetworkPolicyRequest {
    /**
     * name of the NetworkPolicy
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    namespace: string
    /**
     * 
     * @type V1NetworkPolicy
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    body: V1NetworkPolicy
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceNamespacedNetworkPolicy
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiReplaceServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDR
     */
    name: string
    /**
     * 
     * @type V1ServiceCIDR
     * @memberof NetworkingV1ApireplaceServiceCIDR
     */
    body: V1ServiceCIDR
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDR
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDR
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDR
     */
    fieldValidation?: string
}

export interface NetworkingV1ApiReplaceServiceCIDRStatusRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDRStatus
     */
    name: string
    /**
     * 
     * @type V1ServiceCIDR
     * @memberof NetworkingV1ApireplaceServiceCIDRStatus
     */
    body: V1ServiceCIDR
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDRStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDRStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDRStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1ApireplaceServiceCIDRStatus
     */
    fieldValidation?: string
}

export class ObjectNetworkingV1Api {
    private api: ObservableNetworkingV1Api

    public constructor(configuration: Configuration, requestFactory?: NetworkingV1ApiRequestFactory, responseProcessor?: NetworkingV1ApiResponseProcessor) {
        this.api = new ObservableNetworkingV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an IPAddress
     * @param param the request object
     */
    public createIPAddressWithHttpInfo(param: NetworkingV1ApiCreateIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IPAddress>> {
        return this.api.createIPAddressWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an IPAddress
     * @param param the request object
     */
    public createIPAddress(param: NetworkingV1ApiCreateIPAddressRequest, options?: ConfigurationOptions): Promise<V1IPAddress> {
        return this.api.createIPAddress(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an IngressClass
     * @param param the request object
     */
    public createIngressClassWithHttpInfo(param: NetworkingV1ApiCreateIngressClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IngressClass>> {
        return this.api.createIngressClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an IngressClass
     * @param param the request object
     */
    public createIngressClass(param: NetworkingV1ApiCreateIngressClassRequest, options?: ConfigurationOptions): Promise<V1IngressClass> {
        return this.api.createIngressClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an Ingress
     * @param param the request object
     */
    public createNamespacedIngressWithHttpInfo(param: NetworkingV1ApiCreateNamespacedIngressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Ingress>> {
        return this.api.createNamespacedIngressWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an Ingress
     * @param param the request object
     */
    public createNamespacedIngress(param: NetworkingV1ApiCreateNamespacedIngressRequest, options?: ConfigurationOptions): Promise<V1Ingress> {
        return this.api.createNamespacedIngress(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a NetworkPolicy
     * @param param the request object
     */
    public createNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiCreateNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.createNamespacedNetworkPolicyWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a NetworkPolicy
     * @param param the request object
     */
    public createNamespacedNetworkPolicy(param: NetworkingV1ApiCreateNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<V1NetworkPolicy> {
        return this.api.createNamespacedNetworkPolicy(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ServiceCIDR
     * @param param the request object
     */
    public createServiceCIDRWithHttpInfo(param: NetworkingV1ApiCreateServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDR>> {
        return this.api.createServiceCIDRWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ServiceCIDR
     * @param param the request object
     */
    public createServiceCIDR(param: NetworkingV1ApiCreateServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1ServiceCIDR> {
        return this.api.createServiceCIDR(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of IPAddress
     * @param param the request object
     */
    public deleteCollectionIPAddressWithHttpInfo(param: NetworkingV1ApiDeleteCollectionIPAddressRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionIPAddressWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of IPAddress
     * @param param the request object
     */
    public deleteCollectionIPAddress(param: NetworkingV1ApiDeleteCollectionIPAddressRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionIPAddress(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of IngressClass
     * @param param the request object
     */
    public deleteCollectionIngressClassWithHttpInfo(param: NetworkingV1ApiDeleteCollectionIngressClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionIngressClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of IngressClass
     * @param param the request object
     */
    public deleteCollectionIngressClass(param: NetworkingV1ApiDeleteCollectionIngressClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionIngressClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Ingress
     * @param param the request object
     */
    public deleteCollectionNamespacedIngressWithHttpInfo(param: NetworkingV1ApiDeleteCollectionNamespacedIngressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedIngressWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Ingress
     * @param param the request object
     */
    public deleteCollectionNamespacedIngress(param: NetworkingV1ApiDeleteCollectionNamespacedIngressRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedIngress(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of NetworkPolicy
     * @param param the request object
     */
    public deleteCollectionNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiDeleteCollectionNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedNetworkPolicyWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of NetworkPolicy
     * @param param the request object
     */
    public deleteCollectionNamespacedNetworkPolicy(param: NetworkingV1ApiDeleteCollectionNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedNetworkPolicy(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceCIDR
     * @param param the request object
     */
    public deleteCollectionServiceCIDRWithHttpInfo(param: NetworkingV1ApiDeleteCollectionServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionServiceCIDRWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceCIDR
     * @param param the request object
     */
    public deleteCollectionServiceCIDR(param: NetworkingV1ApiDeleteCollectionServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionServiceCIDR(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an IPAddress
     * @param param the request object
     */
    public deleteIPAddressWithHttpInfo(param: NetworkingV1ApiDeleteIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteIPAddressWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an IPAddress
     * @param param the request object
     */
    public deleteIPAddress(param: NetworkingV1ApiDeleteIPAddressRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteIPAddress(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an IngressClass
     * @param param the request object
     */
    public deleteIngressClassWithHttpInfo(param: NetworkingV1ApiDeleteIngressClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteIngressClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an IngressClass
     * @param param the request object
     */
    public deleteIngressClass(param: NetworkingV1ApiDeleteIngressClassRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteIngressClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Ingress
     * @param param the request object
     */
    public deleteNamespacedIngressWithHttpInfo(param: NetworkingV1ApiDeleteNamespacedIngressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedIngressWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an Ingress
     * @param param the request object
     */
    public deleteNamespacedIngress(param: NetworkingV1ApiDeleteNamespacedIngressRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedIngress(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a NetworkPolicy
     * @param param the request object
     */
    public deleteNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiDeleteNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a NetworkPolicy
     * @param param the request object
     */
    public deleteNamespacedNetworkPolicy(param: NetworkingV1ApiDeleteNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedNetworkPolicy(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceCIDR
     * @param param the request object
     */
    public deleteServiceCIDRWithHttpInfo(param: NetworkingV1ApiDeleteServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteServiceCIDRWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceCIDR
     * @param param the request object
     */
    public deleteServiceCIDR(param: NetworkingV1ApiDeleteServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteServiceCIDR(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: NetworkingV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: NetworkingV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind IPAddress
     * @param param the request object
     */
    public listIPAddressWithHttpInfo(param: NetworkingV1ApiListIPAddressRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1IPAddressList>> {
        return this.api.listIPAddressWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind IPAddress
     * @param param the request object
     */
    public listIPAddress(param: NetworkingV1ApiListIPAddressRequest = {}, options?: ConfigurationOptions): Promise<V1IPAddressList> {
        return this.api.listIPAddress(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind IngressClass
     * @param param the request object
     */
    public listIngressClassWithHttpInfo(param: NetworkingV1ApiListIngressClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1IngressClassList>> {
        return this.api.listIngressClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind IngressClass
     * @param param the request object
     */
    public listIngressClass(param: NetworkingV1ApiListIngressClassRequest = {}, options?: ConfigurationOptions): Promise<V1IngressClassList> {
        return this.api.listIngressClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listIngressForAllNamespacesWithHttpInfo(param: NetworkingV1ApiListIngressForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1IngressList>> {
        return this.api.listIngressForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listIngressForAllNamespaces(param: NetworkingV1ApiListIngressForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1IngressList> {
        return this.api.listIngressForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listNamespacedIngressWithHttpInfo(param: NetworkingV1ApiListNamespacedIngressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IngressList>> {
        return this.api.listNamespacedIngressWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Ingress
     * @param param the request object
     */
    public listNamespacedIngress(param: NetworkingV1ApiListNamespacedIngressRequest, options?: ConfigurationOptions): Promise<V1IngressList> {
        return this.api.listNamespacedIngress(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiListNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1NetworkPolicyList>> {
        return this.api.listNamespacedNetworkPolicyWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNamespacedNetworkPolicy(param: NetworkingV1ApiListNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<V1NetworkPolicyList> {
        return this.api.listNamespacedNetworkPolicy(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNetworkPolicyForAllNamespacesWithHttpInfo(param: NetworkingV1ApiListNetworkPolicyForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1NetworkPolicyList>> {
        return this.api.listNetworkPolicyForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind NetworkPolicy
     * @param param the request object
     */
    public listNetworkPolicyForAllNamespaces(param: NetworkingV1ApiListNetworkPolicyForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1NetworkPolicyList> {
        return this.api.listNetworkPolicyForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceCIDR
     * @param param the request object
     */
    public listServiceCIDRWithHttpInfo(param: NetworkingV1ApiListServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDRList>> {
        return this.api.listServiceCIDRWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceCIDR
     * @param param the request object
     */
    public listServiceCIDR(param: NetworkingV1ApiListServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<V1ServiceCIDRList> {
        return this.api.listServiceCIDR(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified IPAddress
     * @param param the request object
     */
    public patchIPAddressWithHttpInfo(param: NetworkingV1ApiPatchIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IPAddress>> {
        return this.api.patchIPAddressWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified IPAddress
     * @param param the request object
     */
    public patchIPAddress(param: NetworkingV1ApiPatchIPAddressRequest, options?: ConfigurationOptions): Promise<V1IPAddress> {
        return this.api.patchIPAddress(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified IngressClass
     * @param param the request object
     */
    public patchIngressClassWithHttpInfo(param: NetworkingV1ApiPatchIngressClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IngressClass>> {
        return this.api.patchIngressClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified IngressClass
     * @param param the request object
     */
    public patchIngressClass(param: NetworkingV1ApiPatchIngressClassRequest, options?: ConfigurationOptions): Promise<V1IngressClass> {
        return this.api.patchIngressClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngressWithHttpInfo(param: NetworkingV1ApiPatchNamespacedIngressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Ingress>> {
        return this.api.patchNamespacedIngressWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngress(param: NetworkingV1ApiPatchNamespacedIngressRequest, options?: ConfigurationOptions): Promise<V1Ingress> {
        return this.api.patchNamespacedIngress(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngressStatusWithHttpInfo(param: NetworkingV1ApiPatchNamespacedIngressStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Ingress>> {
        return this.api.patchNamespacedIngressStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified Ingress
     * @param param the request object
     */
    public patchNamespacedIngressStatus(param: NetworkingV1ApiPatchNamespacedIngressStatusRequest, options?: ConfigurationOptions): Promise<V1Ingress> {
        return this.api.patchNamespacedIngressStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified NetworkPolicy
     * @param param the request object
     */
    public patchNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiPatchNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.patchNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified NetworkPolicy
     * @param param the request object
     */
    public patchNamespacedNetworkPolicy(param: NetworkingV1ApiPatchNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<V1NetworkPolicy> {
        return this.api.patchNamespacedNetworkPolicy(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDRWithHttpInfo(param: NetworkingV1ApiPatchServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDR>> {
        return this.api.patchServiceCIDRWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDR(param: NetworkingV1ApiPatchServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1ServiceCIDR> {
        return this.api.patchServiceCIDR(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDRStatusWithHttpInfo(param: NetworkingV1ApiPatchServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDR>> {
        return this.api.patchServiceCIDRStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDRStatus(param: NetworkingV1ApiPatchServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<V1ServiceCIDR> {
        return this.api.patchServiceCIDRStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified IPAddress
     * @param param the request object
     */
    public readIPAddressWithHttpInfo(param: NetworkingV1ApiReadIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IPAddress>> {
        return this.api.readIPAddressWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified IPAddress
     * @param param the request object
     */
    public readIPAddress(param: NetworkingV1ApiReadIPAddressRequest, options?: ConfigurationOptions): Promise<V1IPAddress> {
        return this.api.readIPAddress(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified IngressClass
     * @param param the request object
     */
    public readIngressClassWithHttpInfo(param: NetworkingV1ApiReadIngressClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IngressClass>> {
        return this.api.readIngressClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified IngressClass
     * @param param the request object
     */
    public readIngressClass(param: NetworkingV1ApiReadIngressClassRequest, options?: ConfigurationOptions): Promise<V1IngressClass> {
        return this.api.readIngressClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngressWithHttpInfo(param: NetworkingV1ApiReadNamespacedIngressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Ingress>> {
        return this.api.readNamespacedIngressWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngress(param: NetworkingV1ApiReadNamespacedIngressRequest, options?: ConfigurationOptions): Promise<V1Ingress> {
        return this.api.readNamespacedIngress(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngressStatusWithHttpInfo(param: NetworkingV1ApiReadNamespacedIngressStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Ingress>> {
        return this.api.readNamespacedIngressStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified Ingress
     * @param param the request object
     */
    public readNamespacedIngressStatus(param: NetworkingV1ApiReadNamespacedIngressStatusRequest, options?: ConfigurationOptions): Promise<V1Ingress> {
        return this.api.readNamespacedIngressStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified NetworkPolicy
     * @param param the request object
     */
    public readNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiReadNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.readNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified NetworkPolicy
     * @param param the request object
     */
    public readNamespacedNetworkPolicy(param: NetworkingV1ApiReadNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<V1NetworkPolicy> {
        return this.api.readNamespacedNetworkPolicy(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDRWithHttpInfo(param: NetworkingV1ApiReadServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDR>> {
        return this.api.readServiceCIDRWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDR(param: NetworkingV1ApiReadServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1ServiceCIDR> {
        return this.api.readServiceCIDR(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDRStatusWithHttpInfo(param: NetworkingV1ApiReadServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDR>> {
        return this.api.readServiceCIDRStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDRStatus(param: NetworkingV1ApiReadServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<V1ServiceCIDR> {
        return this.api.readServiceCIDRStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified IPAddress
     * @param param the request object
     */
    public replaceIPAddressWithHttpInfo(param: NetworkingV1ApiReplaceIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IPAddress>> {
        return this.api.replaceIPAddressWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified IPAddress
     * @param param the request object
     */
    public replaceIPAddress(param: NetworkingV1ApiReplaceIPAddressRequest, options?: ConfigurationOptions): Promise<V1IPAddress> {
        return this.api.replaceIPAddress(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified IngressClass
     * @param param the request object
     */
    public replaceIngressClassWithHttpInfo(param: NetworkingV1ApiReplaceIngressClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1IngressClass>> {
        return this.api.replaceIngressClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified IngressClass
     * @param param the request object
     */
    public replaceIngressClass(param: NetworkingV1ApiReplaceIngressClassRequest, options?: ConfigurationOptions): Promise<V1IngressClass> {
        return this.api.replaceIngressClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngressWithHttpInfo(param: NetworkingV1ApiReplaceNamespacedIngressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Ingress>> {
        return this.api.replaceNamespacedIngressWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngress(param: NetworkingV1ApiReplaceNamespacedIngressRequest, options?: ConfigurationOptions): Promise<V1Ingress> {
        return this.api.replaceNamespacedIngress(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngressStatusWithHttpInfo(param: NetworkingV1ApiReplaceNamespacedIngressStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Ingress>> {
        return this.api.replaceNamespacedIngressStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified Ingress
     * @param param the request object
     */
    public replaceNamespacedIngressStatus(param: NetworkingV1ApiReplaceNamespacedIngressStatusRequest, options?: ConfigurationOptions): Promise<V1Ingress> {
        return this.api.replaceNamespacedIngressStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified NetworkPolicy
     * @param param the request object
     */
    public replaceNamespacedNetworkPolicyWithHttpInfo(param: NetworkingV1ApiReplaceNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1NetworkPolicy>> {
        return this.api.replaceNamespacedNetworkPolicyWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified NetworkPolicy
     * @param param the request object
     */
    public replaceNamespacedNetworkPolicy(param: NetworkingV1ApiReplaceNamespacedNetworkPolicyRequest, options?: ConfigurationOptions): Promise<V1NetworkPolicy> {
        return this.api.replaceNamespacedNetworkPolicy(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDRWithHttpInfo(param: NetworkingV1ApiReplaceServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDR>> {
        return this.api.replaceServiceCIDRWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDR(param: NetworkingV1ApiReplaceServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1ServiceCIDR> {
        return this.api.replaceServiceCIDR(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDRStatusWithHttpInfo(param: NetworkingV1ApiReplaceServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ServiceCIDR>> {
        return this.api.replaceServiceCIDRStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDRStatus(param: NetworkingV1ApiReplaceServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<V1ServiceCIDR> {
        return this.api.replaceServiceCIDRStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableNetworkingV1beta1Api } from "./ObservableAPI.js";
import { NetworkingV1beta1ApiRequestFactory, NetworkingV1beta1ApiResponseProcessor} from "../apis/NetworkingV1beta1Api.js";

export interface NetworkingV1beta1ApiCreateIPAddressRequest {
    /**
     * 
     * @type V1beta1IPAddress
     * @memberof NetworkingV1beta1ApicreateIPAddress
     */
    body: V1beta1IPAddress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateIPAddress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateIPAddress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateIPAddress
     */
    fieldValidation?: string
}

export interface NetworkingV1beta1ApiCreateServiceCIDRRequest {
    /**
     * 
     * @type V1beta1ServiceCIDR
     * @memberof NetworkingV1beta1ApicreateServiceCIDR
     */
    body: V1beta1ServiceCIDR
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateServiceCIDR
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateServiceCIDR
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApicreateServiceCIDR
     */
    fieldValidation?: string
}

export interface NetworkingV1beta1ApiDeleteCollectionIPAddressRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteCollectionIPAddress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1beta1ApiDeleteCollectionServiceCIDRRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteCollectionServiceCIDR
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1beta1ApiDeleteIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteIPAddress
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1beta1ApiDeleteServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NetworkingV1beta1ApideleteServiceCIDR
     */
    body?: V1DeleteOptions
}

export interface NetworkingV1beta1ApiGetAPIResourcesRequest {
}

export interface NetworkingV1beta1ApiListIPAddressRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApilistIPAddress
     */
    watch?: boolean
}

export interface NetworkingV1beta1ApiListServiceCIDRRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApilistServiceCIDR
     */
    watch?: boolean
}

export interface NetworkingV1beta1ApiPatchIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchIPAddress
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1beta1ApipatchIPAddress
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchIPAddress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchIPAddress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchIPAddress
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApipatchIPAddress
     */
    force?: boolean
}

export interface NetworkingV1beta1ApiPatchServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDR
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1beta1ApipatchServiceCIDR
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDR
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDR
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDR
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApipatchServiceCIDR
     */
    force?: boolean
}

export interface NetworkingV1beta1ApiPatchServiceCIDRStatusRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDRStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NetworkingV1beta1ApipatchServiceCIDRStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDRStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDRStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDRStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApipatchServiceCIDRStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NetworkingV1beta1ApipatchServiceCIDRStatus
     */
    force?: boolean
}

export interface NetworkingV1beta1ApiReadIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireadIPAddress
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireadIPAddress
     */
    pretty?: string
}

export interface NetworkingV1beta1ApiReadServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireadServiceCIDR
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireadServiceCIDR
     */
    pretty?: string
}

export interface NetworkingV1beta1ApiReadServiceCIDRStatusRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireadServiceCIDRStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireadServiceCIDRStatus
     */
    pretty?: string
}

export interface NetworkingV1beta1ApiReplaceIPAddressRequest {
    /**
     * name of the IPAddress
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceIPAddress
     */
    name: string
    /**
     * 
     * @type V1beta1IPAddress
     * @memberof NetworkingV1beta1ApireplaceIPAddress
     */
    body: V1beta1IPAddress
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceIPAddress
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceIPAddress
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceIPAddress
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceIPAddress
     */
    fieldValidation?: string
}

export interface NetworkingV1beta1ApiReplaceServiceCIDRRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDR
     */
    name: string
    /**
     * 
     * @type V1beta1ServiceCIDR
     * @memberof NetworkingV1beta1ApireplaceServiceCIDR
     */
    body: V1beta1ServiceCIDR
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDR
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDR
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDR
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDR
     */
    fieldValidation?: string
}

export interface NetworkingV1beta1ApiReplaceServiceCIDRStatusRequest {
    /**
     * name of the ServiceCIDR
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDRStatus
     */
    name: string
    /**
     * 
     * @type V1beta1ServiceCIDR
     * @memberof NetworkingV1beta1ApireplaceServiceCIDRStatus
     */
    body: V1beta1ServiceCIDR
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDRStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDRStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDRStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NetworkingV1beta1ApireplaceServiceCIDRStatus
     */
    fieldValidation?: string
}

export class ObjectNetworkingV1beta1Api {
    private api: ObservableNetworkingV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: NetworkingV1beta1ApiRequestFactory, responseProcessor?: NetworkingV1beta1ApiResponseProcessor) {
        this.api = new ObservableNetworkingV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create an IPAddress
     * @param param the request object
     */
    public createIPAddressWithHttpInfo(param: NetworkingV1beta1ApiCreateIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1IPAddress>> {
        return this.api.createIPAddressWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create an IPAddress
     * @param param the request object
     */
    public createIPAddress(param: NetworkingV1beta1ApiCreateIPAddressRequest, options?: ConfigurationOptions): Promise<V1beta1IPAddress> {
        return this.api.createIPAddress(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ServiceCIDR
     * @param param the request object
     */
    public createServiceCIDRWithHttpInfo(param: NetworkingV1beta1ApiCreateServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDR>> {
        return this.api.createServiceCIDRWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ServiceCIDR
     * @param param the request object
     */
    public createServiceCIDR(param: NetworkingV1beta1ApiCreateServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDR> {
        return this.api.createServiceCIDR(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of IPAddress
     * @param param the request object
     */
    public deleteCollectionIPAddressWithHttpInfo(param: NetworkingV1beta1ApiDeleteCollectionIPAddressRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionIPAddressWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of IPAddress
     * @param param the request object
     */
    public deleteCollectionIPAddress(param: NetworkingV1beta1ApiDeleteCollectionIPAddressRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionIPAddress(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceCIDR
     * @param param the request object
     */
    public deleteCollectionServiceCIDRWithHttpInfo(param: NetworkingV1beta1ApiDeleteCollectionServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionServiceCIDRWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ServiceCIDR
     * @param param the request object
     */
    public deleteCollectionServiceCIDR(param: NetworkingV1beta1ApiDeleteCollectionServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionServiceCIDR(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete an IPAddress
     * @param param the request object
     */
    public deleteIPAddressWithHttpInfo(param: NetworkingV1beta1ApiDeleteIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteIPAddressWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete an IPAddress
     * @param param the request object
     */
    public deleteIPAddress(param: NetworkingV1beta1ApiDeleteIPAddressRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteIPAddress(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceCIDR
     * @param param the request object
     */
    public deleteServiceCIDRWithHttpInfo(param: NetworkingV1beta1ApiDeleteServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteServiceCIDRWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ServiceCIDR
     * @param param the request object
     */
    public deleteServiceCIDR(param: NetworkingV1beta1ApiDeleteServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteServiceCIDR(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: NetworkingV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: NetworkingV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind IPAddress
     * @param param the request object
     */
    public listIPAddressWithHttpInfo(param: NetworkingV1beta1ApiListIPAddressRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1IPAddressList>> {
        return this.api.listIPAddressWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind IPAddress
     * @param param the request object
     */
    public listIPAddress(param: NetworkingV1beta1ApiListIPAddressRequest = {}, options?: ConfigurationOptions): Promise<V1beta1IPAddressList> {
        return this.api.listIPAddress(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceCIDR
     * @param param the request object
     */
    public listServiceCIDRWithHttpInfo(param: NetworkingV1beta1ApiListServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDRList>> {
        return this.api.listServiceCIDRWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ServiceCIDR
     * @param param the request object
     */
    public listServiceCIDR(param: NetworkingV1beta1ApiListServiceCIDRRequest = {}, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDRList> {
        return this.api.listServiceCIDR(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified IPAddress
     * @param param the request object
     */
    public patchIPAddressWithHttpInfo(param: NetworkingV1beta1ApiPatchIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1IPAddress>> {
        return this.api.patchIPAddressWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified IPAddress
     * @param param the request object
     */
    public patchIPAddress(param: NetworkingV1beta1ApiPatchIPAddressRequest, options?: ConfigurationOptions): Promise<V1beta1IPAddress> {
        return this.api.patchIPAddress(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDRWithHttpInfo(param: NetworkingV1beta1ApiPatchServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDR>> {
        return this.api.patchServiceCIDRWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDR(param: NetworkingV1beta1ApiPatchServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDR> {
        return this.api.patchServiceCIDR(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDRStatusWithHttpInfo(param: NetworkingV1beta1ApiPatchServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDR>> {
        return this.api.patchServiceCIDRStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ServiceCIDR
     * @param param the request object
     */
    public patchServiceCIDRStatus(param: NetworkingV1beta1ApiPatchServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDR> {
        return this.api.patchServiceCIDRStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified IPAddress
     * @param param the request object
     */
    public readIPAddressWithHttpInfo(param: NetworkingV1beta1ApiReadIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1IPAddress>> {
        return this.api.readIPAddressWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified IPAddress
     * @param param the request object
     */
    public readIPAddress(param: NetworkingV1beta1ApiReadIPAddressRequest, options?: ConfigurationOptions): Promise<V1beta1IPAddress> {
        return this.api.readIPAddress(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDRWithHttpInfo(param: NetworkingV1beta1ApiReadServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDR>> {
        return this.api.readServiceCIDRWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDR(param: NetworkingV1beta1ApiReadServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDR> {
        return this.api.readServiceCIDR(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDRStatusWithHttpInfo(param: NetworkingV1beta1ApiReadServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDR>> {
        return this.api.readServiceCIDRStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ServiceCIDR
     * @param param the request object
     */
    public readServiceCIDRStatus(param: NetworkingV1beta1ApiReadServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDR> {
        return this.api.readServiceCIDRStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified IPAddress
     * @param param the request object
     */
    public replaceIPAddressWithHttpInfo(param: NetworkingV1beta1ApiReplaceIPAddressRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1IPAddress>> {
        return this.api.replaceIPAddressWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified IPAddress
     * @param param the request object
     */
    public replaceIPAddress(param: NetworkingV1beta1ApiReplaceIPAddressRequest, options?: ConfigurationOptions): Promise<V1beta1IPAddress> {
        return this.api.replaceIPAddress(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDRWithHttpInfo(param: NetworkingV1beta1ApiReplaceServiceCIDRRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDR>> {
        return this.api.replaceServiceCIDRWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDR(param: NetworkingV1beta1ApiReplaceServiceCIDRRequest, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDR> {
        return this.api.replaceServiceCIDR(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDRStatusWithHttpInfo(param: NetworkingV1beta1ApiReplaceServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ServiceCIDR>> {
        return this.api.replaceServiceCIDRStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ServiceCIDR
     * @param param the request object
     */
    public replaceServiceCIDRStatus(param: NetworkingV1beta1ApiReplaceServiceCIDRStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ServiceCIDR> {
        return this.api.replaceServiceCIDRStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableNodeApi } from "./ObservableAPI.js";
import { NodeApiRequestFactory, NodeApiResponseProcessor} from "../apis/NodeApi.js";

export interface NodeApiGetAPIGroupRequest {
}

export class ObjectNodeApi {
    private api: ObservableNodeApi

    public constructor(configuration: Configuration, requestFactory?: NodeApiRequestFactory, responseProcessor?: NodeApiResponseProcessor) {
        this.api = new ObservableNodeApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: NodeApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: NodeApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableNodeV1Api } from "./ObservableAPI.js";
import { NodeV1ApiRequestFactory, NodeV1ApiResponseProcessor} from "../apis/NodeV1Api.js";

export interface NodeV1ApiCreateRuntimeClassRequest {
    /**
     * 
     * @type V1RuntimeClass
     * @memberof NodeV1ApicreateRuntimeClass
     */
    body: V1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApicreateRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApicreateRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApicreateRuntimeClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApicreateRuntimeClass
     */
    fieldValidation?: string
}

export interface NodeV1ApiDeleteCollectionRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1ApideleteCollectionRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1ApiDeleteRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof NodeV1ApideleteRuntimeClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApideleteRuntimeClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApideleteRuntimeClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApideleteRuntimeClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof NodeV1ApideleteRuntimeClass
     */
    body?: V1DeleteOptions
}

export interface NodeV1ApiGetAPIResourcesRequest {
}

export interface NodeV1ApiListRuntimeClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApilistRuntimeClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof NodeV1ApilistRuntimeClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApilistRuntimeClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApilistRuntimeClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof NodeV1ApilistRuntimeClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApilistRuntimeClass
     */
    watch?: boolean
}

export interface NodeV1ApiPatchRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof NodeV1ApipatchRuntimeClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApipatchRuntimeClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof NodeV1ApipatchRuntimeClass
     */
    force?: boolean
}

export interface NodeV1ApiReadRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApireadRuntimeClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApireadRuntimeClass
     */
    pretty?: string
}

export interface NodeV1ApiReplaceRuntimeClassRequest {
    /**
     * name of the RuntimeClass
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    name: string
    /**
     * 
     * @type V1RuntimeClass
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    body: V1RuntimeClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof NodeV1ApireplaceRuntimeClass
     */
    fieldValidation?: string
}

export class ObjectNodeV1Api {
    private api: ObservableNodeV1Api

    public constructor(configuration: Configuration, requestFactory?: NodeV1ApiRequestFactory, responseProcessor?: NodeV1ApiResponseProcessor) {
        this.api = new ObservableNodeV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClassWithHttpInfo(param: NodeV1ApiCreateRuntimeClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.createRuntimeClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a RuntimeClass
     * @param param the request object
     */
    public createRuntimeClass(param: NodeV1ApiCreateRuntimeClassRequest, options?: ConfigurationOptions): Promise<V1RuntimeClass> {
        return this.api.createRuntimeClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClassWithHttpInfo(param: NodeV1ApiDeleteCollectionRuntimeClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionRuntimeClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RuntimeClass
     * @param param the request object
     */
    public deleteCollectionRuntimeClass(param: NodeV1ApiDeleteCollectionRuntimeClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionRuntimeClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClassWithHttpInfo(param: NodeV1ApiDeleteRuntimeClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteRuntimeClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RuntimeClass
     * @param param the request object
     */
    public deleteRuntimeClass(param: NodeV1ApiDeleteRuntimeClassRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteRuntimeClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: NodeV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: NodeV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClassWithHttpInfo(param: NodeV1ApiListRuntimeClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1RuntimeClassList>> {
        return this.api.listRuntimeClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RuntimeClass
     * @param param the request object
     */
    public listRuntimeClass(param: NodeV1ApiListRuntimeClassRequest = {}, options?: ConfigurationOptions): Promise<V1RuntimeClassList> {
        return this.api.listRuntimeClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClassWithHttpInfo(param: NodeV1ApiPatchRuntimeClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.patchRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RuntimeClass
     * @param param the request object
     */
    public patchRuntimeClass(param: NodeV1ApiPatchRuntimeClassRequest, options?: ConfigurationOptions): Promise<V1RuntimeClass> {
        return this.api.patchRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClassWithHttpInfo(param: NodeV1ApiReadRuntimeClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.readRuntimeClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RuntimeClass
     * @param param the request object
     */
    public readRuntimeClass(param: NodeV1ApiReadRuntimeClassRequest, options?: ConfigurationOptions): Promise<V1RuntimeClass> {
        return this.api.readRuntimeClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClassWithHttpInfo(param: NodeV1ApiReplaceRuntimeClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RuntimeClass>> {
        return this.api.replaceRuntimeClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified RuntimeClass
     * @param param the request object
     */
    public replaceRuntimeClass(param: NodeV1ApiReplaceRuntimeClassRequest, options?: ConfigurationOptions): Promise<V1RuntimeClass> {
        return this.api.replaceRuntimeClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableOpenidApi } from "./ObservableAPI.js";
import { OpenidApiRequestFactory, OpenidApiResponseProcessor} from "../apis/OpenidApi.js";

export interface OpenidApiGetServiceAccountIssuerOpenIDKeysetRequest {
}

export class ObjectOpenidApi {
    private api: ObservableOpenidApi

    public constructor(configuration: Configuration, requestFactory?: OpenidApiRequestFactory, responseProcessor?: OpenidApiResponseProcessor) {
        this.api = new ObservableOpenidApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get service account issuer OpenID JSON Web Key Set (contains public token verification keys)
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDKeysetWithHttpInfo(param: OpenidApiGetServiceAccountIssuerOpenIDKeysetRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.getServiceAccountIssuerOpenIDKeysetWithHttpInfo( options).toPromise();
    }

    /**
     * get service account issuer OpenID JSON Web Key Set (contains public token verification keys)
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDKeyset(param: OpenidApiGetServiceAccountIssuerOpenIDKeysetRequest = {}, options?: ConfigurationOptions): Promise<string> {
        return this.api.getServiceAccountIssuerOpenIDKeyset( options).toPromise();
    }

}

import { ObservablePolicyApi } from "./ObservableAPI.js";
import { PolicyApiRequestFactory, PolicyApiResponseProcessor} from "../apis/PolicyApi.js";

export interface PolicyApiGetAPIGroupRequest {
}

export class ObjectPolicyApi {
    private api: ObservablePolicyApi

    public constructor(configuration: Configuration, requestFactory?: PolicyApiRequestFactory, responseProcessor?: PolicyApiResponseProcessor) {
        this.api = new ObservablePolicyApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: PolicyApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: PolicyApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservablePolicyV1Api } from "./ObservableAPI.js";
import { PolicyV1ApiRequestFactory, PolicyV1ApiResponseProcessor} from "../apis/PolicyV1Api.js";

export interface PolicyV1ApiCreateNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type V1PodDisruptionBudget
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    body: V1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApicreateNamespacedPodDisruptionBudget
     */
    fieldValidation?: string
}

export interface PolicyV1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1ApideleteCollectionNamespacedPodDisruptionBudget
     */
    body?: V1DeleteOptions
}

export interface PolicyV1ApiDeleteNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof PolicyV1ApideleteNamespacedPodDisruptionBudget
     */
    body?: V1DeleteOptions
}

export interface PolicyV1ApiGetAPIResourcesRequest {
}

export interface PolicyV1ApiListNamespacedPodDisruptionBudgetRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApilistNamespacedPodDisruptionBudget
     */
    watch?: boolean
}

export interface PolicyV1ApiListPodDisruptionBudgetForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApilistPodDisruptionBudgetForAllNamespaces
     */
    watch?: boolean
}

export interface PolicyV1ApiPatchNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudget
     */
    force?: boolean
}

export interface PolicyV1ApiPatchNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof PolicyV1ApipatchNamespacedPodDisruptionBudgetStatus
     */
    force?: boolean
}

export interface PolicyV1ApiReadNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudget
     */
    pretty?: string
}

export interface PolicyV1ApiReadNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireadNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
}

export interface PolicyV1ApiReplaceNamespacedPodDisruptionBudgetRequest {
    /**
     * name of the PodDisruptionBudget
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    namespace: string
    /**
     * 
     * @type V1PodDisruptionBudget
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    body: V1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudget
     */
    fieldValidation?: string
}

export interface PolicyV1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest {
    /**
     * name of the PodDisruptionBudget
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    namespace: string
    /**
     * 
     * @type V1PodDisruptionBudget
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    body: V1PodDisruptionBudget
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof PolicyV1ApireplaceNamespacedPodDisruptionBudgetStatus
     */
    fieldValidation?: string
}

export class ObjectPolicyV1Api {
    private api: ObservablePolicyV1Api

    public constructor(configuration: Configuration, requestFactory?: PolicyV1ApiRequestFactory, responseProcessor?: PolicyV1ApiResponseProcessor) {
        this.api = new ObservablePolicyV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a PodDisruptionBudget
     * @param param the request object
     */
    public createNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiCreateNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.createNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PodDisruptionBudget
     * @param param the request object
     */
    public createNamespacedPodDisruptionBudget(param: PolicyV1ApiCreateNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudget> {
        return this.api.createNamespacedPodDisruptionBudget(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of PodDisruptionBudget
     * @param param the request object
     */
    public deleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PodDisruptionBudget
     * @param param the request object
     */
    public deleteCollectionNamespacedPodDisruptionBudget(param: PolicyV1ApiDeleteCollectionNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedPodDisruptionBudget(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a PodDisruptionBudget
     * @param param the request object
     */
    public deleteNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiDeleteNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PodDisruptionBudget
     * @param param the request object
     */
    public deleteNamespacedPodDisruptionBudget(param: PolicyV1ApiDeleteNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedPodDisruptionBudget(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: PolicyV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: PolicyV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiListNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudgetList>> {
        return this.api.listNamespacedPodDisruptionBudgetWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listNamespacedPodDisruptionBudget(param: PolicyV1ApiListNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudgetList> {
        return this.api.listNamespacedPodDisruptionBudget(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listPodDisruptionBudgetForAllNamespacesWithHttpInfo(param: PolicyV1ApiListPodDisruptionBudgetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudgetList>> {
        return this.api.listPodDisruptionBudgetForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PodDisruptionBudget
     * @param param the request object
     */
    public listPodDisruptionBudgetForAllNamespaces(param: PolicyV1ApiListPodDisruptionBudgetForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1PodDisruptionBudgetList> {
        return this.api.listPodDisruptionBudgetForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.patchNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudget(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudget> {
        return this.api.patchNamespacedPodDisruptionBudget(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.patchNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public patchNamespacedPodDisruptionBudgetStatus(param: PolicyV1ApiPatchNamespacedPodDisruptionBudgetStatusRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudget> {
        return this.api.patchNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.readNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudget(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudget> {
        return this.api.readNamespacedPodDisruptionBudget(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.readNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public readNamespacedPodDisruptionBudgetStatus(param: PolicyV1ApiReadNamespacedPodDisruptionBudgetStatusRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudget> {
        return this.api.readNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetWithHttpInfo(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.replaceNamespacedPodDisruptionBudgetWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudget(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudget> {
        return this.api.replaceNamespacedPodDisruptionBudget(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetStatusWithHttpInfo(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PodDisruptionBudget>> {
        return this.api.replaceNamespacedPodDisruptionBudgetStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified PodDisruptionBudget
     * @param param the request object
     */
    public replaceNamespacedPodDisruptionBudgetStatus(param: PolicyV1ApiReplaceNamespacedPodDisruptionBudgetStatusRequest, options?: ConfigurationOptions): Promise<V1PodDisruptionBudget> {
        return this.api.replaceNamespacedPodDisruptionBudgetStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableRbacAuthorizationApi } from "./ObservableAPI.js";
import { RbacAuthorizationApiRequestFactory, RbacAuthorizationApiResponseProcessor} from "../apis/RbacAuthorizationApi.js";

export interface RbacAuthorizationApiGetAPIGroupRequest {
}

export class ObjectRbacAuthorizationApi {
    private api: ObservableRbacAuthorizationApi

    public constructor(configuration: Configuration, requestFactory?: RbacAuthorizationApiRequestFactory, responseProcessor?: RbacAuthorizationApiResponseProcessor) {
        this.api = new ObservableRbacAuthorizationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: RbacAuthorizationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: RbacAuthorizationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableRbacAuthorizationV1Api } from "./ObservableAPI.js";
import { RbacAuthorizationV1ApiRequestFactory, RbacAuthorizationV1ApiResponseProcessor} from "../apis/RbacAuthorizationV1Api.js";

export interface RbacAuthorizationV1ApiCreateClusterRoleRequest {
    /**
     * 
     * @type V1ClusterRole
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    body: V1ClusterRole
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRole
     */
    fieldValidation?: string
}

export interface RbacAuthorizationV1ApiCreateClusterRoleBindingRequest {
    /**
     * 
     * @type V1ClusterRoleBinding
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    body: V1ClusterRoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateClusterRoleBinding
     */
    fieldValidation?: string
}

export interface RbacAuthorizationV1ApiCreateNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type V1Role
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    body: V1Role
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRole
     */
    fieldValidation?: string
}

export interface RbacAuthorizationV1ApiCreateNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type V1RoleBinding
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    body: V1RoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApicreateNamespacedRoleBinding
     */
    fieldValidation?: string
}

export interface RbacAuthorizationV1ApiDeleteClusterRoleRequest {
    /**
     * name of the ClusterRole
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteClusterRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteClusterRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionClusterRoleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionClusterRoleBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionClusterRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteCollectionNamespacedRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteNamespacedRoleRequest {
    /**
     * name of the Role
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteNamespacedRole
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiDeleteNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof RbacAuthorizationV1ApideleteNamespacedRoleBinding
     */
    body?: V1DeleteOptions
}

export interface RbacAuthorizationV1ApiGetAPIResourcesRequest {
}

export interface RbacAuthorizationV1ApiListClusterRoleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRole
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListClusterRoleBindingRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistClusterRoleBinding
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListNamespacedRoleRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRole
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListNamespacedRoleBindingRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistNamespacedRoleBinding
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListRoleBindingForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleBindingForAllNamespaces
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiListRoleForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApilistRoleForAllNamespaces
     */
    watch?: boolean
}

export interface RbacAuthorizationV1ApiPatchClusterRoleRequest {
    /**
     * name of the ClusterRole
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    name: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchClusterRole
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiPatchClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    name: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchClusterRoleBinding
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiPatchNamespacedRoleRequest {
    /**
     * name of the Role
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchNamespacedRole
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiPatchNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof RbacAuthorizationV1ApipatchNamespacedRoleBinding
     */
    force?: boolean
}

export interface RbacAuthorizationV1ApiReadClusterRoleRequest {
    /**
     * name of the ClusterRole
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRole
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRole
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReadClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRoleBinding
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadClusterRoleBinding
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReadNamespacedRoleRequest {
    /**
     * name of the Role
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRole
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRole
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReadNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRoleBinding
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireadNamespacedRoleBinding
     */
    pretty?: string
}

export interface RbacAuthorizationV1ApiReplaceClusterRoleRequest {
    /**
     * name of the ClusterRole
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    name: string
    /**
     * 
     * @type V1ClusterRole
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    body: V1ClusterRole
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRole
     */
    fieldValidation?: string
}

export interface RbacAuthorizationV1ApiReplaceClusterRoleBindingRequest {
    /**
     * name of the ClusterRoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    name: string
    /**
     * 
     * @type V1ClusterRoleBinding
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    body: V1ClusterRoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceClusterRoleBinding
     */
    fieldValidation?: string
}

export interface RbacAuthorizationV1ApiReplaceNamespacedRoleRequest {
    /**
     * name of the Role
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    namespace: string
    /**
     * 
     * @type V1Role
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    body: V1Role
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRole
     */
    fieldValidation?: string
}

export interface RbacAuthorizationV1ApiReplaceNamespacedRoleBindingRequest {
    /**
     * name of the RoleBinding
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    namespace: string
    /**
     * 
     * @type V1RoleBinding
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    body: V1RoleBinding
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof RbacAuthorizationV1ApireplaceNamespacedRoleBinding
     */
    fieldValidation?: string
}

export class ObjectRbacAuthorizationV1Api {
    private api: ObservableRbacAuthorizationV1Api

    public constructor(configuration: Configuration, requestFactory?: RbacAuthorizationV1ApiRequestFactory, responseProcessor?: RbacAuthorizationV1ApiResponseProcessor) {
        this.api = new ObservableRbacAuthorizationV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a ClusterRole
     * @param param the request object
     */
    public createClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiCreateClusterRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.createClusterRoleWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ClusterRole
     * @param param the request object
     */
    public createClusterRole(param: RbacAuthorizationV1ApiCreateClusterRoleRequest, options?: ConfigurationOptions): Promise<V1ClusterRole> {
        return this.api.createClusterRole(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
    public createClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiCreateClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.createClusterRoleBindingWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ClusterRoleBinding
     * @param param the request object
     */
    public createClusterRoleBinding(param: RbacAuthorizationV1ApiCreateClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<V1ClusterRoleBinding> {
        return this.api.createClusterRoleBinding(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Role
     * @param param the request object
     */
    public createNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiCreateNamespacedRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Role>> {
        return this.api.createNamespacedRoleWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a Role
     * @param param the request object
     */
    public createNamespacedRole(param: RbacAuthorizationV1ApiCreateNamespacedRoleRequest, options?: ConfigurationOptions): Promise<V1Role> {
        return this.api.createNamespacedRole(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a RoleBinding
     * @param param the request object
     */
    public createNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiCreateNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.createNamespacedRoleBindingWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a RoleBinding
     * @param param the request object
     */
    public createNamespacedRoleBinding(param: RbacAuthorizationV1ApiCreateNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<V1RoleBinding> {
        return this.api.createNamespacedRoleBinding(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete a ClusterRole
     * @param param the request object
     */
    public deleteClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteClusterRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterRoleWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRole
     * @param param the request object
     */
    public deleteClusterRole(param: RbacAuthorizationV1ApiDeleteClusterRoleRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteClusterRole(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
    public deleteClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteClusterRoleBindingWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ClusterRoleBinding
     * @param param the request object
     */
    public deleteClusterRoleBinding(param: RbacAuthorizationV1ApiDeleteClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteClusterRoleBinding(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRole
     * @param param the request object
     */
    public deleteCollectionClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterRoleWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRole
     * @param param the request object
     */
    public deleteCollectionClusterRole(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionClusterRole(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
    public deleteCollectionClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionClusterRoleBindingWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ClusterRoleBinding
     * @param param the request object
     */
    public deleteCollectionClusterRoleBinding(param: RbacAuthorizationV1ApiDeleteCollectionClusterRoleBindingRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionClusterRoleBinding(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Role
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedRoleWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of Role
     * @param param the request object
     */
    public deleteCollectionNamespacedRole(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedRole(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RoleBinding
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedRoleBindingWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of RoleBinding
     * @param param the request object
     */
    public deleteCollectionNamespacedRoleBinding(param: RbacAuthorizationV1ApiDeleteCollectionNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedRoleBinding(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a Role
     * @param param the request object
     */
    public deleteNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiDeleteNamespacedRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedRoleWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a Role
     * @param param the request object
     */
    public deleteNamespacedRole(param: RbacAuthorizationV1ApiDeleteNamespacedRoleRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedRole(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RoleBinding
     * @param param the request object
     */
    public deleteNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiDeleteNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a RoleBinding
     * @param param the request object
     */
    public deleteNamespacedRoleBinding(param: RbacAuthorizationV1ApiDeleteNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedRoleBinding(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: RbacAuthorizationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: RbacAuthorizationV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
    public listClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiListClusterRoleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRoleList>> {
        return this.api.listClusterRoleWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRole
     * @param param the request object
     */
    public listClusterRole(param: RbacAuthorizationV1ApiListClusterRoleRequest = {}, options?: ConfigurationOptions): Promise<V1ClusterRoleList> {
        return this.api.listClusterRole(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
    public listClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiListClusterRoleBindingRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRoleBindingList>> {
        return this.api.listClusterRoleBindingWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ClusterRoleBinding
     * @param param the request object
     */
    public listClusterRoleBinding(param: RbacAuthorizationV1ApiListClusterRoleBindingRequest = {}, options?: ConfigurationOptions): Promise<V1ClusterRoleBindingList> {
        return this.api.listClusterRoleBinding(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiListNamespacedRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleList>> {
        return this.api.listNamespacedRoleWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listNamespacedRole(param: RbacAuthorizationV1ApiListNamespacedRoleRequest, options?: ConfigurationOptions): Promise<V1RoleList> {
        return this.api.listNamespacedRole(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiListNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleBindingList>> {
        return this.api.listNamespacedRoleBindingWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listNamespacedRoleBinding(param: RbacAuthorizationV1ApiListNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<V1RoleBindingList> {
        return this.api.listNamespacedRoleBinding(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listRoleBindingForAllNamespacesWithHttpInfo(param: RbacAuthorizationV1ApiListRoleBindingForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleBindingList>> {
        return this.api.listRoleBindingForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind RoleBinding
     * @param param the request object
     */
    public listRoleBindingForAllNamespaces(param: RbacAuthorizationV1ApiListRoleBindingForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1RoleBindingList> {
        return this.api.listRoleBindingForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listRoleForAllNamespacesWithHttpInfo(param: RbacAuthorizationV1ApiListRoleForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleList>> {
        return this.api.listRoleForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind Role
     * @param param the request object
     */
    public listRoleForAllNamespaces(param: RbacAuthorizationV1ApiListRoleForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1RoleList> {
        return this.api.listRoleForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
    public patchClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiPatchClusterRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.patchClusterRoleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRole
     * @param param the request object
     */
    public patchClusterRole(param: RbacAuthorizationV1ApiPatchClusterRoleRequest, options?: ConfigurationOptions): Promise<V1ClusterRole> {
        return this.api.patchClusterRole(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
    public patchClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiPatchClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.patchClusterRoleBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ClusterRoleBinding
     * @param param the request object
     */
    public patchClusterRoleBinding(param: RbacAuthorizationV1ApiPatchClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<V1ClusterRoleBinding> {
        return this.api.patchClusterRoleBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Role
     * @param param the request object
     */
    public patchNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiPatchNamespacedRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Role>> {
        return this.api.patchNamespacedRoleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified Role
     * @param param the request object
     */
    public patchNamespacedRole(param: RbacAuthorizationV1ApiPatchNamespacedRoleRequest, options?: ConfigurationOptions): Promise<V1Role> {
        return this.api.patchNamespacedRole(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
    public patchNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiPatchNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.patchNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified RoleBinding
     * @param param the request object
     */
    public patchNamespacedRoleBinding(param: RbacAuthorizationV1ApiPatchNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<V1RoleBinding> {
        return this.api.patchNamespacedRoleBinding(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified ClusterRole
     * @param param the request object
     */
    public readClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiReadClusterRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.readClusterRoleWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRole
     * @param param the request object
     */
    public readClusterRole(param: RbacAuthorizationV1ApiReadClusterRoleRequest, options?: ConfigurationOptions): Promise<V1ClusterRole> {
        return this.api.readClusterRole(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
    public readClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReadClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.readClusterRoleBindingWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ClusterRoleBinding
     * @param param the request object
     */
    public readClusterRoleBinding(param: RbacAuthorizationV1ApiReadClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<V1ClusterRoleBinding> {
        return this.api.readClusterRoleBinding(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Role
     * @param param the request object
     */
    public readNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiReadNamespacedRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Role>> {
        return this.api.readNamespacedRoleWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified Role
     * @param param the request object
     */
    public readNamespacedRole(param: RbacAuthorizationV1ApiReadNamespacedRoleRequest, options?: ConfigurationOptions): Promise<V1Role> {
        return this.api.readNamespacedRole(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RoleBinding
     * @param param the request object
     */
    public readNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReadNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.readNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified RoleBinding
     * @param param the request object
     */
    public readNamespacedRoleBinding(param: RbacAuthorizationV1ApiReadNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<V1RoleBinding> {
        return this.api.readNamespacedRoleBinding(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified ClusterRole
     * @param param the request object
     */
    public replaceClusterRoleWithHttpInfo(param: RbacAuthorizationV1ApiReplaceClusterRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRole>> {
        return this.api.replaceClusterRoleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ClusterRole
     * @param param the request object
     */
    public replaceClusterRole(param: RbacAuthorizationV1ApiReplaceClusterRoleRequest, options?: ConfigurationOptions): Promise<V1ClusterRole> {
        return this.api.replaceClusterRole(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
    public replaceClusterRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReplaceClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1ClusterRoleBinding>> {
        return this.api.replaceClusterRoleBindingWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ClusterRoleBinding
     * @param param the request object
     */
    public replaceClusterRoleBinding(param: RbacAuthorizationV1ApiReplaceClusterRoleBindingRequest, options?: ConfigurationOptions): Promise<V1ClusterRoleBinding> {
        return this.api.replaceClusterRoleBinding(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Role
     * @param param the request object
     */
    public replaceNamespacedRoleWithHttpInfo(param: RbacAuthorizationV1ApiReplaceNamespacedRoleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Role>> {
        return this.api.replaceNamespacedRoleWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified Role
     * @param param the request object
     */
    public replaceNamespacedRole(param: RbacAuthorizationV1ApiReplaceNamespacedRoleRequest, options?: ConfigurationOptions): Promise<V1Role> {
        return this.api.replaceNamespacedRole(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified RoleBinding
     * @param param the request object
     */
    public replaceNamespacedRoleBindingWithHttpInfo(param: RbacAuthorizationV1ApiReplaceNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1RoleBinding>> {
        return this.api.replaceNamespacedRoleBindingWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified RoleBinding
     * @param param the request object
     */
    public replaceNamespacedRoleBinding(param: RbacAuthorizationV1ApiReplaceNamespacedRoleBindingRequest, options?: ConfigurationOptions): Promise<V1RoleBinding> {
        return this.api.replaceNamespacedRoleBinding(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableResourceApi } from "./ObservableAPI.js";
import { ResourceApiRequestFactory, ResourceApiResponseProcessor} from "../apis/ResourceApi.js";

export interface ResourceApiGetAPIGroupRequest {
}

export class ObjectResourceApi {
    private api: ObservableResourceApi

    public constructor(configuration: Configuration, requestFactory?: ResourceApiRequestFactory, responseProcessor?: ResourceApiResponseProcessor) {
        this.api = new ObservableResourceApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: ResourceApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: ResourceApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableResourceV1alpha3Api } from "./ObservableAPI.js";
import { ResourceV1alpha3ApiRequestFactory, ResourceV1alpha3ApiResponseProcessor} from "../apis/ResourceV1alpha3Api.js";

export interface ResourceV1alpha3ApiCreateDeviceClassRequest {
    /**
     * 
     * @type V1alpha3DeviceClass
     * @memberof ResourceV1alpha3ApicreateDeviceClass
     */
    body: V1alpha3DeviceClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceClass
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiCreateDeviceTaintRuleRequest {
    /**
     * 
     * @type V1alpha3DeviceTaintRule
     * @memberof ResourceV1alpha3ApicreateDeviceTaintRule
     */
    body: V1alpha3DeviceTaintRule
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceTaintRule
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceTaintRule
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceTaintRule
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateDeviceTaintRule
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiCreateNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type V1alpha3ResourceClaim
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaim
     */
    body: V1alpha3ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaim
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiCreateNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type V1alpha3ResourceClaimTemplate
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaimTemplate
     */
    body: V1alpha3ResourceClaimTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiCreateResourceSliceRequest {
    /**
     * 
     * @type V1alpha3ResourceSlice
     * @memberof ResourceV1alpha3ApicreateResourceSlice
     */
    body: V1alpha3ResourceSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApicreateResourceSlice
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiDeleteCollectionDeviceClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceClass
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteCollectionDeviceTaintRuleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteCollectionDeviceTaintRule
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteCollectionNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaim
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteCollectionNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteCollectionNamespacedResourceClaimTemplate
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteCollectionResourceSliceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteCollectionResourceSlice
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteDeviceClass
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteDeviceTaintRuleRequest {
    /**
     * name of the DeviceTaintRule
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteDeviceTaintRule
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaim
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteNamespacedResourceClaimTemplate
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiDeleteResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1alpha3ApideleteResourceSlice
     */
    body?: V1DeleteOptions
}

export interface ResourceV1alpha3ApiGetAPIResourcesRequest {
}

export interface ResourceV1alpha3ApiListDeviceClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistDeviceClass
     */
    watch?: boolean
}

export interface ResourceV1alpha3ApiListDeviceTaintRuleRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistDeviceTaintRule
     */
    watch?: boolean
}

export interface ResourceV1alpha3ApiListNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaim
     */
    watch?: boolean
}

export interface ResourceV1alpha3ApiListNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistNamespacedResourceClaimTemplate
     */
    watch?: boolean
}

export interface ResourceV1alpha3ApiListResourceClaimForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceClaimForAllNamespaces
     */
    watch?: boolean
}

export interface ResourceV1alpha3ApiListResourceClaimTemplateForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceClaimTemplateForAllNamespaces
     */
    watch?: boolean
}

export interface ResourceV1alpha3ApiListResourceSliceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApilistResourceSlice
     */
    watch?: boolean
}

export interface ResourceV1alpha3ApiPatchDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ResourceV1alpha3ApipatchDeviceClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApipatchDeviceClass
     */
    force?: boolean
}

export interface ResourceV1alpha3ApiPatchDeviceTaintRuleRequest {
    /**
     * name of the DeviceTaintRule
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceTaintRule
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ResourceV1alpha3ApipatchDeviceTaintRule
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceTaintRule
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceTaintRule
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceTaintRule
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchDeviceTaintRule
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApipatchDeviceTaintRule
     */
    force?: boolean
}

export interface ResourceV1alpha3ApiPatchNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaim
     */
    force?: boolean
}

export interface ResourceV1alpha3ApiPatchNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimStatus
     */
    force?: boolean
}

export interface ResourceV1alpha3ApiPatchNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApipatchNamespacedResourceClaimTemplate
     */
    force?: boolean
}

export interface ResourceV1alpha3ApiPatchResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchResourceSlice
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ResourceV1alpha3ApipatchResourceSlice
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApipatchResourceSlice
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1alpha3ApipatchResourceSlice
     */
    force?: boolean
}

export interface ResourceV1alpha3ApiReadDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadDeviceClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadDeviceClass
     */
    pretty?: string
}

export interface ResourceV1alpha3ApiReadDeviceTaintRuleRequest {
    /**
     * name of the DeviceTaintRule
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadDeviceTaintRule
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadDeviceTaintRule
     */
    pretty?: string
}

export interface ResourceV1alpha3ApiReadNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaim
     */
    pretty?: string
}

export interface ResourceV1alpha3ApiReadNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaimStatus
     */
    pretty?: string
}

export interface ResourceV1alpha3ApiReadNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadNamespacedResourceClaimTemplate
     */
    pretty?: string
}

export interface ResourceV1alpha3ApiReadResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadResourceSlice
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireadResourceSlice
     */
    pretty?: string
}

export interface ResourceV1alpha3ApiReplaceDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceClass
     */
    name: string
    /**
     * 
     * @type V1alpha3DeviceClass
     * @memberof ResourceV1alpha3ApireplaceDeviceClass
     */
    body: V1alpha3DeviceClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceClass
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiReplaceDeviceTaintRuleRequest {
    /**
     * name of the DeviceTaintRule
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceTaintRule
     */
    name: string
    /**
     * 
     * @type V1alpha3DeviceTaintRule
     * @memberof ResourceV1alpha3ApireplaceDeviceTaintRule
     */
    body: V1alpha3DeviceTaintRule
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceTaintRule
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceTaintRule
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceTaintRule
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceDeviceTaintRule
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiReplaceNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type V1alpha3ResourceClaim
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaim
     */
    body: V1alpha3ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaim
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiReplaceNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * 
     * @type V1alpha3ResourceClaim
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimStatus
     */
    body: V1alpha3ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimStatus
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiReplaceNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type V1alpha3ResourceClaimTemplate
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimTemplate
     */
    body: V1alpha3ResourceClaimTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
}

export interface ResourceV1alpha3ApiReplaceResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceResourceSlice
     */
    name: string
    /**
     * 
     * @type V1alpha3ResourceSlice
     * @memberof ResourceV1alpha3ApireplaceResourceSlice
     */
    body: V1alpha3ResourceSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1alpha3ApireplaceResourceSlice
     */
    fieldValidation?: string
}

export class ObjectResourceV1alpha3Api {
    private api: ObservableResourceV1alpha3Api

    public constructor(configuration: Configuration, requestFactory?: ResourceV1alpha3ApiRequestFactory, responseProcessor?: ResourceV1alpha3ApiResponseProcessor) {
        this.api = new ObservableResourceV1alpha3Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a DeviceClass
     * @param param the request object
     */
    public createDeviceClassWithHttpInfo(param: ResourceV1alpha3ApiCreateDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceClass>> {
        return this.api.createDeviceClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a DeviceClass
     * @param param the request object
     */
    public createDeviceClass(param: ResourceV1alpha3ApiCreateDeviceClassRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceClass> {
        return this.api.createDeviceClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a DeviceTaintRule
     * @param param the request object
     */
    public createDeviceTaintRuleWithHttpInfo(param: ResourceV1alpha3ApiCreateDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceTaintRule>> {
        return this.api.createDeviceTaintRuleWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a DeviceTaintRule
     * @param param the request object
     */
    public createDeviceTaintRule(param: ResourceV1alpha3ApiCreateDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceTaintRule> {
        return this.api.createDeviceTaintRule(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaim
     * @param param the request object
     */
    public createNamespacedResourceClaimWithHttpInfo(param: ResourceV1alpha3ApiCreateNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.createNamespacedResourceClaimWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaim
     * @param param the request object
     */
    public createNamespacedResourceClaim(param: ResourceV1alpha3ApiCreateNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.createNamespacedResourceClaim(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaimTemplate
     * @param param the request object
     */
    public createNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1alpha3ApiCreateNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimTemplate>> {
        return this.api.createNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaimTemplate
     * @param param the request object
     */
    public createNamespacedResourceClaimTemplate(param: ResourceV1alpha3ApiCreateNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimTemplate> {
        return this.api.createNamespacedResourceClaimTemplate(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceSlice
     * @param param the request object
     */
    public createResourceSliceWithHttpInfo(param: ResourceV1alpha3ApiCreateResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceSlice>> {
        return this.api.createResourceSliceWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceSlice
     * @param param the request object
     */
    public createResourceSlice(param: ResourceV1alpha3ApiCreateResourceSliceRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceSlice> {
        return this.api.createResourceSlice(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of DeviceClass
     * @param param the request object
     */
    public deleteCollectionDeviceClassWithHttpInfo(param: ResourceV1alpha3ApiDeleteCollectionDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionDeviceClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DeviceClass
     * @param param the request object
     */
    public deleteCollectionDeviceClass(param: ResourceV1alpha3ApiDeleteCollectionDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionDeviceClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DeviceTaintRule
     * @param param the request object
     */
    public deleteCollectionDeviceTaintRuleWithHttpInfo(param: ResourceV1alpha3ApiDeleteCollectionDeviceTaintRuleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionDeviceTaintRuleWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DeviceTaintRule
     * @param param the request object
     */
    public deleteCollectionDeviceTaintRule(param: ResourceV1alpha3ApiDeleteCollectionDeviceTaintRuleRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionDeviceTaintRule(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimWithHttpInfo(param: ResourceV1alpha3ApiDeleteCollectionNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceClaimWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaim(param: ResourceV1alpha3ApiDeleteCollectionNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceClaim(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaimTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1alpha3ApiDeleteCollectionNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaimTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimTemplate(param: ResourceV1alpha3ApiDeleteCollectionNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceClaimTemplate(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceSlice
     * @param param the request object
     */
    public deleteCollectionResourceSliceWithHttpInfo(param: ResourceV1alpha3ApiDeleteCollectionResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionResourceSliceWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceSlice
     * @param param the request object
     */
    public deleteCollectionResourceSlice(param: ResourceV1alpha3ApiDeleteCollectionResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionResourceSlice(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceClass
     * @param param the request object
     */
    public deleteDeviceClassWithHttpInfo(param: ResourceV1alpha3ApiDeleteDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceClass>> {
        return this.api.deleteDeviceClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceClass
     * @param param the request object
     */
    public deleteDeviceClass(param: ResourceV1alpha3ApiDeleteDeviceClassRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceClass> {
        return this.api.deleteDeviceClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceTaintRule
     * @param param the request object
     */
    public deleteDeviceTaintRuleWithHttpInfo(param: ResourceV1alpha3ApiDeleteDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceTaintRule>> {
        return this.api.deleteDeviceTaintRuleWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceTaintRule
     * @param param the request object
     */
    public deleteDeviceTaintRule(param: ResourceV1alpha3ApiDeleteDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceTaintRule> {
        return this.api.deleteDeviceTaintRule(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaim
     * @param param the request object
     */
    public deleteNamespacedResourceClaimWithHttpInfo(param: ResourceV1alpha3ApiDeleteNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.deleteNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaim
     * @param param the request object
     */
    public deleteNamespacedResourceClaim(param: ResourceV1alpha3ApiDeleteNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.deleteNamespacedResourceClaim(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaimTemplate
     * @param param the request object
     */
    public deleteNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1alpha3ApiDeleteNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimTemplate>> {
        return this.api.deleteNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaimTemplate
     * @param param the request object
     */
    public deleteNamespacedResourceClaimTemplate(param: ResourceV1alpha3ApiDeleteNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimTemplate> {
        return this.api.deleteNamespacedResourceClaimTemplate(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceSlice
     * @param param the request object
     */
    public deleteResourceSliceWithHttpInfo(param: ResourceV1alpha3ApiDeleteResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceSlice>> {
        return this.api.deleteResourceSliceWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceSlice
     * @param param the request object
     */
    public deleteResourceSlice(param: ResourceV1alpha3ApiDeleteResourceSliceRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceSlice> {
        return this.api.deleteResourceSlice(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: ResourceV1alpha3ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: ResourceV1alpha3ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceClass
     * @param param the request object
     */
    public listDeviceClassWithHttpInfo(param: ResourceV1alpha3ApiListDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceClassList>> {
        return this.api.listDeviceClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceClass
     * @param param the request object
     */
    public listDeviceClass(param: ResourceV1alpha3ApiListDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<V1alpha3DeviceClassList> {
        return this.api.listDeviceClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceTaintRule
     * @param param the request object
     */
    public listDeviceTaintRuleWithHttpInfo(param: ResourceV1alpha3ApiListDeviceTaintRuleRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceTaintRuleList>> {
        return this.api.listDeviceTaintRuleWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceTaintRule
     * @param param the request object
     */
    public listDeviceTaintRule(param: ResourceV1alpha3ApiListDeviceTaintRuleRequest = {}, options?: ConfigurationOptions): Promise<V1alpha3DeviceTaintRuleList> {
        return this.api.listDeviceTaintRule(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listNamespacedResourceClaimWithHttpInfo(param: ResourceV1alpha3ApiListNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimList>> {
        return this.api.listNamespacedResourceClaimWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listNamespacedResourceClaim(param: ResourceV1alpha3ApiListNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimList> {
        return this.api.listNamespacedResourceClaim(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1alpha3ApiListNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimTemplateList>> {
        return this.api.listNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listNamespacedResourceClaimTemplate(param: ResourceV1alpha3ApiListNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimTemplateList> {
        return this.api.listNamespacedResourceClaimTemplate(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listResourceClaimForAllNamespacesWithHttpInfo(param: ResourceV1alpha3ApiListResourceClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimList>> {
        return this.api.listResourceClaimForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listResourceClaimForAllNamespaces(param: ResourceV1alpha3ApiListResourceClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimList> {
        return this.api.listResourceClaimForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listResourceClaimTemplateForAllNamespacesWithHttpInfo(param: ResourceV1alpha3ApiListResourceClaimTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimTemplateList>> {
        return this.api.listResourceClaimTemplateForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listResourceClaimTemplateForAllNamespaces(param: ResourceV1alpha3ApiListResourceClaimTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimTemplateList> {
        return this.api.listResourceClaimTemplateForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceSlice
     * @param param the request object
     */
    public listResourceSliceWithHttpInfo(param: ResourceV1alpha3ApiListResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceSliceList>> {
        return this.api.listResourceSliceWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceSlice
     * @param param the request object
     */
    public listResourceSlice(param: ResourceV1alpha3ApiListResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<V1alpha3ResourceSliceList> {
        return this.api.listResourceSlice(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified DeviceClass
     * @param param the request object
     */
    public patchDeviceClassWithHttpInfo(param: ResourceV1alpha3ApiPatchDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceClass>> {
        return this.api.patchDeviceClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DeviceClass
     * @param param the request object
     */
    public patchDeviceClass(param: ResourceV1alpha3ApiPatchDeviceClassRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceClass> {
        return this.api.patchDeviceClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DeviceTaintRule
     * @param param the request object
     */
    public patchDeviceTaintRuleWithHttpInfo(param: ResourceV1alpha3ApiPatchDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceTaintRule>> {
        return this.api.patchDeviceTaintRuleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DeviceTaintRule
     * @param param the request object
     */
    public patchDeviceTaintRule(param: ResourceV1alpha3ApiPatchDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceTaintRule> {
        return this.api.patchDeviceTaintRule(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimWithHttpInfo(param: ResourceV1alpha3ApiPatchNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.patchNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaim(param: ResourceV1alpha3ApiPatchNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.patchNamespacedResourceClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1alpha3ApiPatchNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.patchNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimStatus(param: ResourceV1alpha3ApiPatchNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.patchNamespacedResourceClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaimTemplate
     * @param param the request object
     */
    public patchNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1alpha3ApiPatchNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimTemplate>> {
        return this.api.patchNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaimTemplate
     * @param param the request object
     */
    public patchNamespacedResourceClaimTemplate(param: ResourceV1alpha3ApiPatchNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimTemplate> {
        return this.api.patchNamespacedResourceClaimTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceSlice
     * @param param the request object
     */
    public patchResourceSliceWithHttpInfo(param: ResourceV1alpha3ApiPatchResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceSlice>> {
        return this.api.patchResourceSliceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceSlice
     * @param param the request object
     */
    public patchResourceSlice(param: ResourceV1alpha3ApiPatchResourceSliceRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceSlice> {
        return this.api.patchResourceSlice(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified DeviceClass
     * @param param the request object
     */
    public readDeviceClassWithHttpInfo(param: ResourceV1alpha3ApiReadDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceClass>> {
        return this.api.readDeviceClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DeviceClass
     * @param param the request object
     */
    public readDeviceClass(param: ResourceV1alpha3ApiReadDeviceClassRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceClass> {
        return this.api.readDeviceClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DeviceTaintRule
     * @param param the request object
     */
    public readDeviceTaintRuleWithHttpInfo(param: ResourceV1alpha3ApiReadDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceTaintRule>> {
        return this.api.readDeviceTaintRuleWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DeviceTaintRule
     * @param param the request object
     */
    public readDeviceTaintRule(param: ResourceV1alpha3ApiReadDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceTaintRule> {
        return this.api.readDeviceTaintRule(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimWithHttpInfo(param: ResourceV1alpha3ApiReadNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.readNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaim(param: ResourceV1alpha3ApiReadNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.readNamespacedResourceClaim(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1alpha3ApiReadNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.readNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimStatus(param: ResourceV1alpha3ApiReadNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.readNamespacedResourceClaimStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaimTemplate
     * @param param the request object
     */
    public readNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1alpha3ApiReadNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimTemplate>> {
        return this.api.readNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaimTemplate
     * @param param the request object
     */
    public readNamespacedResourceClaimTemplate(param: ResourceV1alpha3ApiReadNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimTemplate> {
        return this.api.readNamespacedResourceClaimTemplate(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceSlice
     * @param param the request object
     */
    public readResourceSliceWithHttpInfo(param: ResourceV1alpha3ApiReadResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceSlice>> {
        return this.api.readResourceSliceWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceSlice
     * @param param the request object
     */
    public readResourceSlice(param: ResourceV1alpha3ApiReadResourceSliceRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceSlice> {
        return this.api.readResourceSlice(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified DeviceClass
     * @param param the request object
     */
    public replaceDeviceClassWithHttpInfo(param: ResourceV1alpha3ApiReplaceDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceClass>> {
        return this.api.replaceDeviceClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified DeviceClass
     * @param param the request object
     */
    public replaceDeviceClass(param: ResourceV1alpha3ApiReplaceDeviceClassRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceClass> {
        return this.api.replaceDeviceClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified DeviceTaintRule
     * @param param the request object
     */
    public replaceDeviceTaintRuleWithHttpInfo(param: ResourceV1alpha3ApiReplaceDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3DeviceTaintRule>> {
        return this.api.replaceDeviceTaintRuleWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified DeviceTaintRule
     * @param param the request object
     */
    public replaceDeviceTaintRule(param: ResourceV1alpha3ApiReplaceDeviceTaintRuleRequest, options?: ConfigurationOptions): Promise<V1alpha3DeviceTaintRule> {
        return this.api.replaceDeviceTaintRule(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimWithHttpInfo(param: ResourceV1alpha3ApiReplaceNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.replaceNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaim(param: ResourceV1alpha3ApiReplaceNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.replaceNamespacedResourceClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1alpha3ApiReplaceNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaim>> {
        return this.api.replaceNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimStatus(param: ResourceV1alpha3ApiReplaceNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaim> {
        return this.api.replaceNamespacedResourceClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaimTemplate
     * @param param the request object
     */
    public replaceNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1alpha3ApiReplaceNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceClaimTemplate>> {
        return this.api.replaceNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaimTemplate
     * @param param the request object
     */
    public replaceNamespacedResourceClaimTemplate(param: ResourceV1alpha3ApiReplaceNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceClaimTemplate> {
        return this.api.replaceNamespacedResourceClaimTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceSlice
     * @param param the request object
     */
    public replaceResourceSliceWithHttpInfo(param: ResourceV1alpha3ApiReplaceResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha3ResourceSlice>> {
        return this.api.replaceResourceSliceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceSlice
     * @param param the request object
     */
    public replaceResourceSlice(param: ResourceV1alpha3ApiReplaceResourceSliceRequest, options?: ConfigurationOptions): Promise<V1alpha3ResourceSlice> {
        return this.api.replaceResourceSlice(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableResourceV1beta1Api } from "./ObservableAPI.js";
import { ResourceV1beta1ApiRequestFactory, ResourceV1beta1ApiResponseProcessor} from "../apis/ResourceV1beta1Api.js";

export interface ResourceV1beta1ApiCreateDeviceClassRequest {
    /**
     * 
     * @type V1beta1DeviceClass
     * @memberof ResourceV1beta1ApicreateDeviceClass
     */
    body: V1beta1DeviceClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateDeviceClass
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiCreateNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type V1beta1ResourceClaim
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaim
     */
    body: V1beta1ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaim
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiCreateNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type V1beta1ResourceClaimTemplate
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaimTemplate
     */
    body: V1beta1ResourceClaimTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiCreateResourceSliceRequest {
    /**
     * 
     * @type V1beta1ResourceSlice
     * @memberof ResourceV1beta1ApicreateResourceSlice
     */
    body: V1beta1ResourceSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApicreateResourceSlice
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiDeleteCollectionDeviceClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteCollectionDeviceClass
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiDeleteCollectionNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaim
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiDeleteCollectionNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteCollectionNamespacedResourceClaimTemplate
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiDeleteCollectionResourceSliceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteCollectionResourceSlice
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiDeleteDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteDeviceClass
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiDeleteNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaim
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiDeleteNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteNamespacedResourceClaimTemplate
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiDeleteResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta1ApideleteResourceSlice
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta1ApiGetAPIResourcesRequest {
}

export interface ResourceV1beta1ApiListDeviceClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistDeviceClass
     */
    watch?: boolean
}

export interface ResourceV1beta1ApiListNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaim
     */
    watch?: boolean
}

export interface ResourceV1beta1ApiListNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistNamespacedResourceClaimTemplate
     */
    watch?: boolean
}

export interface ResourceV1beta1ApiListResourceClaimForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceClaimForAllNamespaces
     */
    watch?: boolean
}

export interface ResourceV1beta1ApiListResourceClaimTemplateForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceClaimTemplateForAllNamespaces
     */
    watch?: boolean
}

export interface ResourceV1beta1ApiListResourceSliceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApilistResourceSlice
     */
    watch?: boolean
}

export interface ResourceV1beta1ApiPatchDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchDeviceClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta1ApipatchDeviceClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchDeviceClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApipatchDeviceClass
     */
    force?: boolean
}

export interface ResourceV1beta1ApiPatchNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaim
     */
    force?: boolean
}

export interface ResourceV1beta1ApiPatchNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimStatus
     */
    force?: boolean
}

export interface ResourceV1beta1ApiPatchNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApipatchNamespacedResourceClaimTemplate
     */
    force?: boolean
}

export interface ResourceV1beta1ApiPatchResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchResourceSlice
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta1ApipatchResourceSlice
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApipatchResourceSlice
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta1ApipatchResourceSlice
     */
    force?: boolean
}

export interface ResourceV1beta1ApiReadDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadDeviceClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadDeviceClass
     */
    pretty?: string
}

export interface ResourceV1beta1ApiReadNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaim
     */
    pretty?: string
}

export interface ResourceV1beta1ApiReadNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaimStatus
     */
    pretty?: string
}

export interface ResourceV1beta1ApiReadNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadNamespacedResourceClaimTemplate
     */
    pretty?: string
}

export interface ResourceV1beta1ApiReadResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadResourceSlice
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireadResourceSlice
     */
    pretty?: string
}

export interface ResourceV1beta1ApiReplaceDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceDeviceClass
     */
    name: string
    /**
     * 
     * @type V1beta1DeviceClass
     * @memberof ResourceV1beta1ApireplaceDeviceClass
     */
    body: V1beta1DeviceClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceDeviceClass
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiReplaceNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type V1beta1ResourceClaim
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaim
     */
    body: V1beta1ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaim
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiReplaceNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * 
     * @type V1beta1ResourceClaim
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimStatus
     */
    body: V1beta1ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimStatus
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiReplaceNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type V1beta1ResourceClaimTemplate
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimTemplate
     */
    body: V1beta1ResourceClaimTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
}

export interface ResourceV1beta1ApiReplaceResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceResourceSlice
     */
    name: string
    /**
     * 
     * @type V1beta1ResourceSlice
     * @memberof ResourceV1beta1ApireplaceResourceSlice
     */
    body: V1beta1ResourceSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta1ApireplaceResourceSlice
     */
    fieldValidation?: string
}

export class ObjectResourceV1beta1Api {
    private api: ObservableResourceV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: ResourceV1beta1ApiRequestFactory, responseProcessor?: ResourceV1beta1ApiResponseProcessor) {
        this.api = new ObservableResourceV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a DeviceClass
     * @param param the request object
     */
    public createDeviceClassWithHttpInfo(param: ResourceV1beta1ApiCreateDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1DeviceClass>> {
        return this.api.createDeviceClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a DeviceClass
     * @param param the request object
     */
    public createDeviceClass(param: ResourceV1beta1ApiCreateDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta1DeviceClass> {
        return this.api.createDeviceClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaim
     * @param param the request object
     */
    public createNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta1ApiCreateNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.createNamespacedResourceClaimWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaim
     * @param param the request object
     */
    public createNamespacedResourceClaim(param: ResourceV1beta1ApiCreateNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.createNamespacedResourceClaim(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaimTemplate
     * @param param the request object
     */
    public createNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta1ApiCreateNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimTemplate>> {
        return this.api.createNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaimTemplate
     * @param param the request object
     */
    public createNamespacedResourceClaimTemplate(param: ResourceV1beta1ApiCreateNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimTemplate> {
        return this.api.createNamespacedResourceClaimTemplate(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceSlice
     * @param param the request object
     */
    public createResourceSliceWithHttpInfo(param: ResourceV1beta1ApiCreateResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceSlice>> {
        return this.api.createResourceSliceWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceSlice
     * @param param the request object
     */
    public createResourceSlice(param: ResourceV1beta1ApiCreateResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceSlice> {
        return this.api.createResourceSlice(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of DeviceClass
     * @param param the request object
     */
    public deleteCollectionDeviceClassWithHttpInfo(param: ResourceV1beta1ApiDeleteCollectionDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionDeviceClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DeviceClass
     * @param param the request object
     */
    public deleteCollectionDeviceClass(param: ResourceV1beta1ApiDeleteCollectionDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionDeviceClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta1ApiDeleteCollectionNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceClaimWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaim(param: ResourceV1beta1ApiDeleteCollectionNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceClaim(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaimTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta1ApiDeleteCollectionNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaimTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimTemplate(param: ResourceV1beta1ApiDeleteCollectionNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceClaimTemplate(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceSlice
     * @param param the request object
     */
    public deleteCollectionResourceSliceWithHttpInfo(param: ResourceV1beta1ApiDeleteCollectionResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionResourceSliceWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceSlice
     * @param param the request object
     */
    public deleteCollectionResourceSlice(param: ResourceV1beta1ApiDeleteCollectionResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionResourceSlice(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceClass
     * @param param the request object
     */
    public deleteDeviceClassWithHttpInfo(param: ResourceV1beta1ApiDeleteDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1DeviceClass>> {
        return this.api.deleteDeviceClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceClass
     * @param param the request object
     */
    public deleteDeviceClass(param: ResourceV1beta1ApiDeleteDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta1DeviceClass> {
        return this.api.deleteDeviceClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaim
     * @param param the request object
     */
    public deleteNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta1ApiDeleteNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.deleteNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaim
     * @param param the request object
     */
    public deleteNamespacedResourceClaim(param: ResourceV1beta1ApiDeleteNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.deleteNamespacedResourceClaim(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaimTemplate
     * @param param the request object
     */
    public deleteNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta1ApiDeleteNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimTemplate>> {
        return this.api.deleteNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaimTemplate
     * @param param the request object
     */
    public deleteNamespacedResourceClaimTemplate(param: ResourceV1beta1ApiDeleteNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimTemplate> {
        return this.api.deleteNamespacedResourceClaimTemplate(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceSlice
     * @param param the request object
     */
    public deleteResourceSliceWithHttpInfo(param: ResourceV1beta1ApiDeleteResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceSlice>> {
        return this.api.deleteResourceSliceWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceSlice
     * @param param the request object
     */
    public deleteResourceSlice(param: ResourceV1beta1ApiDeleteResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceSlice> {
        return this.api.deleteResourceSlice(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: ResourceV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: ResourceV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceClass
     * @param param the request object
     */
    public listDeviceClassWithHttpInfo(param: ResourceV1beta1ApiListDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1DeviceClassList>> {
        return this.api.listDeviceClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceClass
     * @param param the request object
     */
    public listDeviceClass(param: ResourceV1beta1ApiListDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<V1beta1DeviceClassList> {
        return this.api.listDeviceClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta1ApiListNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimList>> {
        return this.api.listNamespacedResourceClaimWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listNamespacedResourceClaim(param: ResourceV1beta1ApiListNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimList> {
        return this.api.listNamespacedResourceClaim(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta1ApiListNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimTemplateList>> {
        return this.api.listNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listNamespacedResourceClaimTemplate(param: ResourceV1beta1ApiListNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimTemplateList> {
        return this.api.listNamespacedResourceClaimTemplate(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listResourceClaimForAllNamespacesWithHttpInfo(param: ResourceV1beta1ApiListResourceClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimList>> {
        return this.api.listResourceClaimForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listResourceClaimForAllNamespaces(param: ResourceV1beta1ApiListResourceClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimList> {
        return this.api.listResourceClaimForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listResourceClaimTemplateForAllNamespacesWithHttpInfo(param: ResourceV1beta1ApiListResourceClaimTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimTemplateList>> {
        return this.api.listResourceClaimTemplateForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listResourceClaimTemplateForAllNamespaces(param: ResourceV1beta1ApiListResourceClaimTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimTemplateList> {
        return this.api.listResourceClaimTemplateForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceSlice
     * @param param the request object
     */
    public listResourceSliceWithHttpInfo(param: ResourceV1beta1ApiListResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceSliceList>> {
        return this.api.listResourceSliceWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceSlice
     * @param param the request object
     */
    public listResourceSlice(param: ResourceV1beta1ApiListResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<V1beta1ResourceSliceList> {
        return this.api.listResourceSlice(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified DeviceClass
     * @param param the request object
     */
    public patchDeviceClassWithHttpInfo(param: ResourceV1beta1ApiPatchDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1DeviceClass>> {
        return this.api.patchDeviceClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DeviceClass
     * @param param the request object
     */
    public patchDeviceClass(param: ResourceV1beta1ApiPatchDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta1DeviceClass> {
        return this.api.patchDeviceClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta1ApiPatchNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.patchNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaim(param: ResourceV1beta1ApiPatchNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.patchNamespacedResourceClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1beta1ApiPatchNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.patchNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimStatus(param: ResourceV1beta1ApiPatchNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.patchNamespacedResourceClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaimTemplate
     * @param param the request object
     */
    public patchNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta1ApiPatchNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimTemplate>> {
        return this.api.patchNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaimTemplate
     * @param param the request object
     */
    public patchNamespacedResourceClaimTemplate(param: ResourceV1beta1ApiPatchNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimTemplate> {
        return this.api.patchNamespacedResourceClaimTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceSlice
     * @param param the request object
     */
    public patchResourceSliceWithHttpInfo(param: ResourceV1beta1ApiPatchResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceSlice>> {
        return this.api.patchResourceSliceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceSlice
     * @param param the request object
     */
    public patchResourceSlice(param: ResourceV1beta1ApiPatchResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceSlice> {
        return this.api.patchResourceSlice(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified DeviceClass
     * @param param the request object
     */
    public readDeviceClassWithHttpInfo(param: ResourceV1beta1ApiReadDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1DeviceClass>> {
        return this.api.readDeviceClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DeviceClass
     * @param param the request object
     */
    public readDeviceClass(param: ResourceV1beta1ApiReadDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta1DeviceClass> {
        return this.api.readDeviceClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta1ApiReadNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.readNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaim(param: ResourceV1beta1ApiReadNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.readNamespacedResourceClaim(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1beta1ApiReadNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.readNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimStatus(param: ResourceV1beta1ApiReadNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.readNamespacedResourceClaimStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaimTemplate
     * @param param the request object
     */
    public readNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta1ApiReadNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimTemplate>> {
        return this.api.readNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaimTemplate
     * @param param the request object
     */
    public readNamespacedResourceClaimTemplate(param: ResourceV1beta1ApiReadNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimTemplate> {
        return this.api.readNamespacedResourceClaimTemplate(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceSlice
     * @param param the request object
     */
    public readResourceSliceWithHttpInfo(param: ResourceV1beta1ApiReadResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceSlice>> {
        return this.api.readResourceSliceWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceSlice
     * @param param the request object
     */
    public readResourceSlice(param: ResourceV1beta1ApiReadResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceSlice> {
        return this.api.readResourceSlice(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified DeviceClass
     * @param param the request object
     */
    public replaceDeviceClassWithHttpInfo(param: ResourceV1beta1ApiReplaceDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1DeviceClass>> {
        return this.api.replaceDeviceClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified DeviceClass
     * @param param the request object
     */
    public replaceDeviceClass(param: ResourceV1beta1ApiReplaceDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta1DeviceClass> {
        return this.api.replaceDeviceClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta1ApiReplaceNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.replaceNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaim(param: ResourceV1beta1ApiReplaceNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.replaceNamespacedResourceClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1beta1ApiReplaceNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaim>> {
        return this.api.replaceNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimStatus(param: ResourceV1beta1ApiReplaceNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaim> {
        return this.api.replaceNamespacedResourceClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaimTemplate
     * @param param the request object
     */
    public replaceNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta1ApiReplaceNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceClaimTemplate>> {
        return this.api.replaceNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaimTemplate
     * @param param the request object
     */
    public replaceNamespacedResourceClaimTemplate(param: ResourceV1beta1ApiReplaceNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceClaimTemplate> {
        return this.api.replaceNamespacedResourceClaimTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceSlice
     * @param param the request object
     */
    public replaceResourceSliceWithHttpInfo(param: ResourceV1beta1ApiReplaceResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1ResourceSlice>> {
        return this.api.replaceResourceSliceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceSlice
     * @param param the request object
     */
    public replaceResourceSlice(param: ResourceV1beta1ApiReplaceResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta1ResourceSlice> {
        return this.api.replaceResourceSlice(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableResourceV1beta2Api } from "./ObservableAPI.js";
import { ResourceV1beta2ApiRequestFactory, ResourceV1beta2ApiResponseProcessor} from "../apis/ResourceV1beta2Api.js";

export interface ResourceV1beta2ApiCreateDeviceClassRequest {
    /**
     * 
     * @type V1beta2DeviceClass
     * @memberof ResourceV1beta2ApicreateDeviceClass
     */
    body: V1beta2DeviceClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateDeviceClass
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiCreateNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type V1beta2ResourceClaim
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaim
     */
    body: V1beta2ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaim
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiCreateNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type V1beta2ResourceClaimTemplate
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaimTemplate
     */
    body: V1beta2ResourceClaimTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiCreateResourceSliceRequest {
    /**
     * 
     * @type V1beta2ResourceSlice
     * @memberof ResourceV1beta2ApicreateResourceSlice
     */
    body: V1beta2ResourceSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApicreateResourceSlice
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiDeleteCollectionDeviceClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteCollectionDeviceClass
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiDeleteCollectionNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaim
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiDeleteCollectionNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteCollectionNamespacedResourceClaimTemplate
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiDeleteCollectionResourceSliceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteCollectionResourceSlice
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiDeleteDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteDeviceClass
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiDeleteNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaim
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiDeleteNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteNamespacedResourceClaimTemplate
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiDeleteResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof ResourceV1beta2ApideleteResourceSlice
     */
    body?: V1DeleteOptions
}

export interface ResourceV1beta2ApiGetAPIResourcesRequest {
}

export interface ResourceV1beta2ApiListDeviceClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistDeviceClass
     */
    watch?: boolean
}

export interface ResourceV1beta2ApiListNamespacedResourceClaimRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaim
     */
    watch?: boolean
}

export interface ResourceV1beta2ApiListNamespacedResourceClaimTemplateRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistNamespacedResourceClaimTemplate
     */
    watch?: boolean
}

export interface ResourceV1beta2ApiListResourceClaimForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceClaimForAllNamespaces
     */
    watch?: boolean
}

export interface ResourceV1beta2ApiListResourceClaimTemplateForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceClaimTemplateForAllNamespaces
     */
    watch?: boolean
}

export interface ResourceV1beta2ApiListResourceSliceRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApilistResourceSlice
     */
    watch?: boolean
}

export interface ResourceV1beta2ApiPatchDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchDeviceClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta2ApipatchDeviceClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchDeviceClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApipatchDeviceClass
     */
    force?: boolean
}

export interface ResourceV1beta2ApiPatchNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaim
     */
    force?: boolean
}

export interface ResourceV1beta2ApiPatchNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimStatus
     */
    force?: boolean
}

export interface ResourceV1beta2ApiPatchNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApipatchNamespacedResourceClaimTemplate
     */
    force?: boolean
}

export interface ResourceV1beta2ApiPatchResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchResourceSlice
     */
    name: string
    /**
     * 
     * @type any
     * @memberof ResourceV1beta2ApipatchResourceSlice
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApipatchResourceSlice
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof ResourceV1beta2ApipatchResourceSlice
     */
    force?: boolean
}

export interface ResourceV1beta2ApiReadDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadDeviceClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadDeviceClass
     */
    pretty?: string
}

export interface ResourceV1beta2ApiReadNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaim
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaim
     */
    pretty?: string
}

export interface ResourceV1beta2ApiReadNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaimStatus
     */
    pretty?: string
}

export interface ResourceV1beta2ApiReadNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadNamespacedResourceClaimTemplate
     */
    pretty?: string
}

export interface ResourceV1beta2ApiReadResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadResourceSlice
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireadResourceSlice
     */
    pretty?: string
}

export interface ResourceV1beta2ApiReplaceDeviceClassRequest {
    /**
     * name of the DeviceClass
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceDeviceClass
     */
    name: string
    /**
     * 
     * @type V1beta2DeviceClass
     * @memberof ResourceV1beta2ApireplaceDeviceClass
     */
    body: V1beta2DeviceClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceDeviceClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceDeviceClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceDeviceClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceDeviceClass
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiReplaceNamespacedResourceClaimRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaim
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaim
     */
    namespace: string
    /**
     * 
     * @type V1beta2ResourceClaim
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaim
     */
    body: V1beta2ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaim
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaim
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaim
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaim
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiReplaceNamespacedResourceClaimStatusRequest {
    /**
     * name of the ResourceClaim
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimStatus
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimStatus
     */
    namespace: string
    /**
     * 
     * @type V1beta2ResourceClaim
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimStatus
     */
    body: V1beta2ResourceClaim
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimStatus
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiReplaceNamespacedResourceClaimTemplateRequest {
    /**
     * name of the ResourceClaimTemplate
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimTemplate
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimTemplate
     */
    namespace: string
    /**
     * 
     * @type V1beta2ResourceClaimTemplate
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimTemplate
     */
    body: V1beta2ResourceClaimTemplate
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimTemplate
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimTemplate
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimTemplate
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceNamespacedResourceClaimTemplate
     */
    fieldValidation?: string
}

export interface ResourceV1beta2ApiReplaceResourceSliceRequest {
    /**
     * name of the ResourceSlice
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceResourceSlice
     */
    name: string
    /**
     * 
     * @type V1beta2ResourceSlice
     * @memberof ResourceV1beta2ApireplaceResourceSlice
     */
    body: V1beta2ResourceSlice
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceResourceSlice
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceResourceSlice
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceResourceSlice
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof ResourceV1beta2ApireplaceResourceSlice
     */
    fieldValidation?: string
}

export class ObjectResourceV1beta2Api {
    private api: ObservableResourceV1beta2Api

    public constructor(configuration: Configuration, requestFactory?: ResourceV1beta2ApiRequestFactory, responseProcessor?: ResourceV1beta2ApiResponseProcessor) {
        this.api = new ObservableResourceV1beta2Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a DeviceClass
     * @param param the request object
     */
    public createDeviceClassWithHttpInfo(param: ResourceV1beta2ApiCreateDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2DeviceClass>> {
        return this.api.createDeviceClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a DeviceClass
     * @param param the request object
     */
    public createDeviceClass(param: ResourceV1beta2ApiCreateDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta2DeviceClass> {
        return this.api.createDeviceClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaim
     * @param param the request object
     */
    public createNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta2ApiCreateNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.createNamespacedResourceClaimWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaim
     * @param param the request object
     */
    public createNamespacedResourceClaim(param: ResourceV1beta2ApiCreateNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.createNamespacedResourceClaim(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaimTemplate
     * @param param the request object
     */
    public createNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta2ApiCreateNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimTemplate>> {
        return this.api.createNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceClaimTemplate
     * @param param the request object
     */
    public createNamespacedResourceClaimTemplate(param: ResourceV1beta2ApiCreateNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimTemplate> {
        return this.api.createNamespacedResourceClaimTemplate(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceSlice
     * @param param the request object
     */
    public createResourceSliceWithHttpInfo(param: ResourceV1beta2ApiCreateResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceSlice>> {
        return this.api.createResourceSliceWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a ResourceSlice
     * @param param the request object
     */
    public createResourceSlice(param: ResourceV1beta2ApiCreateResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceSlice> {
        return this.api.createResourceSlice(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of DeviceClass
     * @param param the request object
     */
    public deleteCollectionDeviceClassWithHttpInfo(param: ResourceV1beta2ApiDeleteCollectionDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionDeviceClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of DeviceClass
     * @param param the request object
     */
    public deleteCollectionDeviceClass(param: ResourceV1beta2ApiDeleteCollectionDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionDeviceClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta2ApiDeleteCollectionNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceClaimWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaim
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaim(param: ResourceV1beta2ApiDeleteCollectionNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceClaim(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaimTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta2ApiDeleteCollectionNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceClaimTemplate
     * @param param the request object
     */
    public deleteCollectionNamespacedResourceClaimTemplate(param: ResourceV1beta2ApiDeleteCollectionNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedResourceClaimTemplate(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceSlice
     * @param param the request object
     */
    public deleteCollectionResourceSliceWithHttpInfo(param: ResourceV1beta2ApiDeleteCollectionResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionResourceSliceWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of ResourceSlice
     * @param param the request object
     */
    public deleteCollectionResourceSlice(param: ResourceV1beta2ApiDeleteCollectionResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionResourceSlice(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceClass
     * @param param the request object
     */
    public deleteDeviceClassWithHttpInfo(param: ResourceV1beta2ApiDeleteDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2DeviceClass>> {
        return this.api.deleteDeviceClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a DeviceClass
     * @param param the request object
     */
    public deleteDeviceClass(param: ResourceV1beta2ApiDeleteDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta2DeviceClass> {
        return this.api.deleteDeviceClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaim
     * @param param the request object
     */
    public deleteNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta2ApiDeleteNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.deleteNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaim
     * @param param the request object
     */
    public deleteNamespacedResourceClaim(param: ResourceV1beta2ApiDeleteNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.deleteNamespacedResourceClaim(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaimTemplate
     * @param param the request object
     */
    public deleteNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta2ApiDeleteNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimTemplate>> {
        return this.api.deleteNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceClaimTemplate
     * @param param the request object
     */
    public deleteNamespacedResourceClaimTemplate(param: ResourceV1beta2ApiDeleteNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimTemplate> {
        return this.api.deleteNamespacedResourceClaimTemplate(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceSlice
     * @param param the request object
     */
    public deleteResourceSliceWithHttpInfo(param: ResourceV1beta2ApiDeleteResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceSlice>> {
        return this.api.deleteResourceSliceWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a ResourceSlice
     * @param param the request object
     */
    public deleteResourceSlice(param: ResourceV1beta2ApiDeleteResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceSlice> {
        return this.api.deleteResourceSlice(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: ResourceV1beta2ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: ResourceV1beta2ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceClass
     * @param param the request object
     */
    public listDeviceClassWithHttpInfo(param: ResourceV1beta2ApiListDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2DeviceClassList>> {
        return this.api.listDeviceClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind DeviceClass
     * @param param the request object
     */
    public listDeviceClass(param: ResourceV1beta2ApiListDeviceClassRequest = {}, options?: ConfigurationOptions): Promise<V1beta2DeviceClassList> {
        return this.api.listDeviceClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta2ApiListNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimList>> {
        return this.api.listNamespacedResourceClaimWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listNamespacedResourceClaim(param: ResourceV1beta2ApiListNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimList> {
        return this.api.listNamespacedResourceClaim(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta2ApiListNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimTemplateList>> {
        return this.api.listNamespacedResourceClaimTemplateWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listNamespacedResourceClaimTemplate(param: ResourceV1beta2ApiListNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimTemplateList> {
        return this.api.listNamespacedResourceClaimTemplate(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listResourceClaimForAllNamespacesWithHttpInfo(param: ResourceV1beta2ApiListResourceClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimList>> {
        return this.api.listResourceClaimForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaim
     * @param param the request object
     */
    public listResourceClaimForAllNamespaces(param: ResourceV1beta2ApiListResourceClaimForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimList> {
        return this.api.listResourceClaimForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listResourceClaimTemplateForAllNamespacesWithHttpInfo(param: ResourceV1beta2ApiListResourceClaimTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimTemplateList>> {
        return this.api.listResourceClaimTemplateForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceClaimTemplate
     * @param param the request object
     */
    public listResourceClaimTemplateForAllNamespaces(param: ResourceV1beta2ApiListResourceClaimTemplateForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimTemplateList> {
        return this.api.listResourceClaimTemplateForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceSlice
     * @param param the request object
     */
    public listResourceSliceWithHttpInfo(param: ResourceV1beta2ApiListResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceSliceList>> {
        return this.api.listResourceSliceWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind ResourceSlice
     * @param param the request object
     */
    public listResourceSlice(param: ResourceV1beta2ApiListResourceSliceRequest = {}, options?: ConfigurationOptions): Promise<V1beta2ResourceSliceList> {
        return this.api.listResourceSlice(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified DeviceClass
     * @param param the request object
     */
    public patchDeviceClassWithHttpInfo(param: ResourceV1beta2ApiPatchDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2DeviceClass>> {
        return this.api.patchDeviceClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified DeviceClass
     * @param param the request object
     */
    public patchDeviceClass(param: ResourceV1beta2ApiPatchDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta2DeviceClass> {
        return this.api.patchDeviceClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta2ApiPatchNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.patchNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaim(param: ResourceV1beta2ApiPatchNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.patchNamespacedResourceClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1beta2ApiPatchNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.patchNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified ResourceClaim
     * @param param the request object
     */
    public patchNamespacedResourceClaimStatus(param: ResourceV1beta2ApiPatchNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.patchNamespacedResourceClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaimTemplate
     * @param param the request object
     */
    public patchNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta2ApiPatchNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimTemplate>> {
        return this.api.patchNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceClaimTemplate
     * @param param the request object
     */
    public patchNamespacedResourceClaimTemplate(param: ResourceV1beta2ApiPatchNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimTemplate> {
        return this.api.patchNamespacedResourceClaimTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceSlice
     * @param param the request object
     */
    public patchResourceSliceWithHttpInfo(param: ResourceV1beta2ApiPatchResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceSlice>> {
        return this.api.patchResourceSliceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified ResourceSlice
     * @param param the request object
     */
    public patchResourceSlice(param: ResourceV1beta2ApiPatchResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceSlice> {
        return this.api.patchResourceSlice(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified DeviceClass
     * @param param the request object
     */
    public readDeviceClassWithHttpInfo(param: ResourceV1beta2ApiReadDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2DeviceClass>> {
        return this.api.readDeviceClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified DeviceClass
     * @param param the request object
     */
    public readDeviceClass(param: ResourceV1beta2ApiReadDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta2DeviceClass> {
        return this.api.readDeviceClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta2ApiReadNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.readNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaim(param: ResourceV1beta2ApiReadNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.readNamespacedResourceClaim(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1beta2ApiReadNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.readNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified ResourceClaim
     * @param param the request object
     */
    public readNamespacedResourceClaimStatus(param: ResourceV1beta2ApiReadNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.readNamespacedResourceClaimStatus(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaimTemplate
     * @param param the request object
     */
    public readNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta2ApiReadNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimTemplate>> {
        return this.api.readNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceClaimTemplate
     * @param param the request object
     */
    public readNamespacedResourceClaimTemplate(param: ResourceV1beta2ApiReadNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimTemplate> {
        return this.api.readNamespacedResourceClaimTemplate(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceSlice
     * @param param the request object
     */
    public readResourceSliceWithHttpInfo(param: ResourceV1beta2ApiReadResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceSlice>> {
        return this.api.readResourceSliceWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified ResourceSlice
     * @param param the request object
     */
    public readResourceSlice(param: ResourceV1beta2ApiReadResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceSlice> {
        return this.api.readResourceSlice(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified DeviceClass
     * @param param the request object
     */
    public replaceDeviceClassWithHttpInfo(param: ResourceV1beta2ApiReplaceDeviceClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2DeviceClass>> {
        return this.api.replaceDeviceClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified DeviceClass
     * @param param the request object
     */
    public replaceDeviceClass(param: ResourceV1beta2ApiReplaceDeviceClassRequest, options?: ConfigurationOptions): Promise<V1beta2DeviceClass> {
        return this.api.replaceDeviceClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimWithHttpInfo(param: ResourceV1beta2ApiReplaceNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.replaceNamespacedResourceClaimWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaim(param: ResourceV1beta2ApiReplaceNamespacedResourceClaimRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.replaceNamespacedResourceClaim(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimStatusWithHttpInfo(param: ResourceV1beta2ApiReplaceNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaim>> {
        return this.api.replaceNamespacedResourceClaimStatusWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified ResourceClaim
     * @param param the request object
     */
    public replaceNamespacedResourceClaimStatus(param: ResourceV1beta2ApiReplaceNamespacedResourceClaimStatusRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaim> {
        return this.api.replaceNamespacedResourceClaimStatus(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaimTemplate
     * @param param the request object
     */
    public replaceNamespacedResourceClaimTemplateWithHttpInfo(param: ResourceV1beta2ApiReplaceNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceClaimTemplate>> {
        return this.api.replaceNamespacedResourceClaimTemplateWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceClaimTemplate
     * @param param the request object
     */
    public replaceNamespacedResourceClaimTemplate(param: ResourceV1beta2ApiReplaceNamespacedResourceClaimTemplateRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceClaimTemplate> {
        return this.api.replaceNamespacedResourceClaimTemplate(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceSlice
     * @param param the request object
     */
    public replaceResourceSliceWithHttpInfo(param: ResourceV1beta2ApiReplaceResourceSliceRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta2ResourceSlice>> {
        return this.api.replaceResourceSliceWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified ResourceSlice
     * @param param the request object
     */
    public replaceResourceSlice(param: ResourceV1beta2ApiReplaceResourceSliceRequest, options?: ConfigurationOptions): Promise<V1beta2ResourceSlice> {
        return this.api.replaceResourceSlice(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableSchedulingApi } from "./ObservableAPI.js";
import { SchedulingApiRequestFactory, SchedulingApiResponseProcessor} from "../apis/SchedulingApi.js";

export interface SchedulingApiGetAPIGroupRequest {
}

export class ObjectSchedulingApi {
    private api: ObservableSchedulingApi

    public constructor(configuration: Configuration, requestFactory?: SchedulingApiRequestFactory, responseProcessor?: SchedulingApiResponseProcessor) {
        this.api = new ObservableSchedulingApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: SchedulingApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: SchedulingApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableSchedulingV1Api } from "./ObservableAPI.js";
import { SchedulingV1ApiRequestFactory, SchedulingV1ApiResponseProcessor} from "../apis/SchedulingV1Api.js";

export interface SchedulingV1ApiCreatePriorityClassRequest {
    /**
     * 
     * @type V1PriorityClass
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    body: V1PriorityClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApicreatePriorityClass
     */
    fieldValidation?: string
}

export interface SchedulingV1ApiDeleteCollectionPriorityClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof SchedulingV1ApideleteCollectionPriorityClass
     */
    body?: V1DeleteOptions
}

export interface SchedulingV1ApiDeletePriorityClassRequest {
    /**
     * name of the PriorityClass
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof SchedulingV1ApideletePriorityClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApideletePriorityClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApideletePriorityClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApideletePriorityClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof SchedulingV1ApideletePriorityClass
     */
    body?: V1DeleteOptions
}

export interface SchedulingV1ApiGetAPIResourcesRequest {
}

export interface SchedulingV1ApiListPriorityClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApilistPriorityClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof SchedulingV1ApilistPriorityClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApilistPriorityClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApilistPriorityClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof SchedulingV1ApilistPriorityClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApilistPriorityClass
     */
    watch?: boolean
}

export interface SchedulingV1ApiPatchPriorityClassRequest {
    /**
     * name of the PriorityClass
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof SchedulingV1ApipatchPriorityClass
     */
    force?: boolean
}

export interface SchedulingV1ApiReadPriorityClassRequest {
    /**
     * name of the PriorityClass
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApireadPriorityClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApireadPriorityClass
     */
    pretty?: string
}

export interface SchedulingV1ApiReplacePriorityClassRequest {
    /**
     * name of the PriorityClass
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    name: string
    /**
     * 
     * @type V1PriorityClass
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    body: V1PriorityClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof SchedulingV1ApireplacePriorityClass
     */
    fieldValidation?: string
}

export class ObjectSchedulingV1Api {
    private api: ObservableSchedulingV1Api

    public constructor(configuration: Configuration, requestFactory?: SchedulingV1ApiRequestFactory, responseProcessor?: SchedulingV1ApiResponseProcessor) {
        this.api = new ObservableSchedulingV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a PriorityClass
     * @param param the request object
     */
    public createPriorityClassWithHttpInfo(param: SchedulingV1ApiCreatePriorityClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.createPriorityClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a PriorityClass
     * @param param the request object
     */
    public createPriorityClass(param: SchedulingV1ApiCreatePriorityClassRequest, options?: ConfigurationOptions): Promise<V1PriorityClass> {
        return this.api.createPriorityClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of PriorityClass
     * @param param the request object
     */
    public deleteCollectionPriorityClassWithHttpInfo(param: SchedulingV1ApiDeleteCollectionPriorityClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionPriorityClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of PriorityClass
     * @param param the request object
     */
    public deleteCollectionPriorityClass(param: SchedulingV1ApiDeleteCollectionPriorityClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionPriorityClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityClass
     * @param param the request object
     */
    public deletePriorityClassWithHttpInfo(param: SchedulingV1ApiDeletePriorityClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deletePriorityClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a PriorityClass
     * @param param the request object
     */
    public deletePriorityClass(param: SchedulingV1ApiDeletePriorityClassRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deletePriorityClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: SchedulingV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: SchedulingV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
    public listPriorityClassWithHttpInfo(param: SchedulingV1ApiListPriorityClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityClassList>> {
        return this.api.listPriorityClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind PriorityClass
     * @param param the request object
     */
    public listPriorityClass(param: SchedulingV1ApiListPriorityClassRequest = {}, options?: ConfigurationOptions): Promise<V1PriorityClassList> {
        return this.api.listPriorityClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
    public patchPriorityClassWithHttpInfo(param: SchedulingV1ApiPatchPriorityClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.patchPriorityClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified PriorityClass
     * @param param the request object
     */
    public patchPriorityClass(param: SchedulingV1ApiPatchPriorityClassRequest, options?: ConfigurationOptions): Promise<V1PriorityClass> {
        return this.api.patchPriorityClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified PriorityClass
     * @param param the request object
     */
    public readPriorityClassWithHttpInfo(param: SchedulingV1ApiReadPriorityClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.readPriorityClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified PriorityClass
     * @param param the request object
     */
    public readPriorityClass(param: SchedulingV1ApiReadPriorityClassRequest, options?: ConfigurationOptions): Promise<V1PriorityClass> {
        return this.api.readPriorityClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified PriorityClass
     * @param param the request object
     */
    public replacePriorityClassWithHttpInfo(param: SchedulingV1ApiReplacePriorityClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1PriorityClass>> {
        return this.api.replacePriorityClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified PriorityClass
     * @param param the request object
     */
    public replacePriorityClass(param: SchedulingV1ApiReplacePriorityClassRequest, options?: ConfigurationOptions): Promise<V1PriorityClass> {
        return this.api.replacePriorityClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableStorageApi } from "./ObservableAPI.js";
import { StorageApiRequestFactory, StorageApiResponseProcessor} from "../apis/StorageApi.js";

export interface StorageApiGetAPIGroupRequest {
}

export class ObjectStorageApi {
    private api: ObservableStorageApi

    public constructor(configuration: Configuration, requestFactory?: StorageApiRequestFactory, responseProcessor?: StorageApiResponseProcessor) {
        this.api = new ObservableStorageApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: StorageApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: StorageApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableStorageV1Api } from "./ObservableAPI.js";
import { StorageV1ApiRequestFactory, StorageV1ApiResponseProcessor} from "../apis/StorageV1Api.js";

export interface StorageV1ApiCreateCSIDriverRequest {
    /**
     * 
     * @type V1CSIDriver
     * @memberof StorageV1ApicreateCSIDriver
     */
    body: V1CSIDriver
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSIDriver
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSIDriver
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSIDriver
     */
    fieldValidation?: string
}

export interface StorageV1ApiCreateCSINodeRequest {
    /**
     * 
     * @type V1CSINode
     * @memberof StorageV1ApicreateCSINode
     */
    body: V1CSINode
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSINode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSINode
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateCSINode
     */
    fieldValidation?: string
}

export interface StorageV1ApiCreateNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type V1CSIStorageCapacity
     * @memberof StorageV1ApicreateNamespacedCSIStorageCapacity
     */
    body: V1CSIStorageCapacity
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateNamespacedCSIStorageCapacity
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateNamespacedCSIStorageCapacity
     */
    fieldValidation?: string
}

export interface StorageV1ApiCreateStorageClassRequest {
    /**
     * 
     * @type V1StorageClass
     * @memberof StorageV1ApicreateStorageClass
     */
    body: V1StorageClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateStorageClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateStorageClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateStorageClass
     */
    fieldValidation?: string
}

export interface StorageV1ApiCreateVolumeAttachmentRequest {
    /**
     * 
     * @type V1VolumeAttachment
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    body: V1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApicreateVolumeAttachment
     */
    fieldValidation?: string
}

export interface StorageV1ApiDeleteCSIDriverRequest {
    /**
     * name of the CSIDriver
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCSIDriver
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCSIDriver
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCSIDriver
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSIDriver
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCSIDriver
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCSINodeRequest {
    /**
     * name of the CSINode
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCSINode
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCSINode
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCSINode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCSINode
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCSINode
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionCSIDriverRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionCSIDriver
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionCSINodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionCSINode
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionNamespacedCSIStorageCapacity
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionStorageClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionStorageClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteCollectionVolumeAttachmentRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteCollectionVolumeAttachment
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteNamespacedCSIStorageCapacity
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteStorageClassRequest {
    /**
     * name of the StorageClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteStorageClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteStorageClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteStorageClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteStorageClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteStorageClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiDeleteVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1ApideleteVolumeAttachment
     */
    body?: V1DeleteOptions
}

export interface StorageV1ApiGetAPIResourcesRequest {
}

export interface StorageV1ApiListCSIDriverRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSIDriver
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistCSIDriver
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIDriver
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSIDriver
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistCSIDriver
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSIDriver
     */
    watch?: boolean
}

export interface StorageV1ApiListCSINodeRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSINode
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistCSINode
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSINode
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSINode
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistCSINode
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSINode
     */
    watch?: boolean
}

export interface StorageV1ApiListCSIStorageCapacityForAllNamespacesRequest {
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    limit?: number
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    pretty?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistCSIStorageCapacityForAllNamespaces
     */
    watch?: boolean
}

export interface StorageV1ApiListNamespacedCSIStorageCapacityRequest {
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistNamespacedCSIStorageCapacity
     */
    watch?: boolean
}

export interface StorageV1ApiListStorageClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistStorageClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistStorageClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistStorageClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistStorageClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistStorageClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistStorageClass
     */
    watch?: boolean
}

export interface StorageV1ApiListVolumeAttachmentRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistVolumeAttachment
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistVolumeAttachment
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApilistVolumeAttachment
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistVolumeAttachment
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1ApilistVolumeAttachment
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApilistVolumeAttachment
     */
    watch?: boolean
}

export interface StorageV1ApiPatchCSIDriverRequest {
    /**
     * name of the CSIDriver
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchCSIDriver
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSIDriver
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApipatchCSIDriver
     */
    force?: boolean
}

export interface StorageV1ApiPatchCSINodeRequest {
    /**
     * name of the CSINode
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchCSINode
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchCSINode
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApipatchCSINode
     */
    force?: boolean
}

export interface StorageV1ApiPatchNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApipatchNamespacedCSIStorageCapacity
     */
    force?: boolean
}

export interface StorageV1ApiPatchStorageClassRequest {
    /**
     * name of the StorageClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchStorageClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchStorageClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApipatchStorageClass
     */
    force?: boolean
}

export interface StorageV1ApiPatchVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApipatchVolumeAttachment
     */
    force?: boolean
}

export interface StorageV1ApiPatchVolumeAttachmentStatusRequest {
    /**
     * name of the VolumeAttachment
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1ApipatchVolumeAttachmentStatus
     */
    force?: boolean
}

export interface StorageV1ApiReadCSIDriverRequest {
    /**
     * name of the CSIDriver
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadCSIDriver
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadCSIDriver
     */
    pretty?: string
}

export interface StorageV1ApiReadCSINodeRequest {
    /**
     * name of the CSINode
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadCSINode
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadCSINode
     */
    pretty?: string
}

export interface StorageV1ApiReadNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadNamespacedCSIStorageCapacity
     */
    pretty?: string
}

export interface StorageV1ApiReadStorageClassRequest {
    /**
     * name of the StorageClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadStorageClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadStorageClass
     */
    pretty?: string
}

export interface StorageV1ApiReadVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadVolumeAttachment
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadVolumeAttachment
     */
    pretty?: string
}

export interface StorageV1ApiReadVolumeAttachmentStatusRequest {
    /**
     * name of the VolumeAttachment
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadVolumeAttachmentStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireadVolumeAttachmentStatus
     */
    pretty?: string
}

export interface StorageV1ApiReplaceCSIDriverRequest {
    /**
     * name of the CSIDriver
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    name: string
    /**
     * 
     * @type V1CSIDriver
     * @memberof StorageV1ApireplaceCSIDriver
     */
    body: V1CSIDriver
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSIDriver
     */
    fieldValidation?: string
}

export interface StorageV1ApiReplaceCSINodeRequest {
    /**
     * name of the CSINode
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    name: string
    /**
     * 
     * @type V1CSINode
     * @memberof StorageV1ApireplaceCSINode
     */
    body: V1CSINode
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceCSINode
     */
    fieldValidation?: string
}

export interface StorageV1ApiReplaceNamespacedCSIStorageCapacityRequest {
    /**
     * name of the CSIStorageCapacity
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceNamespacedCSIStorageCapacity
     */
    name: string
    /**
     * object name and auth scope, such as for teams and projects
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceNamespacedCSIStorageCapacity
     */
    namespace: string
    /**
     * 
     * @type V1CSIStorageCapacity
     * @memberof StorageV1ApireplaceNamespacedCSIStorageCapacity
     */
    body: V1CSIStorageCapacity
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceNamespacedCSIStorageCapacity
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceNamespacedCSIStorageCapacity
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceNamespacedCSIStorageCapacity
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceNamespacedCSIStorageCapacity
     */
    fieldValidation?: string
}

export interface StorageV1ApiReplaceStorageClassRequest {
    /**
     * name of the StorageClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    name: string
    /**
     * 
     * @type V1StorageClass
     * @memberof StorageV1ApireplaceStorageClass
     */
    body: V1StorageClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceStorageClass
     */
    fieldValidation?: string
}

export interface StorageV1ApiReplaceVolumeAttachmentRequest {
    /**
     * name of the VolumeAttachment
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    name: string
    /**
     * 
     * @type V1VolumeAttachment
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    body: V1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachment
     */
    fieldValidation?: string
}

export interface StorageV1ApiReplaceVolumeAttachmentStatusRequest {
    /**
     * name of the VolumeAttachment
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    name: string
    /**
     * 
     * @type V1VolumeAttachment
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    body: V1VolumeAttachment
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1ApireplaceVolumeAttachmentStatus
     */
    fieldValidation?: string
}

export class ObjectStorageV1Api {
    private api: ObservableStorageV1Api

    public constructor(configuration: Configuration, requestFactory?: StorageV1ApiRequestFactory, responseProcessor?: StorageV1ApiResponseProcessor) {
        this.api = new ObservableStorageV1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a CSIDriver
     * @param param the request object
     */
    public createCSIDriverWithHttpInfo(param: StorageV1ApiCreateCSIDriverRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.createCSIDriverWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CSIDriver
     * @param param the request object
     */
    public createCSIDriver(param: StorageV1ApiCreateCSIDriverRequest, options?: ConfigurationOptions): Promise<V1CSIDriver> {
        return this.api.createCSIDriver(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CSINode
     * @param param the request object
     */
    public createCSINodeWithHttpInfo(param: StorageV1ApiCreateCSINodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSINode>> {
        return this.api.createCSINodeWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CSINode
     * @param param the request object
     */
    public createCSINode(param: StorageV1ApiCreateCSINodeRequest, options?: ConfigurationOptions): Promise<V1CSINode> {
        return this.api.createCSINode(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CSIStorageCapacity
     * @param param the request object
     */
    public createNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1ApiCreateNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIStorageCapacity>> {
        return this.api.createNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a CSIStorageCapacity
     * @param param the request object
     */
    public createNamespacedCSIStorageCapacity(param: StorageV1ApiCreateNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<V1CSIStorageCapacity> {
        return this.api.createNamespacedCSIStorageCapacity(param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a StorageClass
     * @param param the request object
     */
    public createStorageClassWithHttpInfo(param: StorageV1ApiCreateStorageClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StorageClass>> {
        return this.api.createStorageClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a StorageClass
     * @param param the request object
     */
    public createStorageClass(param: StorageV1ApiCreateStorageClassRequest, options?: ConfigurationOptions): Promise<V1StorageClass> {
        return this.api.createStorageClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a VolumeAttachment
     * @param param the request object
     */
    public createVolumeAttachmentWithHttpInfo(param: StorageV1ApiCreateVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.createVolumeAttachmentWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a VolumeAttachment
     * @param param the request object
     */
    public createVolumeAttachment(param: StorageV1ApiCreateVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.createVolumeAttachment(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete a CSIDriver
     * @param param the request object
     */
    public deleteCSIDriverWithHttpInfo(param: StorageV1ApiDeleteCSIDriverRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.deleteCSIDriverWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSIDriver
     * @param param the request object
     */
    public deleteCSIDriver(param: StorageV1ApiDeleteCSIDriverRequest, options?: ConfigurationOptions): Promise<V1CSIDriver> {
        return this.api.deleteCSIDriver(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSINode
     * @param param the request object
     */
    public deleteCSINodeWithHttpInfo(param: StorageV1ApiDeleteCSINodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSINode>> {
        return this.api.deleteCSINodeWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSINode
     * @param param the request object
     */
    public deleteCSINode(param: StorageV1ApiDeleteCSINodeRequest, options?: ConfigurationOptions): Promise<V1CSINode> {
        return this.api.deleteCSINode(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIDriver
     * @param param the request object
     */
    public deleteCollectionCSIDriverWithHttpInfo(param: StorageV1ApiDeleteCollectionCSIDriverRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCSIDriverWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIDriver
     * @param param the request object
     */
    public deleteCollectionCSIDriver(param: StorageV1ApiDeleteCollectionCSIDriverRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionCSIDriver(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSINode
     * @param param the request object
     */
    public deleteCollectionCSINodeWithHttpInfo(param: StorageV1ApiDeleteCollectionCSINodeRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionCSINodeWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSINode
     * @param param the request object
     */
    public deleteCollectionCSINode(param: StorageV1ApiDeleteCollectionCSINodeRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionCSINode(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIStorageCapacity
     * @param param the request object
     */
    public deleteCollectionNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of CSIStorageCapacity
     * @param param the request object
     */
    public deleteCollectionNamespacedCSIStorageCapacity(param: StorageV1ApiDeleteCollectionNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionNamespacedCSIStorageCapacity(param.namespace, param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StorageClass
     * @param param the request object
     */
    public deleteCollectionStorageClassWithHttpInfo(param: StorageV1ApiDeleteCollectionStorageClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionStorageClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StorageClass
     * @param param the request object
     */
    public deleteCollectionStorageClass(param: StorageV1ApiDeleteCollectionStorageClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionStorageClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
    public deleteCollectionVolumeAttachmentWithHttpInfo(param: StorageV1ApiDeleteCollectionVolumeAttachmentRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionVolumeAttachmentWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttachment
     * @param param the request object
     */
    public deleteCollectionVolumeAttachment(param: StorageV1ApiDeleteCollectionVolumeAttachmentRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionVolumeAttachment(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a CSIStorageCapacity
     * @param param the request object
     */
    public deleteNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1ApiDeleteNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a CSIStorageCapacity
     * @param param the request object
     */
    public deleteNamespacedCSIStorageCapacity(param: StorageV1ApiDeleteNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteNamespacedCSIStorageCapacity(param.name, param.namespace, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StorageClass
     * @param param the request object
     */
    public deleteStorageClassWithHttpInfo(param: StorageV1ApiDeleteStorageClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StorageClass>> {
        return this.api.deleteStorageClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StorageClass
     * @param param the request object
     */
    public deleteStorageClass(param: StorageV1ApiDeleteStorageClassRequest, options?: ConfigurationOptions): Promise<V1StorageClass> {
        return this.api.deleteStorageClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttachment
     * @param param the request object
     */
    public deleteVolumeAttachmentWithHttpInfo(param: StorageV1ApiDeleteVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.deleteVolumeAttachmentWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttachment
     * @param param the request object
     */
    public deleteVolumeAttachment(param: StorageV1ApiDeleteVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.deleteVolumeAttachment(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: StorageV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: StorageV1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind CSIDriver
     * @param param the request object
     */
    public listCSIDriverWithHttpInfo(param: StorageV1ApiListCSIDriverRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIDriverList>> {
        return this.api.listCSIDriverWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIDriver
     * @param param the request object
     */
    public listCSIDriver(param: StorageV1ApiListCSIDriverRequest = {}, options?: ConfigurationOptions): Promise<V1CSIDriverList> {
        return this.api.listCSIDriver(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSINode
     * @param param the request object
     */
    public listCSINodeWithHttpInfo(param: StorageV1ApiListCSINodeRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1CSINodeList>> {
        return this.api.listCSINodeWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSINode
     * @param param the request object
     */
    public listCSINode(param: StorageV1ApiListCSINodeRequest = {}, options?: ConfigurationOptions): Promise<V1CSINodeList> {
        return this.api.listCSINode(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listCSIStorageCapacityForAllNamespacesWithHttpInfo(param: StorageV1ApiListCSIStorageCapacityForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIStorageCapacityList>> {
        return this.api.listCSIStorageCapacityForAllNamespacesWithHttpInfo(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listCSIStorageCapacityForAllNamespaces(param: StorageV1ApiListCSIStorageCapacityForAllNamespacesRequest = {}, options?: ConfigurationOptions): Promise<V1CSIStorageCapacityList> {
        return this.api.listCSIStorageCapacityForAllNamespaces(param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.pretty, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1ApiListNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIStorageCapacityList>> {
        return this.api.listNamespacedCSIStorageCapacityWithHttpInfo(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind CSIStorageCapacity
     * @param param the request object
     */
    public listNamespacedCSIStorageCapacity(param: StorageV1ApiListNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<V1CSIStorageCapacityList> {
        return this.api.listNamespacedCSIStorageCapacity(param.namespace, param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StorageClass
     * @param param the request object
     */
    public listStorageClassWithHttpInfo(param: StorageV1ApiListStorageClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1StorageClassList>> {
        return this.api.listStorageClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StorageClass
     * @param param the request object
     */
    public listStorageClass(param: StorageV1ApiListStorageClassRequest = {}, options?: ConfigurationOptions): Promise<V1StorageClassList> {
        return this.api.listStorageClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
    public listVolumeAttachmentWithHttpInfo(param: StorageV1ApiListVolumeAttachmentRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachmentList>> {
        return this.api.listVolumeAttachmentWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttachment
     * @param param the request object
     */
    public listVolumeAttachment(param: StorageV1ApiListVolumeAttachmentRequest = {}, options?: ConfigurationOptions): Promise<V1VolumeAttachmentList> {
        return this.api.listVolumeAttachment(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified CSIDriver
     * @param param the request object
     */
    public patchCSIDriverWithHttpInfo(param: StorageV1ApiPatchCSIDriverRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.patchCSIDriverWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSIDriver
     * @param param the request object
     */
    public patchCSIDriver(param: StorageV1ApiPatchCSIDriverRequest, options?: ConfigurationOptions): Promise<V1CSIDriver> {
        return this.api.patchCSIDriver(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSINode
     * @param param the request object
     */
    public patchCSINodeWithHttpInfo(param: StorageV1ApiPatchCSINodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSINode>> {
        return this.api.patchCSINodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSINode
     * @param param the request object
     */
    public patchCSINode(param: StorageV1ApiPatchCSINodeRequest, options?: ConfigurationOptions): Promise<V1CSINode> {
        return this.api.patchCSINode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSIStorageCapacity
     * @param param the request object
     */
    public patchNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1ApiPatchNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIStorageCapacity>> {
        return this.api.patchNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified CSIStorageCapacity
     * @param param the request object
     */
    public patchNamespacedCSIStorageCapacity(param: StorageV1ApiPatchNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<V1CSIStorageCapacity> {
        return this.api.patchNamespacedCSIStorageCapacity(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StorageClass
     * @param param the request object
     */
    public patchStorageClassWithHttpInfo(param: StorageV1ApiPatchStorageClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StorageClass>> {
        return this.api.patchStorageClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StorageClass
     * @param param the request object
     */
    public patchStorageClass(param: StorageV1ApiPatchStorageClassRequest, options?: ConfigurationOptions): Promise<V1StorageClass> {
        return this.api.patchStorageClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachmentWithHttpInfo(param: StorageV1ApiPatchVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.patchVolumeAttachmentWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachment(param: StorageV1ApiPatchVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.patchVolumeAttachment(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachmentStatusWithHttpInfo(param: StorageV1ApiPatchVolumeAttachmentStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.patchVolumeAttachmentStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified VolumeAttachment
     * @param param the request object
     */
    public patchVolumeAttachmentStatus(param: StorageV1ApiPatchVolumeAttachmentStatusRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.patchVolumeAttachmentStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified CSIDriver
     * @param param the request object
     */
    public readCSIDriverWithHttpInfo(param: StorageV1ApiReadCSIDriverRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.readCSIDriverWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSIDriver
     * @param param the request object
     */
    public readCSIDriver(param: StorageV1ApiReadCSIDriverRequest, options?: ConfigurationOptions): Promise<V1CSIDriver> {
        return this.api.readCSIDriver(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSINode
     * @param param the request object
     */
    public readCSINodeWithHttpInfo(param: StorageV1ApiReadCSINodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSINode>> {
        return this.api.readCSINodeWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSINode
     * @param param the request object
     */
    public readCSINode(param: StorageV1ApiReadCSINodeRequest, options?: ConfigurationOptions): Promise<V1CSINode> {
        return this.api.readCSINode(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSIStorageCapacity
     * @param param the request object
     */
    public readNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1ApiReadNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIStorageCapacity>> {
        return this.api.readNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified CSIStorageCapacity
     * @param param the request object
     */
    public readNamespacedCSIStorageCapacity(param: StorageV1ApiReadNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<V1CSIStorageCapacity> {
        return this.api.readNamespacedCSIStorageCapacity(param.name, param.namespace, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StorageClass
     * @param param the request object
     */
    public readStorageClassWithHttpInfo(param: StorageV1ApiReadStorageClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StorageClass>> {
        return this.api.readStorageClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StorageClass
     * @param param the request object
     */
    public readStorageClass(param: StorageV1ApiReadStorageClassRequest, options?: ConfigurationOptions): Promise<V1StorageClass> {
        return this.api.readStorageClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachmentWithHttpInfo(param: StorageV1ApiReadVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.readVolumeAttachmentWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachment(param: StorageV1ApiReadVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.readVolumeAttachment(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachmentStatusWithHttpInfo(param: StorageV1ApiReadVolumeAttachmentStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.readVolumeAttachmentStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified VolumeAttachment
     * @param param the request object
     */
    public readVolumeAttachmentStatus(param: StorageV1ApiReadVolumeAttachmentStatusRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.readVolumeAttachmentStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified CSIDriver
     * @param param the request object
     */
    public replaceCSIDriverWithHttpInfo(param: StorageV1ApiReplaceCSIDriverRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIDriver>> {
        return this.api.replaceCSIDriverWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CSIDriver
     * @param param the request object
     */
    public replaceCSIDriver(param: StorageV1ApiReplaceCSIDriverRequest, options?: ConfigurationOptions): Promise<V1CSIDriver> {
        return this.api.replaceCSIDriver(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CSINode
     * @param param the request object
     */
    public replaceCSINodeWithHttpInfo(param: StorageV1ApiReplaceCSINodeRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSINode>> {
        return this.api.replaceCSINodeWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CSINode
     * @param param the request object
     */
    public replaceCSINode(param: StorageV1ApiReplaceCSINodeRequest, options?: ConfigurationOptions): Promise<V1CSINode> {
        return this.api.replaceCSINode(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CSIStorageCapacity
     * @param param the request object
     */
    public replaceNamespacedCSIStorageCapacityWithHttpInfo(param: StorageV1ApiReplaceNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1CSIStorageCapacity>> {
        return this.api.replaceNamespacedCSIStorageCapacityWithHttpInfo(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified CSIStorageCapacity
     * @param param the request object
     */
    public replaceNamespacedCSIStorageCapacity(param: StorageV1ApiReplaceNamespacedCSIStorageCapacityRequest, options?: ConfigurationOptions): Promise<V1CSIStorageCapacity> {
        return this.api.replaceNamespacedCSIStorageCapacity(param.name, param.namespace, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified StorageClass
     * @param param the request object
     */
    public replaceStorageClassWithHttpInfo(param: StorageV1ApiReplaceStorageClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1StorageClass>> {
        return this.api.replaceStorageClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified StorageClass
     * @param param the request object
     */
    public replaceStorageClass(param: StorageV1ApiReplaceStorageClassRequest, options?: ConfigurationOptions): Promise<V1StorageClass> {
        return this.api.replaceStorageClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachmentWithHttpInfo(param: StorageV1ApiReplaceVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.replaceVolumeAttachmentWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachment(param: StorageV1ApiReplaceVolumeAttachmentRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.replaceVolumeAttachment(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachmentStatusWithHttpInfo(param: StorageV1ApiReplaceVolumeAttachmentStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1VolumeAttachment>> {
        return this.api.replaceVolumeAttachmentStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified VolumeAttachment
     * @param param the request object
     */
    public replaceVolumeAttachmentStatus(param: StorageV1ApiReplaceVolumeAttachmentStatusRequest, options?: ConfigurationOptions): Promise<V1VolumeAttachment> {
        return this.api.replaceVolumeAttachmentStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableStorageV1alpha1Api } from "./ObservableAPI.js";
import { StorageV1alpha1ApiRequestFactory, StorageV1alpha1ApiResponseProcessor} from "../apis/StorageV1alpha1Api.js";

export interface StorageV1alpha1ApiCreateVolumeAttributesClassRequest {
    /**
     * 
     * @type V1alpha1VolumeAttributesClass
     * @memberof StorageV1alpha1ApicreateVolumeAttributesClass
     */
    body: V1alpha1VolumeAttributesClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApicreateVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApicreateVolumeAttributesClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApicreateVolumeAttributesClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApicreateVolumeAttributesClass
     */
    fieldValidation?: string
}

export interface StorageV1alpha1ApiDeleteCollectionVolumeAttributesClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1alpha1ApideleteCollectionVolumeAttributesClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1alpha1ApiDeleteVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1alpha1ApideleteVolumeAttributesClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1alpha1ApiGetAPIResourcesRequest {
}

export interface StorageV1alpha1ApiListVolumeAttributesClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApilistVolumeAttributesClass
     */
    watch?: boolean
}

export interface StorageV1alpha1ApiPatchVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttributesClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1alpha1ApipatchVolumeAttributesClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttributesClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttributesClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApipatchVolumeAttributesClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1alpha1ApipatchVolumeAttributesClass
     */
    force?: boolean
}

export interface StorageV1alpha1ApiReadVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApireadVolumeAttributesClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApireadVolumeAttributesClass
     */
    pretty?: string
}

export interface StorageV1alpha1ApiReplaceVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttributesClass
     */
    name: string
    /**
     * 
     * @type V1alpha1VolumeAttributesClass
     * @memberof StorageV1alpha1ApireplaceVolumeAttributesClass
     */
    body: V1alpha1VolumeAttributesClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttributesClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttributesClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1alpha1ApireplaceVolumeAttributesClass
     */
    fieldValidation?: string
}

export class ObjectStorageV1alpha1Api {
    private api: ObservableStorageV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: StorageV1alpha1ApiRequestFactory, responseProcessor?: StorageV1alpha1ApiResponseProcessor) {
        this.api = new ObservableStorageV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a VolumeAttributesClass
     * @param param the request object
     */
    public createVolumeAttributesClassWithHttpInfo(param: StorageV1alpha1ApiCreateVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1VolumeAttributesClass>> {
        return this.api.createVolumeAttributesClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a VolumeAttributesClass
     * @param param the request object
     */
    public createVolumeAttributesClass(param: StorageV1alpha1ApiCreateVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1alpha1VolumeAttributesClass> {
        return this.api.createVolumeAttributesClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttributesClass
     * @param param the request object
     */
    public deleteCollectionVolumeAttributesClassWithHttpInfo(param: StorageV1alpha1ApiDeleteCollectionVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionVolumeAttributesClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttributesClass
     * @param param the request object
     */
    public deleteCollectionVolumeAttributesClass(param: StorageV1alpha1ApiDeleteCollectionVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionVolumeAttributesClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttributesClass
     * @param param the request object
     */
    public deleteVolumeAttributesClassWithHttpInfo(param: StorageV1alpha1ApiDeleteVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1VolumeAttributesClass>> {
        return this.api.deleteVolumeAttributesClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttributesClass
     * @param param the request object
     */
    public deleteVolumeAttributesClass(param: StorageV1alpha1ApiDeleteVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1alpha1VolumeAttributesClass> {
        return this.api.deleteVolumeAttributesClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: StorageV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: StorageV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttributesClass
     * @param param the request object
     */
    public listVolumeAttributesClassWithHttpInfo(param: StorageV1alpha1ApiListVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1VolumeAttributesClassList>> {
        return this.api.listVolumeAttributesClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttributesClass
     * @param param the request object
     */
    public listVolumeAttributesClass(param: StorageV1alpha1ApiListVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<V1alpha1VolumeAttributesClassList> {
        return this.api.listVolumeAttributesClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttributesClass
     * @param param the request object
     */
    public patchVolumeAttributesClassWithHttpInfo(param: StorageV1alpha1ApiPatchVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1VolumeAttributesClass>> {
        return this.api.patchVolumeAttributesClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttributesClass
     * @param param the request object
     */
    public patchVolumeAttributesClass(param: StorageV1alpha1ApiPatchVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1alpha1VolumeAttributesClass> {
        return this.api.patchVolumeAttributesClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified VolumeAttributesClass
     * @param param the request object
     */
    public readVolumeAttributesClassWithHttpInfo(param: StorageV1alpha1ApiReadVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1VolumeAttributesClass>> {
        return this.api.readVolumeAttributesClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttributesClass
     * @param param the request object
     */
    public readVolumeAttributesClass(param: StorageV1alpha1ApiReadVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1alpha1VolumeAttributesClass> {
        return this.api.readVolumeAttributesClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttributesClass
     * @param param the request object
     */
    public replaceVolumeAttributesClassWithHttpInfo(param: StorageV1alpha1ApiReplaceVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1VolumeAttributesClass>> {
        return this.api.replaceVolumeAttributesClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttributesClass
     * @param param the request object
     */
    public replaceVolumeAttributesClass(param: StorageV1alpha1ApiReplaceVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1alpha1VolumeAttributesClass> {
        return this.api.replaceVolumeAttributesClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableStorageV1beta1Api } from "./ObservableAPI.js";
import { StorageV1beta1ApiRequestFactory, StorageV1beta1ApiResponseProcessor} from "../apis/StorageV1beta1Api.js";

export interface StorageV1beta1ApiCreateVolumeAttributesClassRequest {
    /**
     * 
     * @type V1beta1VolumeAttributesClass
     * @memberof StorageV1beta1ApicreateVolumeAttributesClass
     */
    body: V1beta1VolumeAttributesClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApicreateVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApicreateVolumeAttributesClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApicreateVolumeAttributesClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApicreateVolumeAttributesClass
     */
    fieldValidation?: string
}

export interface StorageV1beta1ApiDeleteCollectionVolumeAttributesClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1beta1ApideleteCollectionVolumeAttributesClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1beta1ApiDeleteVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StorageV1beta1ApideleteVolumeAttributesClass
     */
    body?: V1DeleteOptions
}

export interface StorageV1beta1ApiGetAPIResourcesRequest {
}

export interface StorageV1beta1ApiListVolumeAttributesClassRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApilistVolumeAttributesClass
     */
    watch?: boolean
}

export interface StorageV1beta1ApiPatchVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApipatchVolumeAttributesClass
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StorageV1beta1ApipatchVolumeAttributesClass
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApipatchVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApipatchVolumeAttributesClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApipatchVolumeAttributesClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApipatchVolumeAttributesClass
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StorageV1beta1ApipatchVolumeAttributesClass
     */
    force?: boolean
}

export interface StorageV1beta1ApiReadVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApireadVolumeAttributesClass
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApireadVolumeAttributesClass
     */
    pretty?: string
}

export interface StorageV1beta1ApiReplaceVolumeAttributesClassRequest {
    /**
     * name of the VolumeAttributesClass
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApireplaceVolumeAttributesClass
     */
    name: string
    /**
     * 
     * @type V1beta1VolumeAttributesClass
     * @memberof StorageV1beta1ApireplaceVolumeAttributesClass
     */
    body: V1beta1VolumeAttributesClass
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApireplaceVolumeAttributesClass
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApireplaceVolumeAttributesClass
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApireplaceVolumeAttributesClass
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StorageV1beta1ApireplaceVolumeAttributesClass
     */
    fieldValidation?: string
}

export class ObjectStorageV1beta1Api {
    private api: ObservableStorageV1beta1Api

    public constructor(configuration: Configuration, requestFactory?: StorageV1beta1ApiRequestFactory, responseProcessor?: StorageV1beta1ApiResponseProcessor) {
        this.api = new ObservableStorageV1beta1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a VolumeAttributesClass
     * @param param the request object
     */
    public createVolumeAttributesClassWithHttpInfo(param: StorageV1beta1ApiCreateVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1VolumeAttributesClass>> {
        return this.api.createVolumeAttributesClassWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a VolumeAttributesClass
     * @param param the request object
     */
    public createVolumeAttributesClass(param: StorageV1beta1ApiCreateVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1beta1VolumeAttributesClass> {
        return this.api.createVolumeAttributesClass(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttributesClass
     * @param param the request object
     */
    public deleteCollectionVolumeAttributesClassWithHttpInfo(param: StorageV1beta1ApiDeleteCollectionVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionVolumeAttributesClassWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of VolumeAttributesClass
     * @param param the request object
     */
    public deleteCollectionVolumeAttributesClass(param: StorageV1beta1ApiDeleteCollectionVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionVolumeAttributesClass(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttributesClass
     * @param param the request object
     */
    public deleteVolumeAttributesClassWithHttpInfo(param: StorageV1beta1ApiDeleteVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1VolumeAttributesClass>> {
        return this.api.deleteVolumeAttributesClassWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a VolumeAttributesClass
     * @param param the request object
     */
    public deleteVolumeAttributesClass(param: StorageV1beta1ApiDeleteVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1beta1VolumeAttributesClass> {
        return this.api.deleteVolumeAttributesClass(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: StorageV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: StorageV1beta1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttributesClass
     * @param param the request object
     */
    public listVolumeAttributesClassWithHttpInfo(param: StorageV1beta1ApiListVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1VolumeAttributesClassList>> {
        return this.api.listVolumeAttributesClassWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind VolumeAttributesClass
     * @param param the request object
     */
    public listVolumeAttributesClass(param: StorageV1beta1ApiListVolumeAttributesClassRequest = {}, options?: ConfigurationOptions): Promise<V1beta1VolumeAttributesClassList> {
        return this.api.listVolumeAttributesClass(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttributesClass
     * @param param the request object
     */
    public patchVolumeAttributesClassWithHttpInfo(param: StorageV1beta1ApiPatchVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1VolumeAttributesClass>> {
        return this.api.patchVolumeAttributesClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified VolumeAttributesClass
     * @param param the request object
     */
    public patchVolumeAttributesClass(param: StorageV1beta1ApiPatchVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1beta1VolumeAttributesClass> {
        return this.api.patchVolumeAttributesClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified VolumeAttributesClass
     * @param param the request object
     */
    public readVolumeAttributesClassWithHttpInfo(param: StorageV1beta1ApiReadVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1VolumeAttributesClass>> {
        return this.api.readVolumeAttributesClassWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified VolumeAttributesClass
     * @param param the request object
     */
    public readVolumeAttributesClass(param: StorageV1beta1ApiReadVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1beta1VolumeAttributesClass> {
        return this.api.readVolumeAttributesClass(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttributesClass
     * @param param the request object
     */
    public replaceVolumeAttributesClassWithHttpInfo(param: StorageV1beta1ApiReplaceVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1beta1VolumeAttributesClass>> {
        return this.api.replaceVolumeAttributesClassWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified VolumeAttributesClass
     * @param param the request object
     */
    public replaceVolumeAttributesClass(param: StorageV1beta1ApiReplaceVolumeAttributesClassRequest, options?: ConfigurationOptions): Promise<V1beta1VolumeAttributesClass> {
        return this.api.replaceVolumeAttributesClass(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableStoragemigrationApi } from "./ObservableAPI.js";
import { StoragemigrationApiRequestFactory, StoragemigrationApiResponseProcessor} from "../apis/StoragemigrationApi.js";

export interface StoragemigrationApiGetAPIGroupRequest {
}

export class ObjectStoragemigrationApi {
    private api: ObservableStoragemigrationApi

    public constructor(configuration: Configuration, requestFactory?: StoragemigrationApiRequestFactory, responseProcessor?: StoragemigrationApiResponseProcessor) {
        this.api = new ObservableStoragemigrationApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroupWithHttpInfo(param: StoragemigrationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIGroup>> {
        return this.api.getAPIGroupWithHttpInfo( options).toPromise();
    }

    /**
     * get information of a group
     * @param param the request object
     */
    public getAPIGroup(param: StoragemigrationApiGetAPIGroupRequest = {}, options?: ConfigurationOptions): Promise<V1APIGroup> {
        return this.api.getAPIGroup( options).toPromise();
    }

}

import { ObservableStoragemigrationV1alpha1Api } from "./ObservableAPI.js";
import { StoragemigrationV1alpha1ApiRequestFactory, StoragemigrationV1alpha1ApiResponseProcessor} from "../apis/StoragemigrationV1alpha1Api.js";

export interface StoragemigrationV1alpha1ApiCreateStorageVersionMigrationRequest {
    /**
     * 
     * @type V1alpha1StorageVersionMigration
     * @memberof StoragemigrationV1alpha1ApicreateStorageVersionMigration
     */
    body: V1alpha1StorageVersionMigration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApicreateStorageVersionMigration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApicreateStorageVersionMigration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApicreateStorageVersionMigration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApicreateStorageVersionMigration
     */
    fieldValidation?: string
}

export interface StoragemigrationV1alpha1ApiDeleteCollectionStorageVersionMigrationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    pretty?: string
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    _continue?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    dryRun?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    fieldSelector?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    limit?: number
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    propagationPolicy?: string
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    timeoutSeconds?: number
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StoragemigrationV1alpha1ApideleteCollectionStorageVersionMigration
     */
    body?: V1DeleteOptions
}

export interface StoragemigrationV1alpha1ApiDeleteStorageVersionMigrationRequest {
    /**
     * name of the StorageVersionMigration
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    dryRun?: string
    /**
     * The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * Defaults to: undefined
     * @type number
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    gracePeriodSeconds?: number
    /**
     * if set to true, it will trigger an unsafe deletion of the resource in case the normal deletion flow fails with a corrupt object error. A resource is considered corrupt if it can not be retrieved from the underlying storage successfully because of a) its data can not be transformed e.g. decryption failure, or b) it fails to decode into an object. NOTE: unsafe deletion ignores finalizer constraints, skips precondition checks, and removes the object from the storage. WARNING: This may potentially break the cluster if the workload associated with the resource being unsafe-deleted relies on normal deletion flow. Use only if you REALLY know what you are doing. The default value is false, and the user must opt in to enable it
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    ignoreStoreReadErrorWithClusterBreakingPotential?: boolean
    /**
     * Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    orphanDependents?: boolean
    /**
     * Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    propagationPolicy?: string
    /**
     * 
     * @type V1DeleteOptions
     * @memberof StoragemigrationV1alpha1ApideleteStorageVersionMigration
     */
    body?: V1DeleteOptions
}

export interface StoragemigrationV1alpha1ApiGetAPIResourcesRequest {
}

export interface StoragemigrationV1alpha1ApiListStorageVersionMigrationRequest {
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    pretty?: string
    /**
     * allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    allowWatchBookmarks?: boolean
    /**
     * The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    _continue?: string
    /**
     * A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    fieldSelector?: string
    /**
     * A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    labelSelector?: string
    /**
     * limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * Defaults to: undefined
     * @type number
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    limit?: number
    /**
     * resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    resourceVersion?: string
    /**
     * resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    resourceVersionMatch?: string
    /**
     * &#x60;sendInitialEvents&#x3D;true&#x60; may be set together with &#x60;watch&#x3D;true&#x60;. In that case, the watch stream will begin with synthetic events to produce the current state of objects in the collection. Once all such events have been sent, a synthetic \&quot;Bookmark\&quot; event  will be sent. The bookmark will report the ResourceVersion (RV) corresponding to the set of objects, and be marked with &#x60;\&quot;k8s.io/initial-events-end\&quot;: \&quot;true\&quot;&#x60; annotation. Afterwards, the watch stream will proceed as usual, sending watch events corresponding to changes (subsequent to the RV) to objects watched.  When &#x60;sendInitialEvents&#x60; option is set, we require &#x60;resourceVersionMatch&#x60; option to also be set. The semantic of the watch request is as following: - &#x60;resourceVersionMatch&#x60; &#x3D; NotOlderThan   is interpreted as \&quot;data at least as new as the provided &#x60;resourceVersion&#x60;\&quot;   and the bookmark event is send when the state is synced   to a &#x60;resourceVersion&#x60; at least as fresh as the one provided by the ListOptions.   If &#x60;resourceVersion&#x60; is unset, this is interpreted as \&quot;consistent read\&quot; and the   bookmark event is send when the state is synced at least to the moment   when request started being processed. - &#x60;resourceVersionMatch&#x60; set to any other value or unset   Invalid error is returned.  Defaults to true if &#x60;resourceVersion&#x3D;\&quot;\&quot;&#x60; or &#x60;resourceVersion&#x3D;\&quot;0\&quot;&#x60; (for backward compatibility reasons) and to false otherwise.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    sendInitialEvents?: boolean
    /**
     * Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * Defaults to: undefined
     * @type number
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    timeoutSeconds?: number
    /**
     * Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApilistStorageVersionMigration
     */
    watch?: boolean
}

export interface StoragemigrationV1alpha1ApiPatchStorageVersionMigrationRequest {
    /**
     * name of the StorageVersionMigration
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigration
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigration
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigration
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigration
     */
    force?: boolean
}

export interface StoragemigrationV1alpha1ApiPatchStorageVersionMigrationStatusRequest {
    /**
     * name of the StorageVersionMigration
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigrationStatus
     */
    name: string
    /**
     * 
     * @type any
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigrationStatus
     */
    body: any
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigrationStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigrationStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigrationStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigrationStatus
     */
    fieldValidation?: string
    /**
     * Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
     * Defaults to: undefined
     * @type boolean
     * @memberof StoragemigrationV1alpha1ApipatchStorageVersionMigrationStatus
     */
    force?: boolean
}

export interface StoragemigrationV1alpha1ApiReadStorageVersionMigrationRequest {
    /**
     * name of the StorageVersionMigration
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireadStorageVersionMigration
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireadStorageVersionMigration
     */
    pretty?: string
}

export interface StoragemigrationV1alpha1ApiReadStorageVersionMigrationStatusRequest {
    /**
     * name of the StorageVersionMigration
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireadStorageVersionMigrationStatus
     */
    name: string
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireadStorageVersionMigrationStatus
     */
    pretty?: string
}

export interface StoragemigrationV1alpha1ApiReplaceStorageVersionMigrationRequest {
    /**
     * name of the StorageVersionMigration
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigration
     */
    name: string
    /**
     * 
     * @type V1alpha1StorageVersionMigration
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigration
     */
    body: V1alpha1StorageVersionMigration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigration
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigration
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigration
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigration
     */
    fieldValidation?: string
}

export interface StoragemigrationV1alpha1ApiReplaceStorageVersionMigrationStatusRequest {
    /**
     * name of the StorageVersionMigration
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigrationStatus
     */
    name: string
    /**
     * 
     * @type V1alpha1StorageVersionMigration
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigrationStatus
     */
    body: V1alpha1StorageVersionMigration
    /**
     * If \&#39;true\&#39;, then the output is pretty printed. Defaults to \&#39;false\&#39; unless the user-agent indicates a browser or command-line HTTP tool (curl and wget).
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigrationStatus
     */
    pretty?: string
    /**
     * When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigrationStatus
     */
    dryRun?: string
    /**
     * fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigrationStatus
     */
    fieldManager?: string
    /**
     * fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
     * Defaults to: undefined
     * @type string
     * @memberof StoragemigrationV1alpha1ApireplaceStorageVersionMigrationStatus
     */
    fieldValidation?: string
}

export class ObjectStoragemigrationV1alpha1Api {
    private api: ObservableStoragemigrationV1alpha1Api

    public constructor(configuration: Configuration, requestFactory?: StoragemigrationV1alpha1ApiRequestFactory, responseProcessor?: StoragemigrationV1alpha1ApiResponseProcessor) {
        this.api = new ObservableStoragemigrationV1alpha1Api(configuration, requestFactory, responseProcessor);
    }

    /**
     * create a StorageVersionMigration
     * @param param the request object
     */
    public createStorageVersionMigrationWithHttpInfo(param: StoragemigrationV1alpha1ApiCreateStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigration>> {
        return this.api.createStorageVersionMigrationWithHttpInfo(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * create a StorageVersionMigration
     * @param param the request object
     */
    public createStorageVersionMigration(param: StoragemigrationV1alpha1ApiCreateStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigration> {
        return this.api.createStorageVersionMigration(param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * delete collection of StorageVersionMigration
     * @param param the request object
     */
    public deleteCollectionStorageVersionMigrationWithHttpInfo(param: StoragemigrationV1alpha1ApiDeleteCollectionStorageVersionMigrationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteCollectionStorageVersionMigrationWithHttpInfo(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete collection of StorageVersionMigration
     * @param param the request object
     */
    public deleteCollectionStorageVersionMigration(param: StoragemigrationV1alpha1ApiDeleteCollectionStorageVersionMigrationRequest = {}, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteCollectionStorageVersionMigration(param.pretty, param._continue, param.dryRun, param.fieldSelector, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.labelSelector, param.limit, param.orphanDependents, param.propagationPolicy, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.body,  options).toPromise();
    }

    /**
     * delete a StorageVersionMigration
     * @param param the request object
     */
    public deleteStorageVersionMigrationWithHttpInfo(param: StoragemigrationV1alpha1ApiDeleteStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1Status>> {
        return this.api.deleteStorageVersionMigrationWithHttpInfo(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * delete a StorageVersionMigration
     * @param param the request object
     */
    public deleteStorageVersionMigration(param: StoragemigrationV1alpha1ApiDeleteStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<V1Status> {
        return this.api.deleteStorageVersionMigration(param.name, param.pretty, param.dryRun, param.gracePeriodSeconds, param.ignoreStoreReadErrorWithClusterBreakingPotential, param.orphanDependents, param.propagationPolicy, param.body,  options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResourcesWithHttpInfo(param: StoragemigrationV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1APIResourceList>> {
        return this.api.getAPIResourcesWithHttpInfo( options).toPromise();
    }

    /**
     * get available resources
     * @param param the request object
     */
    public getAPIResources(param: StoragemigrationV1alpha1ApiGetAPIResourcesRequest = {}, options?: ConfigurationOptions): Promise<V1APIResourceList> {
        return this.api.getAPIResources( options).toPromise();
    }

    /**
     * list or watch objects of kind StorageVersionMigration
     * @param param the request object
     */
    public listStorageVersionMigrationWithHttpInfo(param: StoragemigrationV1alpha1ApiListStorageVersionMigrationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigrationList>> {
        return this.api.listStorageVersionMigrationWithHttpInfo(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * list or watch objects of kind StorageVersionMigration
     * @param param the request object
     */
    public listStorageVersionMigration(param: StoragemigrationV1alpha1ApiListStorageVersionMigrationRequest = {}, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigrationList> {
        return this.api.listStorageVersionMigration(param.pretty, param.allowWatchBookmarks, param._continue, param.fieldSelector, param.labelSelector, param.limit, param.resourceVersion, param.resourceVersionMatch, param.sendInitialEvents, param.timeoutSeconds, param.watch,  options).toPromise();
    }

    /**
     * partially update the specified StorageVersionMigration
     * @param param the request object
     */
    public patchStorageVersionMigrationWithHttpInfo(param: StoragemigrationV1alpha1ApiPatchStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigration>> {
        return this.api.patchStorageVersionMigrationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update the specified StorageVersionMigration
     * @param param the request object
     */
    public patchStorageVersionMigration(param: StoragemigrationV1alpha1ApiPatchStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigration> {
        return this.api.patchStorageVersionMigration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StorageVersionMigration
     * @param param the request object
     */
    public patchStorageVersionMigrationStatusWithHttpInfo(param: StoragemigrationV1alpha1ApiPatchStorageVersionMigrationStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigration>> {
        return this.api.patchStorageVersionMigrationStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * partially update status of the specified StorageVersionMigration
     * @param param the request object
     */
    public patchStorageVersionMigrationStatus(param: StoragemigrationV1alpha1ApiPatchStorageVersionMigrationStatusRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigration> {
        return this.api.patchStorageVersionMigrationStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation, param.force,  options).toPromise();
    }

    /**
     * read the specified StorageVersionMigration
     * @param param the request object
     */
    public readStorageVersionMigrationWithHttpInfo(param: StoragemigrationV1alpha1ApiReadStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigration>> {
        return this.api.readStorageVersionMigrationWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read the specified StorageVersionMigration
     * @param param the request object
     */
    public readStorageVersionMigration(param: StoragemigrationV1alpha1ApiReadStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigration> {
        return this.api.readStorageVersionMigration(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StorageVersionMigration
     * @param param the request object
     */
    public readStorageVersionMigrationStatusWithHttpInfo(param: StoragemigrationV1alpha1ApiReadStorageVersionMigrationStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigration>> {
        return this.api.readStorageVersionMigrationStatusWithHttpInfo(param.name, param.pretty,  options).toPromise();
    }

    /**
     * read status of the specified StorageVersionMigration
     * @param param the request object
     */
    public readStorageVersionMigrationStatus(param: StoragemigrationV1alpha1ApiReadStorageVersionMigrationStatusRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigration> {
        return this.api.readStorageVersionMigrationStatus(param.name, param.pretty,  options).toPromise();
    }

    /**
     * replace the specified StorageVersionMigration
     * @param param the request object
     */
    public replaceStorageVersionMigrationWithHttpInfo(param: StoragemigrationV1alpha1ApiReplaceStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigration>> {
        return this.api.replaceStorageVersionMigrationWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace the specified StorageVersionMigration
     * @param param the request object
     */
    public replaceStorageVersionMigration(param: StoragemigrationV1alpha1ApiReplaceStorageVersionMigrationRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigration> {
        return this.api.replaceStorageVersionMigration(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified StorageVersionMigration
     * @param param the request object
     */
    public replaceStorageVersionMigrationStatusWithHttpInfo(param: StoragemigrationV1alpha1ApiReplaceStorageVersionMigrationStatusRequest, options?: ConfigurationOptions): Promise<HttpInfo<V1alpha1StorageVersionMigration>> {
        return this.api.replaceStorageVersionMigrationStatusWithHttpInfo(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

    /**
     * replace status of the specified StorageVersionMigration
     * @param param the request object
     */
    public replaceStorageVersionMigrationStatus(param: StoragemigrationV1alpha1ApiReplaceStorageVersionMigrationStatusRequest, options?: ConfigurationOptions): Promise<V1alpha1StorageVersionMigration> {
        return this.api.replaceStorageVersionMigrationStatus(param.name, param.body, param.pretty, param.dryRun, param.fieldManager, param.fieldValidation,  options).toPromise();
    }

}

import { ObservableVersionApi } from "./ObservableAPI.js";
import { VersionApiRequestFactory, VersionApiResponseProcessor} from "../apis/VersionApi.js";

export interface VersionApiGetCodeRequest {
}

export class ObjectVersionApi {
    private api: ObservableVersionApi

    public constructor(configuration: Configuration, requestFactory?: VersionApiRequestFactory, responseProcessor?: VersionApiResponseProcessor) {
        this.api = new ObservableVersionApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get the version information for this server
     * @param param the request object
     */
    public getCodeWithHttpInfo(param: VersionApiGetCodeRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<VersionInfo>> {
        return this.api.getCodeWithHttpInfo( options).toPromise();
    }

    /**
     * get the version information for this server
     * @param param the request object
     */
    public getCode(param: VersionApiGetCodeRequest = {}, options?: ConfigurationOptions): Promise<VersionInfo> {
        return this.api.getCode( options).toPromise();
    }

}

import { ObservableWellKnownApi } from "./ObservableAPI.js";
import { WellKnownApiRequestFactory, WellKnownApiResponseProcessor} from "../apis/WellKnownApi.js";

export interface WellKnownApiGetServiceAccountIssuerOpenIDConfigurationRequest {
}

export class ObjectWellKnownApi {
    private api: ObservableWellKnownApi

    public constructor(configuration: Configuration, requestFactory?: WellKnownApiRequestFactory, responseProcessor?: WellKnownApiResponseProcessor) {
        this.api = new ObservableWellKnownApi(configuration, requestFactory, responseProcessor);
    }

    /**
     * get service account issuer OpenID configuration, also known as the \'OIDC discovery doc\'
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDConfigurationWithHttpInfo(param: WellKnownApiGetServiceAccountIssuerOpenIDConfigurationRequest = {}, options?: ConfigurationOptions): Promise<HttpInfo<string>> {
        return this.api.getServiceAccountIssuerOpenIDConfigurationWithHttpInfo( options).toPromise();
    }

    /**
     * get service account issuer OpenID configuration, also known as the \'OIDC discovery doc\'
     * @param param the request object
     */
    public getServiceAccountIssuerOpenIDConfiguration(param: WellKnownApiGetServiceAccountIssuerOpenIDConfigurationRequest = {}, options?: ConfigurationOptions): Promise<string> {
        return this.api.getServiceAccountIssuerOpenIDConfiguration( options).toPromise();
    }

}
